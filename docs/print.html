<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Desenvolvimento de Jogos online com Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-quemsou.html"><strong aria-hidden="true">1.1.</strong> Quem sou eu? (Sobre a autora)</a></li></ol></li><li class="chapter-item expanded "><a href="part-1/00-capa.html"><strong aria-hidden="true">2.</strong> Conceitos B√°sicos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-1/01-arq.html"><strong aria-hidden="true">2.1.</strong> Arquitetura de servidores</a></li><li class="chapter-item expanded "><a href="part-1/02-prd-rec.html"><strong aria-hidden="true">2.2.</strong> Predi√ß√£o e Reconcilia√ß√£o</a></li><li class="chapter-item expanded "><a href="part-1/03-interpolacao.html"><strong aria-hidden="true">2.3.</strong> Interpola√ß√£o de Entidades</a></li><li class="chapter-item expanded "><a href="part-1/04-lag.html"><strong aria-hidden="true">2.4.</strong> Compensac√£o de Lag</a></li></ol></li><li class="chapter-item expanded "><a href="part-2/00-intro.html"><strong aria-hidden="true">3.</strong> Multiplayer Snake Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-2/01-bevy.html"><strong aria-hidden="true">3.1.</strong> Sobre a Bevy</a></li><li class="chapter-item expanded "><a href="part-2/02-ecs.html"><strong aria-hidden="true">3.2.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="part-2/03-cabeca.html"><strong aria-hidden="true">3.3.</strong> A Cabe√ßa da Cobra</a></li><li class="chapter-item expanded "><a href="part-2/04-grid.html"><strong aria-hidden="true">3.4.</strong> Grade de Movimento</a></li><li class="chapter-item expanded "><a href="part-2/05-spawnfood.html"><strong aria-hidden="true">3.5.</strong> Gerador de Comidas</a></li><li class="chapter-item expanded "><a href="part-2/06-cadencia.html"><strong aria-hidden="true">3.6.</strong> Melhorando a Cad√™ncia do Movimento</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Desenvolvimento de Jogos online com Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="desenvolvimento-de-jogos-online-com-rust"><a class="header" href="#desenvolvimento-de-jogos-online-com-rust">Desenvolvimento de Jogos Online com Rust</a></h1>
<p>Por Julia Naomi Boeira.</p>
<p><a href="https://www.patreon.com/naomijub"><img src="https://media.giphy.com/media/FOe2EcTuBYGbG0Yc3w/giphy.gif" alt="" /></a> <br/>
<a href="https://www.patreon.com/naomijub">Patreon link</a></p>
<p>Escrever um livro open source √© um trablho que precisa de incentivo e por isso Github Sponsor e Patreon s√£o coisas importantes, pois al√©m de atuarem como incetivo, s√£o um bomr econhecimento do nosso trabalho. Escrevi bastantes livros pela casa do c√≥digo, mas em especial no assunto Rust e Games eu sinto que falta alcance, e por isso gostaria de continuar produzindo esse tipo de material.</p>
<h2 id="sobre-o-livro"><a class="header" href="#sobre-o-livro">Sobre o livro</a></h2>
<p>At√© o momento planejei 3 partes para este livro:</p>
<ol>
<li><a href="part-1/00-capa.html">Conceitos B√°sicos</a>, onde vamos falar sobre como funciona um jogo online e quais s√£o suas limita√ß√µes.</li>
<li>Jogo da cobrinha com a engine Bevy, essa √© a parte menos criativa do processo e √© uma c√≥pia traduzida deste tutorial <a href="https://mbuffett.com/posts/bevy-snake-tutorial/">Bevy Snake Tutorial</a>. A diferen√ßa √© que vou adicionar elementos de um jogo multiplayer local.</li>
<li>Servidor autorit√°rio com a Bevy.</li>
</ol>
<p>ESPERO QUE APROVEITEM A LEITURA e feedbacks s√£o bem vindos. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quem-sou-eu"><a class="header" href="#quem-sou-eu">Quem sou eu</a></h1>
<p>Eu sou uma desenolvedora de jogos na Ubisoft Winnipeg atuando no desenvolvimento de sistemas online, middlewares e ferramentas para jogos. Trabalho principalmente com C++, mas um pouco de C# e Rust. Sou autora dos livros:</p>
<ul>
<li>üìñ <a href="https://www.apress.com/gp/book/9781484232156">Lean Game Development - Ingl√™s - Apress</a></li>
<li>üìñ <a href="https://www.casadocodigo.com.br/products/livro-lean-game-development">Lean Game Development - Portugu√™s - Casa do C√≥digo</a></li>
<li>üìñ <a href="https://www.casadocodigo.com.br/products/livro-rust-funcional-concorrente">Programa√ß√£o Funcional e Concorrente em Rust - Casa do C√≥digo</a></li>
<li>üìñ <a href="https://www.casadocodigo.com.br/products/livro-tdd-games">TDD para Games - Casa do C√≥digo</a></li>
<li>üìñ <a href="https://github.com/naomijub/web-dev-rust-book">[OPEN SOURCE] Desenvolvimento Web com Rust</a></li>
</ul>
<p>E atualmente estou desenvolvendo em paralelo a este livro o livro <a href="https://github.com/naomijub/Unity-FPS-game-with-TDD-Book">Unity FPS game with TDD - Ingl√™s</a>.</p>
<p>Tenho atuado como evangelista voluntaria de Rust desde 2017 quando me deparei com Rust pela primeira vez e percebi que esta maravilhosa linguagem era um raio de esperan√ßa nos problemas que eu tinha no desenvolvimento de jogos com C++.</p>
<p>Hobbies como engenheira s√£o aprender novas linguagens, em especial de paradigmas diferentes ou que pelo menos possuem uma forma bem diferente de resolver problemas, tornando Clojure e Elixir minhas duas outras linguagens favoritas. E no meu tempo livre escrever e fazer prototipos bobos de jogos como esses (quando eu estava aprendendo Java) https://github.com/naomijub/DiammondSeek e https://github.com/naomijub/PacmanLabyrinth.</p>
<p>Curiosidade sobre aprender linguagens de programa√ß√£o, tentei aprender Java na faculdade, mas simplesmente n√£o entrava na minha cabe√ßa, foi gra√ßas a XNA e aos C# que consegui aprender Java e arrumar trabalho com software corporativo. Tentei aprender Go 3 vezes e NUNCA entra na minha cabe√ßa. Trabalhei muito com Python a ponto de dizer que era uma das minhas linguagens favoritas, mas hoje em dia eu fujo de qualquer projeto Python.</p>
<p>Passei pelas faculdades de Matematica Aplicada, Engenharia de Materiais e Ci√™ncias da Computa√ß√£o. Larguei a CC porque j√° estava cursando mestrado em intelig√™ncia artificial aplicada a engenharia de materiais e depois aiinda fiz especializa√ß√£o em desenvolvimento de jogos para suprir as √°reas que faltavam do meu conhecimento em jogos. A empresa que mais gostei de trabalhar √© a Ubiisoft DE WINNIPEG, mas outras empresas que gostei muito foram a Thoughtworks at√© 2018, onde conheci pessoas incr√≠veis que s√£o minhas amigas at√© hoje, e Nubank que foi um lugar de muito aprendizado.</p>
<p>Para d√∫vidas sobre o livro, discuss√µes sobre o tema e corre√ß√µes sugiro abrir <a href="https://github.com/naomijub/Rust-game-dev/issues">issues</a> ou criar <a href="https://github.com/naomijub/Rust-game-dev">Pull Requests</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conceitos-importantes-para-o-desenvolvimento-de-servi√ßos-de-jogos-digitais"><a class="header" href="#conceitos-importantes-para-o-desenvolvimento-de-servi√ßos-de-jogos-digitais">Conceitos importantes para o desenvolvimento de servi√ßos de jogos digitais</a></h1>
<ol>
<li>O problema e sua arquitetura b√°sica.</li>
<li>Predi√ß√£o e reconcilia√ß√£o.</li>
<li>Interpola√ß√£o de entidades.</li>
<li>Compensa√ß√£o de lag.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="o-problema-e-sua-arquitetura-b√°sica"><a class="header" href="#o-problema-e-sua-arquitetura-b√°sica">O problema e sua arquitetura b√°sica.</a></h1>
<p>Neste cap√≠tulo vamos entender quais os problemas que servi√ßos para games enfrentam e quais s√£o algumas das formas de resolv√™-los para obtermos um conjunto de servi√ßos que tornam o desenvolvimento de jogos multiplayer uma realidade. </p>
<blockquote>
<p><em>Multiplayer</em></p>
<p>Jogos multiplayer s√£o jogos com mais de uma pessoa jogando simultaneamente se conectando atrav√©s de um servidor.</p>
</blockquote>
<h2 id="introdu√ß√£o"><a class="header" href="#introdu√ß√£o">Introdu√ß√£o</a></h2>
<p>Desenvolver um jogo √© bastante complicado, agora desenvolver um jogo para mais de uma pessoa jogando √© ainda mais complicado. Felizmente, podemos resumir os problemas que servidores de jogos possuem em duas categorias:</p>
<ol>
<li>Humanos maliciosos.</li>
<li>F√≠sica real√≠stica.</li>
</ol>
<h3 id="humanos-maliciosos"><a class="header" href="#humanos-maliciosos">Humanos Maliciosos</a></h3>
<p>Tudo come√ßa com o desejo das pessoas de trapacear em um jogo.</p>
<p>Podemos dizer que para jogos single-player, ou de somente uma pessoa jogando, trapacear afeta a experi√™ncia, mas √© uma escolha da pessoa burlar a experi√™ncia do jogo, a final a trapa√ßa n√£o afeta ningu√©m al√©m da pessoa, por√©m para jogos multiplayer o cen√°rio √© diferente. Em um jogo multiplayer, uma pessoa burlando as regras do jogo pode conseguir algumas vantagens que al√©m de afetar sua experi√™ncia, tornam a experi√™ncia das outras pessoas muito pior. Alguns exemplos que j√° vi na minha vida:</p>
<ul>
<li>Vida muito maior que 100%, ou seja, a pessoa possuia 1000% de vida em uma partida, tornando ela quase imortal, j√° que colecionava muito mais recursos.</li>
<li>Tiros duplos ou triplos, ou seja, para cada vez que a pessoa realizava um tiro, duas ou tr√™s balas eram enviadas ao mesmo tempo, reduzindo muito as chances do alvo de sobreviver.</li>
<li>Atravessar paredes, n√£o sei bem como este mod funcionava, mas acredito que projetava a pessoa para al√©m do objeto de colis√£o.</li>
<li>Paredes invis√≠veis, ou seja, a pessoa havia removido a renderiza√ß√£o de objetos inanimados, o que a permitia visualizar todos os alvos antes de ser percebida.</li>
<li>Velocidade 2, ou seja, para cada passo da pessoa, o jogo a movia 2 vezes mais r√°pido.</li>
</ul>
<p>Tendo estes eventos em mente, podemos concluir que existe uma √∫nica solu√ß√£o realmente confi√°vel para um servidor N√ÉO CONFIAR NO USU√ÅRIO.</p>
<h2 id="como-n√£o-confiar-no-usu√°rio"><a class="header" href="#como-n√£o-confiar-no-usu√°rio">Como n√£o confiar no usu√°rio?</a></h2>
<p>A resposta para est√° pergunta √© na verdade bastante simples, o cliente, ou seja a pessoa jogando, deve fornecer o m√≠nimo de informa√ß√µes em rela√ß√£o ao seu posicionamento, balas disparadas, dire√ß√£o, etc. Enquanto isso, o servidor deve ser autorit√°rio, recendendo estes comandos b√°sicos e informado para o cliente o que est√° acontecendo. Em outras palavras, o cliente envia comandos e bot√µes pressionados para o servidor, o servidor executa o pr√≥ximo passo do jogo e devolve ao cliente as novas informa√ß√µes. Isso n√£o vai impedir que o servidor seja explorado de vulnerabilidades, mas reduzir√° drasticamente a capacidade de uma pessoa jogando de trapacear. Assim, para o caso da pessoa que est√° dando tiros m√∫ltiplos, ela pode at√© ver 3 tiros saindo de sua arma, mas o servidor reconhecer√° somente 1 e propagar√° ao resto do jogo somente 1. </p>
<p>Resumindo, o gerenciamento do estado do jogo √© realizado apenas pelo servidor. Clientes enviam apenas suas intera√ß√µes com o controle, teclado e mouse para o servidor. O servidor atualiza o estado do jogo e envia esta informa√ß√£o de volta aos clientes que apenas renderizam ela em sua tela.</p>
<h2 id="o-problema-com-a-f√≠sica"><a class="header" href="#o-problema-com-a-f√≠sica">O problema com a f√≠sica</a></h2>
<p>Parece uma solu√ß√£o perfeita n√©? Infelizmente ela funciona bem somente quando o jogo √© baseado em turnos, como jogos de carta e alguns RPGs, ou a rede √© em LAN, j√° que neste cen√°rio a comunica√ß√£o com o servidor √© considerada instant√¢nea. Para jogos como Call of Duty e Rainbow Six est√° estrat√©gia vai contar com um enorme delay j√° que precisam se conectar com servidores distantes.</p>
<p>Assim, vamos supor o meu cen√°rio. Mesmo que minha conex√£o √† internet seja sensacional (mentira, isso n√£o existe), estou em Porto Alegre e o servidor mais pr√≥ximo est√° em S√£o Paulo para o jogo X. Porto Alegre e S√£o Paulo est√£o distantes entre si mais de 1100 km. Na f√≠sica a velocidade da luz √© a maior velocidade ating√≠vel por um corpo (photons no caso), ou seja 300.000 km/s no v√°cuo, assim a luz levaria 3,7 milisegundos para percorrer os 1100 km (1100/300000 = 0,0036667 segundos). Essa √© a velocidade da luz no v√°cuo, parece bem otimista n√©? Mas neste caso estamos falando de bytes trafegando pela internet, que na pr√°tica s√£o el√©trons e pulsos de luz trafegando por um cabo, e provavelmente n√£o em linha reta, o que deve aumentar esse valor de 3,7 por alguns microsegundos. Existe mais um fator importante em como a internet funciona, os dados trafegados pela internet s√£o na verdade uma s√©ries de pacotes, ou <em>hops</em>, que trafegam de um roteador ao outro, certamente abaixo da velocidade da luz. Al√©m disso, roteadores possuem um atraso extra, j√° que todos os pacotes devem ser abertos, copiados e inspecionados para ent√£o serem reroteados a seus destinos finais.</p>
<p>Vamos ent√£o dizer que o atraso dos meus pacotes at√© S√£o Paulo leva 25 ms, o que seria um tempo excepcional (neste momento um ping da minha m√°quina ao google.com est√° levando entre 25 e 30 ms), mas tempos de 50 ms e at√© 200 ms n√£o seria impressionantes para certas situa√ß√µes. Agora vamos dizer que nossa jogadora apertou para atirar no momento x, isso quer dizer que nosso servidor receber√° a a√ß√£o de atirar 25 ms depois. Digamos que nosso servidor processe o evento em um tempo substancialmente menor que 1 milisegundo, algo como 500 us, isso quer dizer que quando o servidor responder, a jogadora receber√° essa atualiza√ß√£o 50 ms depois de ter clicado para atirar. Humanos em m√©dia enxergam 25 frames por segundo, o que indica que o delay j√° √© maior que nossa capacidade de observa√ß√£o por 10 ms. Esses 10 ms de delay na nossa percep√ß√£o j√° s√£o suficiente para termos uma experi√™ncia ruim de jogabilidade, ou seja, o famoso <em>lag</em>, ou atraso. A imagem a seguir demonstra este efeito:</p>
<p><img src="part-1/../imagens/ping_time.jpg" alt="Diagrama de atraso na conex√£o cliente servidor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predi√ß√£o-e-reconcilia√ß√£o"><a class="header" href="#predi√ß√£o-e-reconcilia√ß√£o">Predi√ß√£o e Reconcilia√ß√£o</a></h1>
<p>No cap√≠tulo anterior falamos sobre o lag, ou atraso entre a√ß√£o no cliente e a atualiza√ß√£o enviada pelo servidor nos baseando no modelo de cliente servidor na qual o cliente n√£o responde seu estado, mas sim a a√ß√£o desejada, para que o servidor atualize seu estado. Um jogo que pode levar algumas fra√ß√µes de segundo para atualizar o estado pode ser considerado de jogabilidade ruim ou injog√°vel devido ao lag de renderiza√ß√£o. Assim, neste cap√≠tulo vamos explorar uma solu√ß√£o para minimizar este problema.</p>
<h2 id="predi√ß√£o-pelo-lado-do-cliente"><a class="header" href="#predi√ß√£o-pelo-lado-do-cliente">Predi√ß√£o pelo lado do cliente</a></h2>
<p>Como a maior parte dos jogos √© deterministico, ou seja, n√£o h√° aleatoriedade no resultado, podemos prever qual vai ser o pr√≥ximo passo do jogo antes do servidor responder. Para maior parte das pessoas jogando esta experi√™ncia ser√° &quot;id√™ntica&quot; ao jogo sem servidor, mas para as pessoas trapaceando a experi√™ncia n√£o ser√° realistica, desfavorecendo o jogo com trapa√ßas. Assim, podemos assumir que nosso servidor receber√° a√ß√µes v√°lidas para 99% dos casos, nos permitindo prever o pr√≥ximo instante.</p>
<p>No cen√°rio que descrevemos anteriormente nossa a√ß√£o com o servidor levava 50 ms para atualizar o estado do jogo, para s√≥ ent√£o uma anima√ß√£o ser ativada (digamos que ela leve mais 50 ms) como a imagem a seguir nos mostra:</p>
<p><img src="part-1/../imagens/animation_time.jpg" alt="Diagrama de atraso na conex√£o cliente servidor com tempo de anima√ß√£o" /></p>
<p>Nessa imagem podemos ver que o atraso do servidor (50 ms) mais o tempo de anima√ß√£o (50 ms) far√° com que percebemos o tiro apenas 100 ms depois dele ter sido realizado, ou seja, no terceiro frame que nosso olho detecta, certamente uma experi√™ncia desagrad√°vel. </p>
<p>Como o jogo nosso jogo √© deterministico, podemos presumir que a a√ß√£o ser√° executada com sucesso no servidor, aplicar nossas regras locais de valida√ß√£o e iniciar a anima√ß√£o do tiro no momento em que pressionamos o bot√£o para realizar a a√ß√£o. Para a grande maioria dos casos a atualiza√ß√£o do servidor e o final da anima√ß√£o v√£o coincidir em estado e fizemos um predi√ß√£o bem sucedida, fazendo com que n√£o exista atrasos entre a a√ß√£o e a renderiza√ß√£o. Para os casos de trapa√ßa a anima√ß√£o ocorrer√°, mas em nada afetar√° o estado geral do jogo, somente afetar√° negativamente a experi√™ncia do usu√°rio trapacendo.</p>
<h3 id="problemas-de-sincroniza√ß√£o"><a class="header" href="#problemas-de-sincroniza√ß√£o">Problemas de sincroniza√ß√£o</a></h3>
<p>Infelizmente essa estrat√©gia n√£o √© perfeita e problemas de sincroniza√ß√£o ou eventos conflitantes podem acontecer. Imagine agora o cen√°rio na qual o personagem est√° se movimentando e o tempo de atraso √© 75 ms em vez dos 50 ms anteriores, o tempo da anima√ß√£o √© de 30 ms e a pessoa pressiona para se movimentar para frente 2 vezes seguidas. A imagem a seguir e os passos marcados na imagem exemplificam:</p>
<p><img src="part-1/../imagens/sync_problem.jpg" alt="Diagrama com problemas de sincroniza√ß√£o de a√ß√µes" /></p>
<ol start="0">
<li>Personagem est√° o ponto <code>(0,0)</code> no instante 0 ms.</li>
<li>Neste mesmo instante a pessoa pressiona para se movimentar enviando uma a√ß√£o para o servidor que durar√° 75 ms.</li>
<li>A a√ß√£o do passo 1 ativou uma anima√ß√£o que moveu o personagem para a posi√ß√£o <code>(0,1)</code> 30 ms depois.</li>
<li>Na posi√ß√£o <code>(0,1)</code> uma nova a√ß√£o de movimenta√ß√£o acontece, enviando esta nova a√ß√£o para o servidor que durar√° mais 75 ms.</li>
<li>A a√ß√£o do passo 3 ativou uma nova anima√ß√£o que moveu o personagem para a posi√ß√£o <code>(0,2)</code> 30 ms depois. J√° se passaram 60 ms.</li>
<li>15 ms depois de terminar a a√ß√£o 4, o servidor respondeu a a√ß√£o 1 fazendo o personagem voltar para posi√ß√£o <code>(0,1)</code>. J√° se passaram 75 ms.</li>
<li>30 ms depois de terminar a a√ß√£o 5, o servidor respondeu a √¶√ß√£o 3 fazendo o personagem voltar para posi√ß√£o <code>(0,2)</code>. Ja se passaram 105 ms.</li>
</ol>
<p>Com este detalhamento podemos ver que pelo ponto de vista da pessoa jogando, o personagem vai responder as duas primeiras a√ß√µes se movimentando at√© a posi√ß√£o <code>(0,2)</code> para ent√£o voltar para posi√ß√£o <code>(0,1)</code> e depois ainda voltar para posi√ß√£o <code>(0,2)</code> gerando uma p√©ssima experi√™ncia de jogo, for√ßando assim a adotarmos uma estrat√©gia de reconcilia√ß√£o.</p>
<h2 id="reconciliac√£o-pelo-servidor"><a class="header" href="#reconciliac√£o-pelo-servidor">Reconciliac√£o pelo servidor</a></h2>
<p>A chave deste problema √© entender a diferen√ßa temporal dos cliente e do servidor, j√° que o cliente v√™ o jogo em tempo real (presente) e o servidor autorit√°rio est√° no passado. Assim, sempre haver√° uma diferen√ßa de sequ√™ncia de comandos a serem processados entre o cliente e o servidor. Felizmente isso n√£o √© muito dif√≠cil de resolver.</p>
<p>Primeiro passo √© fazer com que o cliente salve suas a√ß√µes em uma sequ√™ncia de comandos, assim a primeira movimenta√ß√£o seria a a√ß√£o <code>#1</code> e a segunda movimenta√ß√£o seria a a√ß√£o <code>#2</code>. Logo, o servidor poder√° respoder√° responder uma a√ß√£o identificando a qual comando ela pertence. A figura a seguir exemplifica o que acontece:</p>
<p><img src="part-1/../imagens/reconciliacao.jpg" alt="Diagrama de reconcilia√ß√£o de a√ß√µes" /></p>
<ol>
<li>O evento <code>#1</code> √© lancado, 30 ms depois da anima√ß√£o a posi√ß√£o <code>#1 =&gt; (0,1)</code> √© registrada e 38 ms depois o servidor recebe a a√ß√£o <code>#1</code>. A sequ√™ncia de comandos √© <code>[#1 =&gt; (0,1)]</code>.</li>
<li>O evento <code>#2</code> √© lancado, 30 ms depois da anima√ß√£o a posi√ß√£o <code>#2 =&gt; (0,2)</code> √© registrada e 38 ms depois o servidor recebe a a√ß√£o <code>#2</code>.  A sequ√™ncia de comandos √© <code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>.</li>
<li>O evento <code>#1</code> √© retornado pelo servidor com o valor <code>#1 =&gt; (0,1)</code>. A fun√ß√£o <code>check</code> para o estado da sequ√™ncia de comandos atual (<code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>) e o evento <code>#1 =&gt; (0,1)</code> recebido √© executado para reconciliar. Remove todos os comandos at√© <code>#1 =&gt; (0,1)</code> da sequ√™ncia de comandos.</li>
<li>O evento <code>#2</code> √© retornado pelo servidor com o valor <code>#2 =&gt; (0,2)</code>. A fun√ß√£o <code>check</code> para o estado da sequ√™ncia de comandos atual (<code>[#2 =&gt; (0,2)]</code>) e o evento <code>#2 =&gt; (0,2)</code> recebido √© executado para reconciliar. Remove todos os comandos at√© <code>#2 =&gt; (0,2)</code> da sequ√™ncia de comandos.</li>
<li>Sequ√™ncia de comandos √© <code>[]</code>.</li>
</ol>
<blockquote>
<p><strong>Descri√ß√£o da fun√ß√£o <code>check</code></strong></p>
<ol>
<li>Argumentos s√£o <strong>sequ√™ncia de comandos executados</strong> e <strong>evento #</strong>.</li>
<li>Verifica se o valor de <code>#n</code> na sequ√™ncia de comando √© igual ao que o servidor retornou. Caso n√£o for igual retorna erro.</li>
<li>Aplica o pr√≥ximo evento, <code>#n+1</code>, ao resultado do evento <code>#n</code>. Caso o resultado de <code>#n</code> mais o evento <code>#n+1</code> n√£o corresponder ao evento salvo na sequ√™ncia de comandos para <code>#n+1</code> retornar erro.
<strong>Observa√ß√£o</strong>: Se o evento que o servidor responder n√£o for <code>#n</code> esperado, podemos concluir que o pacote se perdeu ou o servidor retornou um erro, assim existem duas alternativas <strong>1.</strong> descartar todos os pacotes at√© o evento recebido e fazer o check, ou <strong>2.</strong> aplciar todos os eventos anteriores at√© o evento recebido. Particularmente vejo a solua√ß√£o <strong>1</strong> sendo a mais comum, pois sabemos que o estado anterior est√° certo.</li>
</ol>
</blockquote>
<p>Este √© um exemplo bem simples de movimenta√ß√£o e bastante intuitivo de visualizar, mas as aplica√ß√µes de predi√ß√£o e reconcilia√ß√£o podem ser feitas em praticamente qualquer √°rea do jogo e qualquer tipo de jogo. Imagine um jogo de corrida multiplayer e voc√™ est√° na linha de chegada em velocidade m√°xima, com um carro logo atr√°s de voc√™. No pr√≥ximo segundo considerando as atuais circunst√¢ncias, √© √≥bvio que voc√™ vai ganhar, pois voc√™ est√° na frente do outro carro e com uma velocidade maior, mas agora imagine que alguns mil√©simos antes do final da corrida a outra pessoa apertou o bot√£o de nitro e te ultrapassou. A predi√ß√£o diria que seu carro ganharia a corrida, mas o servidor disse que n√£o e voc√™ ficou em segundo lugar. Isso nos leva a um ponto interessante, mesmo em ambientes determin√≠sticos, existe a chance da predi√ß√£o e da reconcilia√ß√£o n√£o serem iguais, Para um cen√°rio de fim de jogo como descrito aqui √© bastante trivial a resposta, ignore a predi√ß√£o e responda com o resultado do servidor, por√©m se isso acontecer frequentemente no meio do jogo a experi√™ncia de jogabilidade vai ser ruim.</p>
<p>No pr√≥ximo cap√≠tulo vamos explorar como resolver este problema de predi√ß√£o e reconcilia√ß√£o atrav√©s de interpola√ß√£o de entidades.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpola√ß√£o-de-entidades"><a class="header" href="#interpola√ß√£o-de-entidades">Interpola√ß√£o de Entidades</a></h1>
<p>Nos cap√≠tulos anteriores lidamos com o problema de uma pessoa poder trapacear e como fazer com que o jogo se mantenha conciliado com um servidor autorit√°rio dando a sensa√ß√£o de que o servidor n√£o existe, por√©m n√£o expandimos este problema para quando estamos lidando com mais de uma pessoa jogando online. Neste cap√≠tulo vamos explorar t√©cnicas que nos permitem manter a jogabilidade quando v√°rias pessoas est√£o interagindo umas com as outras em um ambiente online.</p>
<h2 id="lidando-com-centenas-de-a√ß√µes-simult√¢neas"><a class="header" href="#lidando-com-centenas-de-a√ß√µes-simult√¢neas">Lidando com centenas de a√ß√µes simult√¢neas</a></h2>
<p>No cap√≠tulo anterior falamos sobre o servidor processar uma sequ√™ncia de comandos e retornar como eventos autorit√°rios para o cliente. Imagine agora que este cliente est√° alucinadamente mandando eventos para o servidor e que ele n√£o est√° sozinho, pois existem mais uma dezena de clientes mandando eventos simultaneamente para o servidor. Sendo assim, atualizar o estado do jogo para cada comando recebido de cada cliente e depois transmitir o estado do jogo de volta para cada cliente consumiria muita CPU e muita banda.</p>
<p>Tendo em vista evitar o consumo desnecess√°rio de CPU e banda outra abordagem parece fundamental. Esta nova abordagem consiste em enfileirar os comandos que os clientes enviam, sem processar eles, e em vez de atualizar o estado do jogo imediatamente para cada comando, fazemos atualiza√ß√µes peri√≥dicas e de baixa frequ√™ncia, por exemplo 10 vezes por segundo. Este atraso entre cada update, no caso do nosso exemplo de 100 ms, √© chamado de <em>time step</em>, ou passo temporal. O <em>time step</em> √© definido como uma itera√ß√£o de loop de update na qual todas as informa√ß√µes n√£o processdas de todos clientes s√£o aplicadas e o novo estado √© transmitido para todos os clientes. Ou seja, o estado do jogo √© atualizado com uma periodicidade espec√≠fica de forma independente e n√£o √© afetado pela quantidade de clientes e seus comandos.</p>
<p><strong>Obs</strong>: Muitas vezes a f√≠sica do jogo √© atualizada em passos de tempo menor para aumentar a previsibilidade.</p>
<h2 id="updates-de-baixa-frequ√™ncia"><a class="header" href="#updates-de-baixa-frequ√™ncia">Updates de baixa frequ√™ncia</a></h2>
<p>Seguindo com o conceito de um update de estado a cada 100 ms um novo problema aparece, os outros clientes n√£o tem ideia de como seus oponentes est√£o se atualizando, gerando eventos que parecem bastante bruscos a cada atualiza√ß√£o. Ou seja, predi√ß√£o e reconcilia√ß√£o funcionam muito bem para o lado do cliente, mas n√£o para o resto das pessoas jogando. A imagem a seguir detalha melhor essa situa√ß√£o:</p>
<p><img src="part-1/../imagens/step_time.jpg" alt="Diagrama de efeitos do step time para dois clientes" /></p>
<p>Na imagem anterior podemos ver o mesmo cen√°rio de predi√ß√£o e reconcilia√ß√£o funcionando muito bem para o <code>Cliente 1</code>, permitindo que sua jogabilidade seja coerente com a jogabilidade de um jogo single-player, por√©m para o <code>Cliente 2</code> podemos ver que as transi√ß√µes <code>(0,0) -&gt; (0, 1)</code> e <code>(0, 1) -&gt; (0, 2)</code> do <code>Cliente 1</code> s√£o bruscas para o <code>Cliente 2</code>, j√° que estas atualiza√ß√µes dependem exclusivamente das atualiza√ß√µes do servidor.</p>
<p>Agora voltando ao exemplo dos carros que mencionamos no final do cap√≠tulo anterior. Estamos em uma situa√ß√£o na qual temos controle do nosso carro, mas o carro da outra pessoa √© determinado pelo servidor. Se este carro recebe atualiza√ß√µes apenas a cada 100 ms, teremos uma anima√ß√£o p√©ssima de seu deslocamento, nos obrigando a encontrar outra solu√ß√£o para melhorar a experien√™ncia. Esta outra solua√ß√£o envolve fazer a predi√ß√£o da posi√ß√£o do outro carro do lado do nosso cliente, pois sabemos sua dire√ß√£o, sua velocidade e temos certeza que o carro n√£o far√° um movimento radical, como girar 180 graus. Sendo assim, se o outro carro est√° indo reto com uma velocidade de 100 km/h, podemos prever que nos pr√≥ximos 100 ms o carro estar√° 0,2 metros a frente de onde ele est√° neste exato segundo. Essa predi√ß√£o pode parecer maravilhosa, j√° que ele s√≥ se deslocou 0,2 metros em linha reta, mas infelizmente 100 ms √© tempo suficiente para muitas outras coisas acontecerem como uma curva aparecer, bater em um poste, desacelerar ou at√© mesmo frear bruscamente. Chamamos est√° t√©cnica de <strong>dead reckoning</strong>. Portanto, o <strong>dead reckoning</strong> √© uma t√©cnica de predi√ß√£o dos movimentos de outras pessoas em jogos na qual sua posi√ß√£o, velocidade e dire√ß√£o n√£o s√£o afetadas de forma instant√¢nea, permitindo uma pequena margem para prever movimentos sem grandes danos √† experi√™ncia. Caso alguma a√ß√£o inesperada aconte√ßa aceitamos que vamos conviver com uma cena estranha.</p>
<blockquote>
<p><strong>Dead reckoning</strong> √© originalmente uma estrat√©gia militar para prever a pr√≥xima localiza√ß√£o de um navio, que se move lentamente e sem grandes oscila√ß√µes de dire√ß√£o, para que se possa prever onde um torpedo precisa ser lan√ßado para acertar o navio.</p>
</blockquote>
<h2 id="e-para-cen√°rios-muito-din√¢micos"><a class="header" href="#e-para-cen√°rios-muito-din√¢micos">E para cen√°rios muito din√¢micos?</a></h2>
<p>Como falamos anteriormente, <em>dead reckoning</em> √© bom para jogos que n√£o s√£o t√£o din√¢micos, como jogos de corrida, por√©m para jogos na qual as pessoas jogando se movimentam constantemente, atiram, se abaixam, pulam, giram 180 graus √© imposs√≠vel prever o pr√≥ximo passo da pessoa apenas com dados anteriores. Se aplic√°ssemos dead reckoning em um jogo de tiro ver√≠amos personagens se teletransportando pequenas dist√¢ncias, m√∫ltiplas balas saindo de diferentes lugares e personagens fazendo movimentos imposs√≠veis. Sendo assim, outra estrat√©gia √© necess√°ria para jogos de tiro, sendo essa a <strong>interpola√ß√£o de entidades</strong>.</p>
<p>No cen√°rio descrito do par√°grafo anterior, temos certeza apenas de 1 coisa, que a cada 100 ms temos uma atualiza√ß√£o das informa√ß√µes do estado do jogo e dos personagens. Tendo em vista que sabemos o passado todo, o truque √© mostrar para pessoa jogando o que acontece entre esses dados que j√° sabemos. Ou seja, a solu√ß√£o √© mostrar para a pessoa que est√° jogando o passado relativo dos outros personagens. Isso que chamamos de <strong>interpola√ß√£o de entidades</strong>.</p>
<p>Explicando melhor, podemos dizer que no momento <code>t = n + 1</code>, que voc√™ acabou de receber, a posi√ß√£o do momento <code>t = n</code> √© conhecida. Sendo assim, neste momento <code>t = n + 1</code> conhecemos as posi√ß√µes referentes a <code>t = n</code> e <code>t = n + 1</code>. Portanto, para o momento <code>t = n + 2</code> mostramos o passado, ou seja, o que ocorreu no momento <code>t = n = 1</code> e para o momento <code>t = n + 1</code> mostramos o que ocorreu no momento <code>t = n</code> do outro personagem. Deste modo o servidor est√° sempre mostrando as informa√ß√µes reais de movimenta√ß√£o dos outros personagens, por√©m com um &quot;pequeno atraso&quot; de 100 ms. A imagem a seguir exemplifica:</p>
<p><img src="part-1/../imagens/interpolation.jpg" alt="Diagrama de interpola√ß√£o" /></p>
<p>O diagrama de interpola√ß√£o nos mostra bem como estamos prevendo os passos intermedi√°rios. Para um momento inicial estamos com a posi√ß√£o <code>P(0,1)</code>, depois o servidor nos atualiza com a posi√ß√£o <code>P(0,1)</code> novamente, neste momento exibimos a posi√ß√£o que conheciamos antes do <em>step time</em>, a <code>V(0,1)</code>. Quando recebemos a posi√ß√£o <code>P(0,2)</code>, mantemos a posi√ß√£o <code>V(0,1)</code>, que havia sido entregue anteriormente pelo servidor. Agora sabemos o vetor de posi√ß√µes <code>[P(0, 1), #1 P(0, 1), #2 P(0, 2)]</code>, e podemos interpolar que no pr√≥ximo <em>step time</em> nosso personagem inimigo vai para a posi√ß√£o <code>V(0,2)</code> passando pela posi√ß√£o <code>V(0,1.75)</code>, melhorando a experi√™ncia da pessoa jogadora.</p>
<p>Na maior parte dos casos interpola√ß√£o funciona muito bem, por√©m existem alguns casos que pode ser importante enviar mais informa√ß√µes de posi√ß√µes intermedi√°rias entre <code>#1</code> e <code>#2</code>. Ou seja, se atualiza√ß√µes de estado a cada 100 ms n√£o s√£o suficientes, podemos enviar as √∫ltimas 10 atualiza√ß√µes que ocorreram com intervalos de 10 ms, que certamente vai fazer com que seu jogo pare√ßa mais realista. Note que est√° t√©cnica faz com que cada jogadora perceba pequenas varia√ß√µes do ambiente do jogo em rela√ß√£o √†s outras pessoas, que geralmente n√£o √© algo percept√≠vel. Infelizmente, nada √© perfeito e existem exce√ß√µes como no caso de quando damos um tiro, pois estamos atirando na personagem da outra pessoa de 100 ms atr√°s. √â nesse caso que precisamos explorar o √∫ltimo t√≥pico desta parte, compensa√ß√£o de lag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compensac√£o-de-lag"><a class="header" href="#compensac√£o-de-lag">Compensac√£o de Lag</a></h1>
<p>O cen√°rio que temos at√© agora parece funcionar muito bem para percebermos movimenta√ß√µes, pois temos:</p>
<ul>
<li>Dado um tempo n, nosso servidor recebe informa√ß√µes de todos os clientes.</li>
<li>Servidor processa todas as informa√ß√µes e transmite as atualiza√ß√µes.</li>
<li>Estas atualiza√ß√µes s√£o peri√≥dicas e de baixa frequ√™ncia.</li>
<li>Clientes enviam informa√ß√µes e verificam seus efeitos localmente.</li>
<li>Clientes recebem as atualiza√ß√µes de estado do jogo:
<ol>
<li>Reconciliam com os efeitos que previram.</li>
<li>Interpolam os efeitos dos outros personagens.</li>
</ol>
</li>
<li>Cliente se v√™ no presente, mas v√™ os outros cliente no passado.</li>
</ul>
<p>Esta situa√ß√£o √© geralmente √≥tima, a menos quando precisamos garantir situa√ß√µes como um tiro na cabe√ßa, que qualquer pequena varia√ß√£o pode causar um erro, pois as informa√ß√µes de tempo e espa√ßo s√£o muito sens√≠veis. √â ai que entra a compensa√ß√£o de lag.</p>
<p>Imagine o cen√°rio na qual voc√™ √© uma sniper mirando perfeitamente na cabe√ßa de um personagem &quot;im√≥vel&quot;, um tiro dificil de errar. Voc√™ atira e, magicamente, nada acontece. Voc√™ se irrita, sai da partida e desliga o jogo pensando como pode ter errado aquele tiro perfeito e, pior, a pessoa que voc√™ devia ter matado te matou. Este √© o efeito de lag temporal, pois seu tiro ocorreu em um personagem que estava 100 ms no passado, para quem gosta de f√≠sica, √© como se a velocidade da luz fosse muito muito muito inferior a que realmente √©. Felizmente, existem algumas estrat√©gias para resolver este efeito. Vamos detalhar como isso pode ser reolvido:</p>
<ol>
<li>Voc√™ deu um tiro, seu cliente enviou as informa√ß√µes para o servidor, mas desta vez enviou mais informa√ß√µes al√©m do bot√£o que voc√™ clicou, pois enviou o bot√£o que voc√™ apertou, o exato momento temporal que voc√™ apertou o bot√£o (e se o bot√£o de mira estava sendo apertado) e o que estava exatamente em sua mira neste instante.</li>
<li>Como o servidor est√° recebendo todos momentos temporais, ele pode reconstruir os eventos temporalmente ordenados, ou seja, o servidor pode reconstruir o mundo no exato momento de seu tiro, assim como para todos outros clientes.</li>
<li>Sabendo o que sua arma estava mirando no momento de seu tiro, a cabe√ßa de seu inimigo, seu presente passa a ser considerado como v√°lido no servidor, j√° que ele compensa esta diferenca.</li>
<li>O servidor processa o tiro e transmite para todos os clientes, deixando seu oponente furioso por ter levado um headshot.</li>
</ol>
<p>E √© no passo dois que a compensac√£o de lag ocorre.</p>
<h2 id="conclus√£o"><a class="header" href="#conclus√£o">Conclus√£o</a></h2>
<p>Primeira coisa que fizemos foi entender qual o grande problema do desenvolvimento de servidores para jogos, pessoas querendo trapacear, e a partir disso entendemos qual a solu√ß√£o b√°sica, um cliente que s√≥ envia comandos pro servidor e um servidor autorit√°rio. Vimos que com um servidor autorit√°rio alguns problemas de defasamento temporal pode ocorrer entre a informa√ß√£o que temos e a informa√ß√£o que o servidor nos obriga a ter. Para reduzir estes problemas aprendemos as t√©cncias de predi√ß√£o e de reconcilia√ß√£o, mas descobrimos problemas de sincroniza√ß√£o com outros clientes. Para resolver os problemas de sincroniza√ß√£o aprendemos as t√©cncias de dead reckoning e interpola√ß√£o de entidades, que s√£o √≥timas t√©cnicas, mas ainda podem falhar na hora que a√ß√µes muito sens√≠veis espacialmente s√£o executadas. Para resolver este problema de a√ß√µes sens√≠veis, aprendemos compensa√ß√£o de lag, mas ainda nos falta por a m√£o na massa. Nos pr√≥ximos cap√≠tulos vamos explorar um jogo simples de tiro e um exemplo de servidor para ele.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiplayer-snake-game"><a class="header" href="#multiplayer-snake-game">Multiplayer Snake Game</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sobre-a-bevy"><a class="header" href="#sobre-a-bevy">Sobre a Bevy</a></h1>
<p>Bevy engine √© uma das game engines mais promissoras do mercado e um grande esfor√ßo coletivo para a comunidade rust_gamedev. Se trata de uma engine orientada a dados, gratu√≠ta e open source, sob as licen√ßas Apache e MIT, ou seja, perfeita para qualquer projeto. Ela possui como objetivos de design:</p>
<ul>
<li>Um conjunto completo de features para jogos 2D e 3D, podendo inclusive ser aplicada para outros objetivos.</li>
<li>Simples e poderosa, mas mantendo o f√°cil aprendizado.</li>
<li>Orientada a dados utilizando o paradigma ECS (Entity component system, no pr√≥ximo cap√≠tulo).</li>
<li>Modular, use o que quiser, adicione o que quiser, e substitua o que quiser.</li>
<li>R√°pida, paralela e em Rust &lt;3.</li>
<li>Compila√ß√£o r√°pida</li>
</ul>
<p>A atual vers√£o da Bevy √© <a href="https://crates.io/crates/bevy"><img src="https://img.shields.io/crates/v/bevy.svg" alt="Crates.io" /></a> e este livro foi desenvolvido com a vers√£o <code>0.7</code>.</p>
<h2 id="iniciando-o-projeto"><a class="header" href="#iniciando-o-projeto">Iniciando o projeto</a></h2>
<blockquote>
<p>Para iniciar um projeto com a Bevy √© necess√°rio possuir Rust e Cargo, caso voc√™ n√£o possua basta fazer download em https://rustup.rs/.</p>
</blockquote>
<p>Vamos iniciar nosso projeto com um simples <code>cargo new bevy-snake --bin</code>, que gera um projeto execut√°vel em Rust chamado <code>bevy-snake</code>. Este projeto vai possuir um <code>Cargo.toml</code> (onde os metadados do projeto est√£o localizados), um <code>src/main.rs</code> e um <code>.gitignore</code>:</p>
<pre><pre class="playground"><code class="language-rust">// src/main.rs
fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<pre><code class="language-sh"># .gitignore 
/target
</code></pre>
<p>Agora adicionamos vers√£o atual da bevy (<code>bevy = &quot;0.7&quot;</code>) a se√ß√£o <code>[dependencies]</code> do Cargo.toml. Adicionamos tamb√©m a crate de aleatoriedade <code>rand</code>:</p>
<pre><code class="language-toml">[dependencies]
bevy = &quot;0.7&quot;
rand = &quot;0.7&quot;
</code></pre>
<p>Com essas mudan√ßas no <code>Cargo.toml</code> podemos come√ßar a usar o <code>prelude</code> da bevy e criar nosso primeiro app com:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::new().run();
}
</code></pre></pre>
<h3 id="instanciando-uma-janela"><a class="header" href="#instanciando-uma-janela">Instanciando uma Janela</a></h3>
<p>Instanciar uma janela com a Bevy √© bastante trivial e pode ser feito atrav√©s do uso de plugins, neste caso o <code>DefaultPlugins</code> cont√©m um conjunto b√°sico de plugins que tornam a bevy operacional:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new().add_plugins(DefaultPlugins).run();
}
</code></pre></pre>
<p>Agora se executarmos <code>cargo run</code> veremos uma janela com fundo cinza. Por padr√£o, os plugins da Bevy n√£o incluem camera, pois o uso de camera √© muito variado em jogos, assim, precisamos criar nosso pr√≥prio sistema de cameras. Usaremos uma camera ortogr√°fica 2D com o commando <code>OrthographicCameraBundle::new_2d()</code> em uma fun√ß√£o que far√° a configura√ß√£o do sistema de cameras inicial alterando a vari√°vel do tipo <code>mut Commands</code>. <code>Commands</code> √© um tipo muito comum ao escrever sistemas com a Bevy e √© usado para enfileirar comandos com o objetivo de modificar o mundo (que chamaremos de <code>world</code>) e os recursos (que chamaremos de <code>resources</code>). Assim, na fun√ß√£o a seguir, <code>setup_camera</code>, receberemos como argumento <code>mut commands: Commands</code> e utilizaremos ele para instanciar (chamado de <code>spawn</code>) uma nova entidade bundle com os componentes de uma c√¢mera 2D ortogr√°fica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
<span class="boring">}
</span></code></pre></pre>
<p>E agora basta adicionar esse fun√ß√£o ao nosso <code>App</code> atrav√©s de um <code>add_startup_system</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_plugins(DefaultPlugins)
        .run();
}

fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
</code></pre></pre>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>A Bevy √© pensada de forma que todas suas partes sejam modulariz√°veis, assim, todas as core features da engine s√£o implementadas como plugins que podem ser substitu√≠dos, evolu√≠dos e customizados, al√©m disso, os pr√≥prios jogos s√£o encarados como plugins. Assim, se voc√™ n√£o precisar de uma UI, basta n√£o registrar o sistema de UI, quer um sistema de UI diferente, registre o seu pr√≥prio. Para o caso de servidores, basta n√£o registrar o plugin <code>RenderPlugin</code>.</p>
<p>Caso voc√™ n√£o precise de uma experi√™ncia t√£o avan√ßada com a Bevy, √© poss√≠vel utilizar o <code>DefaultPlugins</code> que utilizamos anteriormente, que possui sistemas como Rendering, gerenciamento de assets, sistema de UI, janelas e gerenciamento de entrada de dados.</p>
<h3 id="criando-um-plugin"><a class="header" href="#criando-um-plugin">Criando um Plugin</a></h3>
<p>Para criar um plugin simplesmente precisamos implementar a trait <code>Plugin</code> em um tipo que comporte as informa√ß√µes necess√°rias. No caso do plugin que vamos implementar √© apenas um <code>hello world</code> para plugins, ent√£o n√£o precisamos de dados, criando apenas um </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HelloPlugin;

impl Plugin for HelloPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        // l√≥gica do plugin
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos de uma fun√ß√£o que nosso sistema vai executar, neste caso um simples <code>println</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_plugin() {
    println!(&quot;hello plugin!&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p>E adicionamos essa fun√ß√£o como um <code>startup_system</code> no nosso plugin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Plugin for HelloPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_startup_system(hello_plugin);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Por √∫ltimo, basta adicionarmos nosso plugin ao <code>App</code> principal e executar <code>cargo run</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_plugin(HelloPlugin)
        .add_plugins(DefaultPlugins)
        .run();
}
</code></pre></pre>
<p>Veremos algo no terminal como:</p>
<pre><code>2022-06-20T05:28:52.725036Z  INFO bevy_render::renderer: AdapterInfo { name: &quot;AMD Radeon Pro 5500M&quot;, vendor: 0, device: 0, device_type: DiscreteGpu, backend: Metal }
hello plugin!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system-ecs"><a class="header" href="#entity-component-system-ecs">Entity Component System (ECS)</a></h1>
<p>O sistema de gerenciamento de dados da Bevy √© chamado de <em>Entity Component System</em>, ou <strong>ECS</strong>, e sua principal caracter√≠stica √© a simplicidade do gerenciamento de dados. Uma boa analogia ao seu funcionamento √© com bancos de dados tabulares, na qual os componentes, <em>components</em>, s√£o os tipos de dados, ou colunas, e as entidades, <em>entities</em>, s√£o as linhas, mais especificamente o ID das linhas. Por exemplo, voc√™ poderia ter diversas entidades com o componente <code>Health</code> e cada entidade possui um component <code>Health</code> diferente, j√° que NPCs, players e objetos do mundo podem ter <code>Health</code>s diferentes (<em>health</em> significa vida em ingl√™s). Assim, o conjunto de componentes que uma entidade possui √© chamado de arqu√©tipo, <em>Archetype</em>.</p>
<p>Considerando a entidade player possuindo componentes como vida, for√ßa, ataque, defesa, inventario, as entidades inimigos com vida, for√ßa, ataque, defesa, intelig√™ncia, e a entidade planta com apenas vida, fica muito f√°cil escrever uma l√≥gica de jogo que gerencia esses tipos de entidades, como verificar se uma entidade com vida encontrou outra entidade com vida, simplificando muito a cria√ß√£o de l√≥gicas de jogo. Essa l√≥gica de gerenciamento √© chamado sistema, <em>system</em>. Estes sistemas s√£o executados em paralelo pelo <em>smart scheduling algorithm</em> da Bevy e com isso devemos manter nossas entidades o mais horizontal poss√≠vel, evitando grandes componentes com muitos campos. Isso influ√™ncia muito a performance do sistema, pois quando mais vertical a entidade mais problemas de acesso aos dados em paralelo teremos.</p>
<blockquote>
<p>Para voc√™ que vem da orienta√ß√£o a objectos, no paradigma de ECS √© mais comum possuir uma entidade com diversos componentes, como a entidade Player que possui os componentes Vida(u32), Posi√ß√£o(x, y, z), Dire√ß√£o(x, y, z), Escala(x, y, z), Rota√ß√£o(x, y, z), Defesa(u16), Ataque(u16), For√ßa(u16) em vez de uma classe <code>Player</code> com os campos vida: u32, posi√ß√£o: [x, y, z], dire√ß√£o: [x, y, z], escala: [x, y, z], rota√ß√£o: [x, y, z], defesa: u16, ataque: u16, for√ßa: u16:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prefira isso:
// Entidade Player;

#[derive(Component)]
pub struct Vida(u32)

#[derive(Component)]
pub struct Posi√ß√£o(x, y, z)

#[derive(Component)]
pub struct Dire√ß√£o(x, y, z)

#[derive(Component)]
pub struct Escala(x, y, z)

#[derive(Component)]
pub struct Rota√ß√£o(x, y, z)

#[derive(Component)]
pub struct Defesa(u16)

#[derive(Component)]
pub struct Ataque(u16)

#[derive(Component)]
pub struct For√ßa(u16)

// Em vez disso:
pub struct Player {
    pub vida: u32, 
    pub posi√ß√£o: [x, y, z], 
    pub dire√ß√£o: [x, y, z], 
    pub escala: [x, y, z], 
    pub rota√ß√£o: [x, y, z], 
    pub defesa: u16, 
    pub ataque: u16, 
    pub for√ßa: u16,
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="criando-entidades"><a class="header" href="#criando-entidades">Criando entidades</a></h2>
<p>Entidades s√£o simplesmente IDs inteiros associados a um comando <code>spawn</code> de <code>commands</code>, <code>commands.spawn(...)</code> e para adicionar componentes basta utilizarmos a diretica <code>insert</code> em um <code>spawn</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_entity(mut commands: Commands) {
    commands
        .spawn()
        .insert(Label(&quot;Player&quot;))
        .insert(Vida(10))
        .insert(Posi√ß√£o(0, 2, 0))
        .insert(Dire√ß√£o(0, 2, 0))
        .insert(Escala(0, 2, 0))
        .insert(Rota√ß√£o(0, 2, 0))
        .insert(Defesa(10))
        .insert(Ataque(10))
        .insert(For√ßa(10));
}
<span class="boring">}
</span></code></pre></pre>
<p>Al√©m disso, existe o conceito de <em>bundles</em>. <em>Bundles</em> s√£o como <em>templates</em> que tornam a cria√ß√£o de entidades com diversos componentes mais simples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Bundle)]
struct Transform {
    posi√ß√£o: Posi√ß√£o(x, y, z),
    dire√ß√£o: Dire√ß√£o(x, y, z),
    escala: Escala(x, y, z),
    rota√ß√£o: Rota√ß√£o(x, y, z),
}

#[derive(Bundle)]
struct Player {
    vida: u32, 
    defesa: u16, 
    ataque: u16, 
    for√ßa: u16,

    #[bundle] // Nested bundles
    transform: Transform
}
<span class="boring">}
</span></code></pre></pre>
<p>Como podemos ver em <code>transform: Transform</code>, bundles tamb√©m podem ser encadeados. Tuplas arbitr√°rias tamb√©m s√£o consideradas bundles. Note, que bundles n√£o podem ser consultados com uma <em>query</em>.</p>
<h2 id="recursos-resources"><a class="header" href="#recursos-resources">Recursos (<em>Resources</em>)</a></h2>
<p>Recursos s√£o um tipo de inst√¢ncia que permite armazenar um tipo de dado de forma global, independente de entidades, e qualquer tipo Rust pode ser usado como um recurso independente de implementa√ß√£o de traits. Existem duas formas de inicializar recursos, a primeira √© definindo a trait <code>Default</code> para eles, quando eles possuem um tipo de dado simples, j√° a segunda √© implementando a trait <code>FromWorld</code> que permite atuar sobre o recurso utilizando valores de <code>World</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct StartingLevel(usize);

struct MyFancyResource { /* stuff */ }

impl FromWorld for MyFancyResource {
    fn from_world(world: &amp;mut World) -&gt; Self {
        // You have full access to anything in the ECS from here.
        // For instance, you can mutate other resources:
        let mut x = world.get_resource_mut::&lt;MyOtherResource&gt;().unwrap();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E para inicializar seus recursos em um App basta usar a fun√ß√£o <code>insert_resource</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        // Caso implemente uma das traits `Default` ou `FromWorld`
        .init_resource::&lt;MyFancyResource&gt;()
        // se for necess√°rio definir o valor inicial
        .insert_resource(StartingLevel(3))
        // ...
        .run();
}
</code></pre></pre>
<p>A decis√£o de quando usar recursos ou entity/component √© baseada na forma e no momento em que este dado vai ser acessado, mas considerando algo como um jogo com uma unica entidade, pode ainda ser √∫til utilizar o padr√£o ECS, pois ele permite maior flexibildiade e compartilhamento de dados, que podem ser muito √∫teis para a evolu√ß√£o do jogo.</p>
<h2 id="sistemas-systems"><a class="header" href="#sistemas-systems">Sistemas (<em>Systems</em>)</a></h2>
<p>Sistemas s√£o fun√ß√µes que a desenvolvedora escreve com o objetivo de ser uma unidade de l√≥gica do jogo atuando sobre as entidades e os componentes. Os sistemas s√£o executados e gerenciados pelas Bevy, mas somente podem ser usados com par√¢metros especiais. Os par√¢metros especiais s√£o:</p>
<ul>
<li><code>Res/ResMut</code> para acessar recursos.</li>
<li><code>Query</code> para acessar componentes de uma entidade.</li>
<li><code>Commands</code> para criar e destruir entidades, componentes e recursos.</li>
<li><code>EventWriter/EventReader</code> para enviar e receber eventos.</li>
</ul>
<p>Um sistema pode conter no m√°ximo 16 par√¢metros, caso seja preciso mais par√¢metros pode se agrega-los em tuplas de no m√°ximo 16 par√¢metros. Caso estes limites n√£o sejam suficiente, √© poss√≠vel fazer tuplas de tuplas.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn complex_system(
    (a, mut b): (Res&lt;ResourceA&gt;, ResMut&lt;ResourceB&gt;),
    mut c: Option&lt;ResMut&lt;ResourceC&gt;&gt;,
) {
    if let Some(mut c) = c {
        // l√≥gica
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>No sistema a cima <code>ResourceA</code> √© um recurso imut√°vel e esta compartilhando uma tupla com <code>ResourceB</code>que √© um recurso mut√°vel. J√° <code>ResourceC</code> √© um recurso que pode n√£o existir e por isso est√° englobado por um tipo <code>Optional&lt;T&gt;</code>.</p>
<p>Existem dois tipos de fun√ß√µes para executar sistemas na Bevy</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        // ...
        // sistemas executados apenas quando o App √© lan√ßado
        .add_startup_system(init_menu)
        .add_startup_system(debug_start)

        // sistemas executados todos os frames
        .add_system(move_player)
        .add_system(enemies_ai)
        // ...
        .run();
}
</code></pre></pre>
<p>Agora vamos come√ßar a implementar nosso snake game e aprofundar nossos conhecimentos em bevy.</p>
<p><strong>Refer√™ncia: <a href="https://bevy-cheatbook.github.io/programming.html">unofficial bevy guide</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-cabe√ßa-da-cobra"><a class="header" href="#a-cabe√ßa-da-cobra">A Cabe√ßa da Cobra</a></h1>
<p>Para come√ßar o jogo precisamos do primeiro componente, neste caso a cabe√ßa da cobra, que definir√° os pr√≥ximos poss√≠veis passos, assim como para onde os blocos seguintes se mover√£o. Este primeiro componente se chamar√° <code>SnakeHead</code> e ser√° uma struct vazia com a trait <code>Component</code> associada a ela:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Component)]
pub struct SnakeHead;
<span class="boring">}
</span></code></pre></pre>
<p>A fun√ß√£o de <code>SnakeHead</code> √© basicamente ser um marcador para as entidades do tipo snake, que nos permitir√° filtrar as estas entidades quando formos fazer queries com os players. Muitos componentes n√£o precisam de estados e podem funcionar apenas como marcadores, um padr√£o bastante comum no mundo ECS, j√° que optamos por uma estrat√©gia de <em>has a</em> (possui um) em vez de <em>is a</em> (√© um, da orienta√ß√£o a objetos). Outro detalhe importante √© a adi√ß√£o de uma cor espec√≠fica para a cabe√ßa da cobra <code>const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);</code>.</p>
<p>Nosso pr√≥ximo passo √© gerar uma entidade snake, que possui um componente do tipo <code>SnakeHead</code>, e essa entidade pode ser gerada adicionando um sistema inicial com <code>add_startup_system(spawn_snake)</code>, dada a fun√ß√£o <code>spawn_snake</code>:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
 
const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(spawn_snake)
       .add_plugins(DefaultPlugins)
       .run();
}
 
fn setup_camera(mut commands: Commands) {
   commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
 
#[derive(Component)]
pub struct SnakeHead;
 
fn spawn_snake(mut commands: Commands) {
   commands
       .spawn_bundle(SpriteBundle {
           sprite: Sprite {
               color: SNAKE_HEAD_COLOR,
               ..default()
           },
           transform: Transform {
               scale: Vec3::new(10.0, 10.0, 10.0),
               ..default()
           },
           ..default()
       })
       .insert(SnakeHead);
}
</code></pre></pre>
<blockquote>
<p><strong>SpriteBundle</strong></p>
<p><code>SpriteBundle</code> √© um tipo de componente que agrega caracter√≠sticas comuns a uma entidade que utiliza sprites como o pr√≥prio sprite (especificidades da imagem), transform (rela√ß√£o de posi√ß√£o, escala e rota√ß√£o), visibilidade, transform global e o manuseio de imagens.</p>
</blockquote>
<p>Neste caso, n√£o temos nenhuma imagem espec√≠fica como sprite, mas definimos um transform com uma escala de <code>10 x 10 x 10</code> pixels e uma cor de filtro acinzentada para a regi√£o definida pelo transform, as outras propriedades foram definidas como <code>..default()</code>. Ao executarmos <code>cargo run</code> o resultado √© algo como:</p>
<p><img src="part-2/../imagens/snake_pixel.png" alt="Entidade snake com SpriteBundle" /></p>
<h2 id="nosso-primeiro-teste"><a class="header" href="#nosso-primeiro-teste">Nosso primeiro teste</a></h2>
<p>No mundo moderno, jogos sem testes est√£o fadados ao fracasso. N√£o estou dizendo que todos os jogos possuem uma bateria maravilhosa de testes automatizados, mas desde que escrevi o livro <strong>Lean Game Development</strong> at√© hoje, o mercado de games AAA mudou muito. Hoje em dia vejo jogos sendo desenvolvidos com TDD e com QA advogando por testes automatizados de gameplay emt todos os sistemas, garantindo uma jogabilidade equilibrada/desejada em qualquer plataforma. Hoje em dia um jogo, middleware, game server ou ferramenta sem nenhum teste esta fadado ao fracasso por conta do n√∫mero excessivo de bugs e clientes infelizes. Sendo assim, √© importante ter uma no√ß√£o de como testar minimamente seus sistemas com a Bevy. Sendo assim, vamos aprender a escrever o teste mais simples poss√≠vel, verificar se nosso sistema <code>spawn_snake</code> de fato adiciona um componente <code>SnakeHead</code> √† entidade desejada.</p>
<p>Primeiro passo do teste ser√° mover tudo que √© relacionado a <code>snake</code> para um m√≥dulo chamado <code>snake.rs</code>:</p>
<p><strong><code>main.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
 
mod snake;
 
use snake::spawn_snake;
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(spawn_snake)
       .add_plugins(DefaultPlugins)
       .run();
}
 
fn setup_camera(mut commands: Commands) {
   commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
</code></pre></pre>
<p><strong><code>snake.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
 
const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
 
#[derive(Component)]
pub struct SnakeHead;
 
pub fn spawn_snake(mut commands: Commands) {
   commands
       .spawn_bundle(SpriteBundle {
           sprite: Sprite {
               color: SNAKE_HEAD_COLOR,
               ..default()
           },
           transform: Transform {
               scale: Vec3::new(10.0, 10.0, 10.0),
               ..default()
           },
           ..default()
       })
       .insert(SnakeHead);
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora em Snake vamos criar um teste dentro de um m√≥dulo de testes (<code>#[cfg(test)] mod test {...}</code>) que verifique se um componente <code>SnakeHead</code> est√° presente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
   use super::*;
 
   #[test]
   fn entity_has_snake_head() {
       // 1 Inicializa√ß√£o do App
       let mut app = App::new();
 
       // 2 Adicionar o `spawn_snake` startup system
       app.add_startup_system(spawn_snake);
 
       // 3 Executar todos os sistemas pelo menos uma vez
       app.update();
 
       // 4 Fazer uma query por entidades que contenham o componente `SnakeHead`
       let mut query = app.world.query_filtered::&lt;Entity, With&lt;SnakeHead&gt;&gt;();
 
       // 5 Verificar se a contagem de componentes da query foi igual a 1
       assert_eq!(query.iter(&amp;app.world).count(), 1);
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Descrevendo o teste <code>entity_has_snake_head</code> (verifica se entidade possui componente snake head) temos como primeiro passo (<code>1</code>) criar um <code>App</code> mut√°vel para podermos adicionar sistemas como o <code>spawn_snake</code> (<code>2</code>) e executarmos todos os sistemas pelo menos uma vez com <code>app.update()</code> (<code>3</code>). O pr√≥ximo passo √© realizarmos uma <code>query</code> (<code>4</code>) no sistema de ECS para procurarmos por uma entidade que possua o componente <code>SnakeHead</code> (<code>With&lt;SnakeHead&gt;</code>). Com o resultado desta <code>query</code> verificamos se a quantidade de entidades que possuem o componente <code>SnakeHead</code> √© igual a <code>1</code> (<code>5</code>).</p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>O principal objetivo de queries √© nos permitir acessar componentes de entidades. No c√≥digo a seguir, temos uma query do tipo <code>Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;</code> que representa todas as entidades que possuam <code>Health</code> e <code>Transform</code>, com a propriedade <code>Health</code> sendo apenas leitura e a propriedade <code>Transform</code> sendo mut√°vel. Al√©m disso, caso o componente <code>Player</code> esteja presente, permite a leitura dele. Depois disso iteramos sobre todos os √≠tens dessa query, de forma mut√°vel, para podermos alterar a propriedade transform, <code>(health, mut transform, player) in query.iter_mut()</code>. Por √∫ltimo, caso o componente <code>Player</code> esteja presente, sabemos que esta entidade √© do tipo player e aplicamos uma l√≥gica extra.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_zero_health(
   mut query: Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;,
) {
   // Obtem todas as entidades do tipo
   for (health, mut transform, player) in query.iter_mut() {
       eprintln!(&quot;Entity at {} has {} HP.&quot;, transform.translation, health.hp);
 
       // centraliza se `hp` √© menor ou igual a `0.0`
       if health.hp &lt;= 0.0 {
           transform.translation = Vec3::ZERO;
       }
 
       if let Some(player) = player {
           // entidade √© do tipo `Player`
           // l√≥gica extra
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>para obter o ID de uma entidade com queries basta adicionar <code>Entity</code> a query e a vari√°vel <code>entity_id</code> corresponder√° ao id:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// adicione `Entity` a `Query` para obter os IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
   for (entity_id, /* ... */) in q.iter() {
       // `entity_id` √© o ID da entidade que estamos acessando.
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Caso exista certeza que uma query vai identificar apenas uma entidade, √© poss√≠vel utilizar <code>single</code> e <code>single_mut</code> para acessar seus componentes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn query_player(mut q: Query&lt;(&amp;Player, &amp;mut Transform)&gt;) {
   let (player, mut transform) = q.single_mut();
   // l√≥gica
}
<span class="boring">}
</span></code></pre></pre>
<p>Outro recurso interessante de queries s√£o os <em>Query Filters</em>, um tipo especial de queries que permite reduzir a quantidade de entidade que uma query retorna. <em>Query filters</em> se utilizam dos filtros <code>With</code> e <code>Without</code> para garantir que a entidade tenha (<code>With</code>) ou n√£o tenha (<code>Without</code>) certos componentes. No exemplo a seguir, a query acessa todas as entidades com o componente <code>Health</code> que sejam  <code>Players</code> amig√°veis e que opcionalmente possuam <code>PlayerName</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_player_hp(
   query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
   for (health, name) in query.iter() {
       // ...
   }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Utilizando filtros</strong></p>
<ul>
<li>Elementos adicionados em uma Tupla, como <code>(With&lt;Player&gt;, Without&lt;Enemy&gt;)</code>, s√£o considerados <code>AND</code>/<code>E</code> l√≥gicos.</li>
<li>Para utilizar <code>OR</code>/<code>OU</code> l√≥gicos √© preciso envolver as tuplas em um filtro do tipo <code>Or&lt;(‚Ä¶)&gt;</code>.</li>
</ul>
</blockquote>
<h2 id="movendo-a-cabe√ßa-da-cobra"><a class="header" href="#movendo-a-cabe√ßa-da-cobra">Movendo a cabe√ßa da cobra</a></h2>
<p>N√£o existe o Snake game sem movimento, ent√£o o pr√≥ximo passo √© controlarmos os movimentos da cabe√ßa da cobra com as teclas <code>WASD</code> ou direcionais. Para isso, podemos come√ßar com a movimenta√ß√£o para cima utilizando o teste:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn snake_head_has_moved_up() {
   // Setup
   let mut app = App::new();
   let default_transform = Transform {..default()};
 
   // Adicionando sistemas
   app.add_startup_system(spawn_snake)
   .add_system(snake_movement);
 
   // Adicionando inputs de `KeyCode`s
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::W);
   app.insert_resource(input);
 
   // Executando sistemas pelo menos uma vez
   app.update();
 
   // Query para obter entidades com `SnakeHead` e `Transform`
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
 
   // Verificando se o valor de Y no `Transform` mudou
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert!(default_transform.translation.y &lt; transform.translation.y);
       assert_eq!(default_transform.translation.x, transform.translation.x);
   })
}
<span class="boring">}
</span></code></pre></pre>
<p>Neste teste adicionamos um <code>Transform</code> com valores padr√£o de <code>translation</code> para comparar quando o transform da query mudar, adicionamos um novo sistema de movimento <code>add_system(snake_movement)</code> e criamos um recurso que gerencia inputs de teclado <code>Input::&lt;KeyCode&gt;::default()</code>, na qual setamos seu evento <code>press</code> como <code>KeyCode::W</code>. Para resolver este teste precisamos criar o sistema <code>snake_movement</code>, que √© bastante trivial neste caso, apenas um sistema que busca por um query contendo <code>&amp;SnakeHead</code> e <code>&amp;Transform</code>, depois modifica o valor de Y de forma que sempre aumente:</p>
<pre><pre class="playground"><code class="language-rust">// snake.rs
pub fn snake_movement(mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;) {
   for (_head, mut transform) in head_positions.iter_mut() {
       transform.translation.y += 1.;
   }
}
 
// main.rs
// ...
mod snake;
use snake::{spawn_snake, snake_movement};
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(spawn_snake)
       .add_plugins(DefaultPlugins)
       .add_system(snake_movement)
       .run();
}
// ...
</code></pre></pre>
<h3 id="controlando-a-dire√ß√£o-de-movimento"><a class="header" href="#controlando-a-dire√ß√£o-de-movimento">Controlando a dire√ß√£o de movimento</a></h3>
<p>Nosso movimento atual est√° longe de ser realista ou funcional, para isso precisamos que a cobra se movimente com base nas teclas <code>wasd</code> e podemos come√ßar com um teste que move a cobra 1 unidade para cima, verificando que apenas o <code>y</code> mudou em relacao ao original, depois uma unidade para direita, verificando que apenas o <code>x</code> mudou em rela√ß√£o ao anterior. Por √∫ltimo, um novo teste movendo para baixo e para esquerda, verificando se as posi√ß√µes s√£o inferiores √†s originais em <code>x</code> e <code>y</code>. Assim, o primeiro teste fica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn snake_head_moves_up_and_right() {
   // Setup
   let mut app = App::new();
   let default_transform = Transform {..default()};
 
   // Adiciona systemas
   app.add_startup_system(spawn_snake)
   .add_system(snake_movement);
 
   // Testa movimento para cima
   let mut up_transform = Transform {..default()};
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::W);
   app.insert_resource(input);
   app.update();
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert!(default_transform.translation.y &lt; transform.translation.y);
       assert_eq!(default_transform.translation.x, transform.translation.x);
       up_transform = transform.to_owned();
   });
 
   // Testa movimento para direita
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::D);
   app.insert_resource(input);
   app.update();
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert_eq!(up_transform.translation.y , transform.translation.y);
       assert!(up_transform.translation.x &lt; transform.translation.x);
   })
}
<span class="boring">}
</span></code></pre></pre>
<p>Ao executarmos este teste percebemos que a linha <code>assert_eq!(up_transform.translation.y , transform.translation.y);</code> falha pois nosso <code>transform.translation.y</code> est√° maior que o anterior, que faz sentido, j√° que nosso sistema de movimento est√° apenas aumentando o <code>y</code> a cada update. Para resolvermos isso, podemos adicionar os comandos para se mover com <code>w</code> e com <code>d</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// snake.rs
pub fn snake_movement(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;
) {
   for (_head, mut transform) in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Teste passando, ent√£o podemos fazer o segundo teste, movimento para baixo e para esquerda. O teste √© basicamente igual ao anterior, mas reduzimos algumas linhas:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn snake_head_moves_down_and_left() {
   // Setup
   let mut app = App::new();
   let default_transform = Transform {..default()};
 
   app.add_startup_system(spawn_snake)
   .add_system(snake_movement);
 
   // Movimenta para baixo
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::S);
   app.insert_resource(input);
   app.update();
 
 
   // Movimenta para esquerda
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::A);
   app.insert_resource(input);
   app.update();
 
   // Assert
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert!(default_transform.translation.y &gt; transform.translation.y);
       assert!(default_transform.translation.x &gt; transform.translation.x);
   })
}
<span class="boring">}
</span></code></pre></pre>
<p>Como esperado, o teste falha e podemos implementar as condi√ß√µes que faltam de pressionar o teclado, <code>s</code> e <code>a</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn snake_movement(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;
) {
   for (_head, mut transform) in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
       if keyboard_input.pressed(KeyCode::A) {
           transform.translation.x -= 1.;
       }
       if keyboard_input.pressed(KeyCode::S) {
           transform.translation.y -= 1.;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Tudo passa e podemos ir para o pr√≥ximo passo, explicar e melhorar este c√≥digo. O argumento <code>keyboard_input</code> √© um recurso que cont√©m os eventos relacionados a tecla que foi pressionada no <code>input</code>, ou seja, <code>Res&lt;Input&lt;KeyCode&gt;&gt;,</code>. Nossa query faz sentido e est√° funcional, por√©m, como n√£o estamos utilizando o componente <code>SnakeHead</code>, representado por <code>_head</code>, podemos mudar nossa query para <code>Query&lt;&amp;mut Transform, With&lt;SnakeHead&gt;&gt;</code>, que altera nosso c√≥digo para utilizar apenas o transform como vari√°vel:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn snake_movement(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;&amp;mut Transform, With&lt;SnakeHead&gt;&gt;
) {
   for mut transform in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
       if keyboard_input.pressed(KeyCode::A) {
           transform.translation.x -= 1.;
       }
       if keyboard_input.pressed(KeyCode::S) {
           transform.translation.y -= 1.;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Como mencionamos antes sobre o <code>With</code>, ele nos permite buscar todas as entidades que possuam o componente <code>SnakeHead</code>, mas expl√≠cita para a Bevy que n√£o nos importamos com o conte√∫do de <code>SnakeHead</code>, apenas com o <code>Transform</code>. Isso √© importante pois quanto menos componentes o sistema precisar acessar, mais a bevy conseguir√° paralelizar as coisas.</p>
<h2 id="ci"><a class="header" href="#ci">CI</a></h2>
<p>Uma coisa bastante importante enquanto desenvolvemos √© termos um sistema de integra√ß√£o cont√≠nua executando. No caso do Rust no Github eu recomendo utilizar o <em>Github Actions</em> e minha configura√ß√£o base para projetos Rust √©:</p>
<pre><code class="language-yaml">name: Rust
 
on:
 push:
   branches: [ &quot;main&quot; ]
 pull_request:
   branches: [ &quot;*&quot; ]
 
env:
 CARGO_TERM_COLOR: always
 
jobs:
 build:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v3
   - name: Install alsa and udev
     run: sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev
   - name: Build
     run: cargo build --release --verbose
    
 test:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v2
   - name: Install alsa and udev
     run: sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev
   - name: tests
     run: cargo test -- --nocapture
  fmt:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v2
   - name: FMT
     run: cargo fmt -- --check
 
 clippy:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v2
   - name: Install alsa and udev
     run: sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev
   - name: install-clippy
     run: rustup component add clippy
   - name: clippy
     run: cargo clippy -- -W clippy::pedantic --deny &quot;warnings&quot;
 
</code></pre>
<p>Ao executarmos o CI, percebemos que a formata√ß√£o n√£o estava correta, que pode ser corrigida com <code>cargo fmt</code>, e h√° algumas sugest√µes de linting em rela√ß√£o a nomenclatura das fun√ß√µes e structs no m√≥dulo e declara√ß√£o de argumentos. A quest√£o de nomenclatura solicita que fun√ß√µes e structs n√£o comecem com o nome do m√≥dulo. A declara√ß√£o de argumentos solicita que o tipo de <code>keyboard_input</code> seja passado como refer√™ncia <code>keyboard_input: &amp;Res&lt;Input&lt;KeyCode&gt;&gt;</code>, por√©m isso quebra a inje√ß√£o de recursos da bevy, necessitando assim que o lint seja descartado com <code>#[allow(clippy::needless_pass_by_value)]</code>. Meu √∫nico problema com a quest√£o de nomenclatura √© perder o contexto de que os sistemas e as structs quando utilizamos importa√ß√µes absolutas em vez de qualificadas. A solu√ß√£o √© utilizar importa√ß√µes qualificadas. O c√≥digo ficou assim:</p>
<pre><pre class="playground"><code class="language-rust">// Snake.rs
use bevy::prelude::*;
 
const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
 
#[derive(Component)]
pub struct Head;
 
pub fn spawn_system(mut commands: Commands) {
   commands
       .spawn_bundle(SpriteBundle {
           sprite: Sprite {
               color: SNAKE_HEAD_COLOR,
               ..default()
           },
           transform: Transform {
               scale: Vec3::new(10.0, 10.0, 10.0),
               ..default()
           },
           ..default()
       })
       .insert(Head);
}
 
#[allow(clippy::needless_pass_by_value)]
pub fn movement_system(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;&amp;mut Transform, With&lt;Head&gt;&gt;,
) {
   for mut transform in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
       if keyboard_input.pressed(KeyCode::A) {
           transform.translation.x -= 1.;
       }
       if keyboard_input.pressed(KeyCode::S) {
           transform.translation.y -= 1.;
       }
   }
}
 
#[cfg(test)]
mod test {
   use super::*;
 
   #[test]
   fn entity_has_snake_head() {
       // Setup app
       let mut app = App::new();
 
       // Add startup system
       app.add_startup_system(spawn_system);
 
       // Run systems
       app.update();
 
       let mut query = app.world.query_filtered::&lt;Entity, With&lt;Head&gt;&gt;();
       assert_eq!(query.iter(&amp;app.world).count(), 1);
   }
 
   #[test]
   fn snake_head_has_moved_up() {
       // Setup
       let mut app = App::new();
       let default_transform = Transform { ..default() };
 
       // Add systems
       app.add_startup_system(spawn_system)
           .add_system(movement_system);
 
       // Add input resource
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::W);
       app.insert_resource(input);
 
       // Run systems
       app.update();
 
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert!(default_transform.translation.y &lt; transform.translation.y);
           assert_eq!(default_transform.translation.x, transform.translation.x);
       })
   }
 
   #[test]
   fn snake_head_moves_up_and_right() {
       // Setup
       let mut app = App::new();
       let default_transform = Transform { ..default() };
 
       // Add systems
       app.add_startup_system(spawn_system)
           .add_system(movement_system);
 
       // Move Up
       let mut up_transform = Transform { ..default() };
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::W);
       app.insert_resource(input);
       app.update();
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert!(default_transform.translation.y &lt; transform.translation.y);
           assert_eq!(default_transform.translation.x, transform.translation.x);
           up_transform = transform.to_owned();
       });
 
       // Move Right
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::D);
       app.insert_resource(input);
       app.update();
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert_eq!(up_transform.translation.y, transform.translation.y);
           assert!(up_transform.translation.x &lt; transform.translation.x);
       })
   }
 
   #[test]
   fn snake_head_moves_down_and_left() {
       // Setup
       let mut app = App::new();
       let default_transform = Transform { ..default() };
 
       // Add systems
       app.add_startup_system(spawn_system)
           .add_system(movement_system);
 
       // Move down
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::S);
       app.insert_resource(input);
       app.update();
 
       // Move Left
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::A);
       app.insert_resource(input);
       app.update();
 
       // Assert
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert!(default_transform.translation.y &gt; transform.translation.y);
           assert!(default_transform.translation.x &gt; transform.translation.x);
       })
   }
}
 
// Main.rs
use bevy::prelude::*;
 
mod snake;
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(snake::spawn_system)
       .add_plugins(DefaultPlugins)
       .add_system(snake::movement_system)
       .run();
}
 
fn setup_camera(mut commands: Commands) {
   commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
 
</code></pre></pre>
<p>A seguir vamos criar o conceito de Grid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grade-de-movimento"><a class="header" href="#grade-de-movimento">Grade de Movimento</a></h1>
<p>Nosso sistema de movimenta√ß√£o tem utilizado coordenadas da janela para fazer a movimenta√ß√£o, sendo o ponto <code>(0,0)</code> o centro da janela e cada unidade corresponde a um pixel, por√©m o snake game utiliza um sistema de grade. Assim, precisamos definir uma grade b√°sica com tamanho da grade de <code>10 x 10</code> e c√©lulas da grade com mais de 1 pixel para evitar janelas de 10 px por 10 px. Al√©m disso, definir uma grade a aprtir do centro √© bastante complexo, por isso vamos utilizar nosso pr√≥prio sistema de coordenadas e criar um sistema que fa√ßa a convers√£o. Nosso primeiro passo √© adicionar constantes referentes ao tamnho da arena. √â importante que estas constantes sejam definidas fora, pois quando iniciarmos o modo multiplayer <code>10 x 10</code> ser√° muito pequena. </p>
<pre><code class="language-rs">// main.rs
mod snake;

const GRID_WIDTH: u32 = 10;
const GRID_HEIGHT: u32 = 10;

fn main() {
    // ...
}
</code></pre>
<p>As constantes <code>GRID_WIDTH</code> e <code>GRID_HEIGHT</code> referemm a largura da arena e a altura da arena, respectivamente. Agora criamos um novo m√≥dulo <code>components</code> que √© respons√°vel por gerenciar componentes b√°sicos e transversair do jogo, como posi√ß√£o (<code>Position</code>) e tamanho de c√©lula (<code>Size</code>):</p>
<pre><code class="language-rs">// main.rs
mod snake;
pub mod components;

const GRID_WIDTH: u32 = 10;
const GRID_HEIGHT: u32 = 10;
// ...

// components.rs
use bevy::prelude::Component;

#[derive(Component, Clone, Debug, PartialEq, Eq)]
pub struct Position {
    pub x: i32,
    pub y: i32,
}

#[derive(Component, Debug, PartialEq)]
pub struct Size {
    pub width: f32,
    pub height: f32,
}

impl Size {
    pub fn square(x: f32) -&gt; Self {
        Self {
            width: x,
            height: x,
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn sized_square_is_created_calling_square_fn() {
        let expected = Size {width: 3.14, height: 3.14};
        let actual = Size::square(3.14);

        assert_eq!(actual, expected);
    }
}
</code></pre>
<p>No arquivo de components precisamos apenas importar a trait <code>Component</code> e definir as structs <code>Position</code> com <code>x, y</code> e <code>Size</code> com <code>width,height</code>. O √∫nico teste presente √© o <code>sized_square_is_created_calling_square_fn</code> pois ele testa se um quadrado de lado <code>f</code> √© criado quando chamamos a fun√ß√£o <code>Size::square</code>. Ou seja, <code>Size::square</code> √© um m√©todo para ajudar a gerar c√©lulas, ou qualquer outra coisa que tenha tamanho, de altura e largura iguais. Outra coisa importante de salientar s√£o as v√°rias traits derivadas em <code>Position</code>, no futuro elas devem nos ajudar a utilizar <code>Position</code>. Pr√≥ximo passo √© incorporar estes componentes na cobra que temos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::components::{Position, Size};

const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);

#[derive(Component)]
pub struct Head;

pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: SNAKE_HEAD_COLOR,
                ..default()
            },
            transform: Transform {
                scale: Vec3::new(10.0, 10.0, 10.0),
                ..default()
            },
            ..default()
        })
        .insert(Head) // Remover ;
        .insert(Position { x: 5, y: 5 }) // &lt;-
        .insert(Size::square(0.8));  // &lt;-
}
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos os testes agora, vamos ver que n√£o h√° nenhuma altera√ß√£o significativa, pois todos os testes seguem passando. Agora precisamos de uma fun√ß√£o auxiliar para gerenciar a escala de c√°da c√©lula da cobra e da grade, assim como uma fun√ß√£o que fa√ßa a correspond√™ncia entre posi√ß√£o na grade e posi√ß√£o na janela. Vamos come√ßar com a mais f√°cil, escala, que chamaremos de <code>size_scaling</code>. Antes, criamos um m√≥dulo chamado <code>grid</code> e movemos <code>GRID_WIDTH</code>e <code>GRID_HEIGHT</code> para este m√≥dulo:</p>
<pre><code class="language-rs">// grid.rs
use bevy::prelude::*;
use crate::components::Size;

const GRID_WIDTH: u32 = 10;
const GRID_HEIGHT: u32 = 10;

pub fn size_scaling(windows: Res&lt;Windows&gt;, mut q: Query&lt;(&amp;Size, &amp;mut Transform)&gt;) {
    let window = windows.get_primary().unwrap();
    for (sprite_size, mut transform) in q.iter_mut() {
        scale_sprite(transform.as_mut(), sprite_size, window);
    }
}

fn scale_sprite(transform: &amp;mut Transform, sprite_size: &amp;Size, window: &amp;Window) {
    transform.scale = Vec3::new(
        sprite_size.width / GRID_WIDTH as f32 * window.width() as f32,
        sprite_size.height / GRID_HEIGHT as f32 * window.height() as f32,
        1.0,
    );
}

#[cfg(test)]
mod test {
    use bevy::window::WindowId;
    use raw_window_handle::{RawWindowHandle, WebHandle};
    use crate::{components::Size};

    use super::*;

    #[test]
    fn transform_has_correct_scale_for_window() {
        // Setup
        let expected_transform = Transform { scale: Vec3::new(20., 20., 1.,),..default() };
        let mut default_transform = Transform { scale: Vec3::new(2., 3., 4.,),..default() };
        let sprite_size = Size::square(1.);

        // Create window
        let mut descriptor = WindowDescriptor::default();
        descriptor.height = 200.;
        descriptor.width = 200.;
        let raw_window_handle = RawWindowHandle::Web(WebHandle::empty());
        let window = Window::new(WindowId::new(), &amp;descriptor, 200, 200, 1., None, raw_window_handle);

        // Apply scale
        scale_sprite(&amp;mut default_transform, &amp;sprite_size, &amp;window);

        assert_eq!(default_transform, expected_transform);
    }
}
</code></pre>
<p>Infelizmente, o recurso <code>Windows</code> √© bastante complicado de testar pois causa muitos problemas com o sistema de sincroniza√ß√£o e agendamento do ECS da Bevy, por isto, neste caso n√£o vamos testar o sistema em si, mas sim a l√≥gica que o sistema chama, a fun√ß√£o <code>scale_sprite</code>. A l√≥gica de <code>size_scaling</code> √© a seguinte: Se algo possui uma <code>Size.width</code> e uma <code>Size.height</code>, neste caso <code>sprite_size.width</code> e <code>sprite_size.height</code>, igual a 1.0, em uma grade de tamanho 40, em uma janela de tamanho 400 px, ent√£o a largura deveria ser 10, pois <code>1.0 / 40. * 400. = 10</code>. Ou seja, para este teste, os valores iniciais de <code>default_transform</code> n√£o importam, apenas os valores pr√©configurados de <code>Size</code>, <code>Window</code>, <code>GRID_WIDTH</code>e <code>GRID_HEIGHT</code>.</p>
<p>Note que no teste estamos utilizando a biblioteca <code>raw_window_handle</code>, na vers√£o <code>0.4.3</code>, para gerar as informa√ß√µes de window e que criamos uma janela de <code>200 x 200</code>.</p>
<p>A pr√≥xima fun√ß√£o √© a respons√°vel por transformar a posi√ß√£o em uma coordenada de janela, ent√£o, de novo, n√£o poderemos testar o sistema em si, apenas os blocos l√≥gicos que ser√£o divididos em 2:</p>
<ol>
<li>Fun√ß√£o <code>convert</code> respons√°vel por calcular o fator de convers√£o de posi√ß√£o para window.</li>
<li>Aplicar a convers√£o ao <code>Transform.translation</code>, posi√ß√£o na janela.</li>
</ol>
<p>Vamos criar 2 testes para <code>convert</code>:</p>
<pre><code class="language-rs">#[test]
fn convert_position_x_for_grid_width() {
    let x = convert(4., 400., GRID_WIDTH as f32);

    assert_eq!(x, -20.)
}

#[test]
fn convert_position_y_for_grid_height() {
    let y = convert(5., 400., GRID_HEIGHT as f32);

    assert_eq!(y, 20.)
}
</code></pre>
<p>Estes testes tem como principal objetivo, impedir mudan√ßas que quebrem o c√≥digo, assim, sua implementa√ßnao √© apenas:</p>
<pre><code class="language-rs">fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    pos / grid_side_lenght * bound_window - (bound_window / 2.) + (tile_size / 2.)
}
</code></pre>
<p>Calculamos o <code>tilesize</code> como o tamanho da janela dividido pela quantidade de elementos da grade. Depois a posi√ß√£o passa a ser em rela√ß√£o √† grade, algo como <code>5/ 10 = 0.5</code> multilicado pelo tamanho da window, por√©m como a bevy o ponto <code>(0,0)</code> √© no centro da janela, precisamos deslocal meia janela (<code>- (bound_window / 2.)</code>) e centralizar o tile com <code>+ (tile_size / 2.)</code>. </p>
<p>Pr√≥ximo passo √© criar a fun√ß√£o que executa a transla√ß√£o do valor do componente <code>Position</code> para o correspondente da posi√ßnao na janela no componente <code>Transform</code>, como √© uma fun√ß√£o muito simples, vamos adicionar apenas um teste b√°sico:</p>
<pre><code class="language-rs">fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(pos.x as f32, window.width() as f32, GRID_WIDTH as f32),
        convert(pos.y as f32, window.height() as f32, GRID_HEIGHT as f32),
        0.0,
    );
}

// mod test:
#[test]
fn translate_position_to_window() {
    let position = Position {x: 2, y: 8};
    let mut default_transform= Transform::default();
    let expected = Transform { translation: Vec3::new(-100., 140., 0.,),..default() };

    // Create window
    let mut descriptor = WindowDescriptor::default();
    descriptor.height = 400.;
    descriptor.width = 400.;
    let raw_window_handle = RawWindowHandle::Web(WebHandle::empty());
    let window = Window::new(WindowId::new(), &amp;descriptor, 400, 400, 1., None, raw_window_handle);
    
    // Apply translation
    translate_position(&amp;mut default_transform, &amp;position, &amp;window);

    assert_eq!(default_transform, expected);
}
</code></pre>
<p>Agora agregando tudo na fun√ß√£o <code>position_translation</code> temos:</p>
<pre><code class="language-rs">pub fn position_translation(windows: Res&lt;Windows&gt;, mut q: Query&lt;(&amp;Position, &amp;mut Transform)&gt;) {
    let window = windows.get_primary().unwrap();
    for (pos, mut transform) in q.iter_mut() {
        translate_position(transform.as_mut(), pos, window);
    }
}

fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    pos / grid_side_lenght * bound_window - (bound_window / 2.) + (tile_size / 2.)
}

fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(pos.x as f32, window.width() as f32, GRID_WIDTH as f32),
        convert(pos.y as f32, window.height() as f32, GRID_HEIGHT as f32),
        0.0,
    );
}
</code></pre>
<p>Pr√≥ximo passo √© adicionar os sistemas que criamos √† fun√ß√£o main utilizando o <code>App::Builder</code>. Este sistema √© um caso especial, pois deve ser executado ap√≥s o m√©todo update j√° que qualquer componente que seja adicionado no update corrente ser√° visivel somente no pr√≥ximo est√°gio (por exemplo <code>PostUpdate</code> e <code>Draw</code>) e as fun√ß√µes  <code>position_translation</code> e <code>size_scaling</code> somente conseguiram ver nodos novos da cobra ou comidas nova no est√°gio seguinte. Esta configura√ß√£o especial √© representada utilizando o <code>CoreStage::PostUpdate</code>  na fun√ß√£o de adicionar sistemas  <code>add_system_set_to_stage</code>:</p>
<pre><code class="language-rs">// main
pub mod grid;

fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_system(snake::movement_system)
        .add_system_set_to_stage(
            CoreStage::PostUpdate,
            SystemSet::new()
                .with_system(grid::position_translation)
                .with_system(grid::size_scaling),
        )
        .run();
}
</code></pre>
<p><img src="part-2/../imagens/simpleblock.png" alt="Resultado do c√≥digo at√© agora" /></p>
<h2 id="corrigindo-a-movimenta√ß√£o-na-grade"><a class="header" href="#corrigindo-a-movimenta√ß√£o-na-grade">Corrigindo a Movimenta√ß√£o na Grade</a></h2>
<p>At√© agora nosso sistema de movimento, <code>snake::movement_system</code>, era baseado em movimentar o componente <code>Transform</code> pela janela, por√©m com a implementa√ß√£o de grade precisamos atualizar o sistema para utilizar o componente <code>Position</code>. Primeiro passo ser√° atualizar os testes para utilizar <code>Position</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// snake.rs
#[cfg(test)]
mod test {
    // ...

    #[test]
    fn snake_head_has_moved_up() {
        // Setup
        let mut app = App::new();
        let default_position = Position{x: 3, y: 4}; // &lt;--

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system);

        // Add input resource
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);

        // Run systems
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(&amp;default_position, position);  // &lt;--
        })
    }

    #[test]
    fn snake_head_moves_up_and_right() {
        // Setup
        let mut app = App::new();
        let up_position = Position{x: 3, y: 4};  // &lt;--

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system);

        // Move Up
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(position, &amp;up_position);  // &lt;--
        });

        let up_right_position = Position{x: 4, y: 4};  // &lt;--

        // Move Right
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::D);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(&amp;up_right_position, position);  // &lt;--
        })
    }

    #[test]
    fn snake_head_moves_down_and_left() {
        // Setup
        let mut app = App::new();
        let down_left_position = Position{x: 2, y: 2};  // &lt;--

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system);

        // Move down
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::S);
        app.insert_resource(input);
        app.update();
        
        // Move Left
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::A);
        app.insert_resource(input);
        app.update();

        // Assert
        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(&amp;down_left_position, position);  // &lt;--
        })
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Como agora estamos lidando com valores inteiros, nossos testes podem verificar se a posi√ß√£o mudou com <code>assert_eq!</code> em vez de utilizar express√µes l√≥gicas com <code>assert!</code>. Al√©m disso, Position inicial com o valor <code>Position { x: 3, y: 3 }</code>, por isso os valores s√£o maiores que <code>0</code>. Ao executarmos os testes veremos que todas as positions est√£o iguais a ``Position { x: 3, y: 3 }`, corrigimos isso modificando a fun√ß√£o de input:</p>
<pre><code class="language-rs">// snake.rs
#[allow(clippy::needless_pass_by_value)]
pub fn movement_system(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut head_positions: Query&lt;&amp;mut Position, With&lt;Head&gt;&gt;,
) {
    for mut position in head_positions.iter_mut() {
        if keyboard_input.pressed(KeyCode::D) {
            position.x += 1;
        }
        if keyboard_input.pressed(KeyCode::W) {
            position.y += 1;
        }
        if keyboard_input.pressed(KeyCode::A) {
            position.x -= 1;
        }
        if keyboard_input.pressed(KeyCode::S) {
            position.y -= 1;
        }
    }
}
</code></pre>
<p>Agora sim, movimentamos o bloco c√©lula a c√©lula, infelizmente muito sensivel.</p>
<h2 id="configurando-a-janela"><a class="header" href="#configurando-a-janela">Configurando a Janela</a></h2>
<p>Pr√≥ximo passo √© fazermos com que a janela seja mais coerente com o snake game, j√° que por padr√£o a janela do snake game √© quadrada enquanto a janela padr√£o da bevy √© retangular. Para fazer isso, precisamos adicionar um recurso chamado <code>WindowDescriptor</code> que nos permite configurar o tamanha da tela e o t√≠tulo da janela:</p>
<pre><code class="language-rs">// mains.rs

fn main() {
    App::new()
        .insert_resource(WindowDescriptor {
            title: &quot;Snake Game&quot;.to_string(),
            width: 500.0,
            height: 500.0,
            ..default()         
        }) // &lt;--
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_system(snake::movement_system)
        .add_system_set_to_stage(
            CoreStage::PostUpdate,
            SystemSet::new()
                .with_system(grid::position_translation)
                .with_system(grid::size_scaling),
        )
        .run();
}
</code></pre>
<p>Outra mudan√ßa que pode ser interessante fazer √© mudar o fundo da tela para ficar um pouco mais escuro, podemos fazer isso adicionando o recurso <code>.insert_resource(ClearColor(Color::rgb(0.04, 0.04, 0.04)))</code> depois do <code>WindowDescriptor</code>. Pr√≥ximo passo √© fazermos a comida aparecer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gerador-de-comidas"><a class="header" href="#gerador-de-comidas">Gerador de Comidas</a></h1>
<p>Nosso pr√≥ximo passo √© come√ßarmos um sistema que gere comidas de forma aleat√≥ria pela grade. O primeiro passo √© definir qual sera a cor da comida. Como pretendemos fazer um jogo multiplayer, n√£o faz sentido termos comidas coloridas, j√° que estas ser√£o dos jogadores, sendo assim podemos criar um m√≥dulo chamado <code>food</code> e adicionar a constante <code>const FOOD_COLOR: Color = Color::rgb(1.0, 1.0, 1.0)</code>. Pr√≥ximo passo √© criamos um componente chamado <code>Food</code> para representar a comida:</p>
<pre><code class="language-rs">// food.rs
#[derive(Component)]
pub struct Food;
</code></pre>
<p>Pr√≥ximo passo √© criarmos um sistema que gera uma comida em um local aleat√≥rio da grade. Como este sistema utiliza aleatoriedade, podemos utilizar uma biblioteca de <code>property testing</code> semelhante a <em>proptest</em> do python, a <em>propcheck</em> do Elixir e a <em>quickcheck</em> do Haskell, chamada <code>proptest</code> para gerar centenas de cen√°rios de teste. Para isso, adicionamos <code>proptest = &quot;1.0.0&quot;</code> como uma <code>dev-dependencies</code> no Cargo.toml e para utilizarmos basta utilizar a macro <code>proptest!</code> e determinar os valores a serem executados (ou quantidade de cen√°rios) como argumento da fun√ß√£o de teste como em <code>_execution in 0u32..1000</code>:</p>
<pre><code class="language-rs">#[cfg(test)]
mod test {
    use crate::components::Position;

    use super::*;
    use proptest::prelude::*;

    proptest!{
        #[test]
        fn spawns_food_inplace(_execution in 0u32..1000) {
            // Setup app
            let mut app = App::new();

            // Add startup system
            app.add_startup_system(spawn_system);

            // Run systems
            app.update();

            let mut query = app.world.query_filtered::&lt;&amp;Position, With&lt;Food&gt;&gt;();
            assert_eq!(query.iter(&amp;app.world).count(), 1);
            query.iter(&amp;app.world).for_each(|position| {
                let x = position.x;
                let y = position.y;

                assert!(x &gt;= 0 &amp;&amp; x as i32 &lt;= (GRID_WIDTH -1) as i32);
                assert!(y &gt;= 0 &amp;&amp; y as i32 &lt;= (GRID_HEIGHT -1) as i32);
            })
        }
    }
}
</code></pre>
<p>A vantagem de um proptest √© que ele permite executar diversos cen√°rios e podemos definir regras de limite para falha, executando centenas de cen√°rios em poucos segundos. Para este teste passar, precisamos implementar a fun√ß√£o <code>spawn_system</code> para o m√≥dulo <code>food</code>:</p>
<pre><code class="language-rs">// food.rs
pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: FOOD_COLOR,
                ..default()
            },
            ..default()
        })
        .insert(Food)
        .insert(Position {
            x: (random::&lt;u16&gt;() % GRID_WIDTH) as i16,
            y: (random::&lt;u16&gt;() % GRID_HEIGHT) as i16,
        })
        .insert(Size::square(0.8));
}
</code></pre>
<p>O pr√≥ximo passo √© adicionar o sistema a <code>App</code> na fun√ß√£o <code>main</code>, por√©m este sistema tem uma pegadinha. Como n√£o queremos que o sistema gere uma nova comdia para cada frame, precisamos definir um tempo de intervalo para as comidas serem geradas. Como este cen√°rio de executar uma fun√ß√£o somente a cada x segundos √© muito comum no desenvolvimento de jogos a Bevy nos disponibiliza a struct <code>FixedTimestep</code> que nos permite definir um passo (<code>step</code>) em segundos, que ser√° usada com a fun√ß√£o <code>with_run_criteria</code>:</p>
<pre><code class="language-rs">// main.rs
pub mod food;

fn main() {
    App::new()
        .insert_resource(WindowDescriptor {
            title: &quot;Snake Game&quot;.to_string(),
            width: 500.0,
            height: 500.0,
            ..default()
        }) // &lt;--
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_system(snake::movement_system)
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(FixedTimestep::step(1.0)) // &lt;-- Pegadinha
                .with_system(food::spawn_system), // &lt;-- Sistema
        ) // &lt;--
        .add_system_set_to_stage(
            CoreStage::PostUpdate,
            SystemSet::new()
                .with_system(grid::position_translation)
                .with_system(grid::size_scaling),
        )
        .run();
}
</code></pre>
<p>Pr√≥ximo passo ser√° melhorar o movimento da cabe√ßa da cobra, tornando ele mais lento e cadenciado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="melhorando-a-cad√™ncia-do-movimento"><a class="header" href="#melhorando-a-cad√™ncia-do-movimento">Melhorando a Cad√™ncia do Movimento</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>

<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Desenvolvimento de Jogos online com Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-quemsou.html"><strong aria-hidden="true">1.1.</strong> Quem sou eu? (Sobre a autora)</a></li></ol></li><li class="chapter-item expanded "><a href="part-1/00-capa.html"><strong aria-hidden="true">2.</strong> Conceitos Básicos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-1/01-arq.html"><strong aria-hidden="true">2.1.</strong> Arquitetura de servidores</a></li><li class="chapter-item expanded "><a href="part-1/02-prd-rec.html"><strong aria-hidden="true">2.2.</strong> Predição e Reconciliação</a></li><li class="chapter-item expanded "><a href="part-1/03-interpolacao.html"><strong aria-hidden="true">2.3.</strong> Interpolação de Entidades</a></li><li class="chapter-item expanded "><a href="part-1/04-lag.html"><strong aria-hidden="true">2.4.</strong> Compensacão de Lag</a></li></ol></li><li class="chapter-item expanded "><a href="part-2/00-intro.html"><strong aria-hidden="true">3.</strong> Multiplayer Local Snake Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="part-2/01-bevy.html"><strong aria-hidden="true">3.1.</strong> Sobre a Bevy</a></li><li class="chapter-item expanded "><a href="part-2/02-ecs.html"><strong aria-hidden="true">3.2.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="part-2/03-cabeca.html"><strong aria-hidden="true">3.3.</strong> A Cabeça da Cobra</a></li><li class="chapter-item expanded "><a href="part-2/04-grid.html"><strong aria-hidden="true">3.4.</strong> Grade de Movimento</a></li><li class="chapter-item expanded "><a href="part-2/05-spawnfood.html"><strong aria-hidden="true">3.5.</strong> Gerador de Comidas</a></li><li class="chapter-item expanded "><a href="part-2/06-cadencia.html"><strong aria-hidden="true">3.6.</strong> Melhorando a Cadência do Movimento</a></li><li class="chapter-item expanded "><a href="part-2/07-rabo.html"><strong aria-hidden="true">3.7.</strong> Adicionando um Rabo a Cobra</a></li><li class="chapter-item expanded "><a href="part-2/08-colisoes.html"><strong aria-hidden="true">3.8.</strong> Colisões</a></li><li class="chapter-item expanded "><a href="part-2/09-migrando-versoes.html"><strong aria-hidden="true">3.9.</strong> Migrando versões da Bevy</a></li><li class="chapter-item expanded "><a href="part-2/10-multiplayer.html"><strong aria-hidden="true">3.10.</strong> Multiplayer Local</a></li></ol></li><li class="chapter-item expanded "><a href="part-3/00-capa.html"><strong aria-hidden="true">4.</strong> Multiplayer ONLINE Snake Game</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Desenvolvimento de Jogos online com Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="desenvolvimento-de-jogos-online-com-rust"><a class="header" href="#desenvolvimento-de-jogos-online-com-rust">Desenvolvimento de Jogos Online com Rust</a></h1>
<p>Por Julia Naomi Boeira.</p>
<p><a href="https://www.patreon.com/naomijub"><img src="https://media.giphy.com/media/FOe2EcTuBYGbG0Yc3w/giphy.gif" alt="" /></a> <br/>
<a href="https://www.patreon.com/naomijub">Patreon link</a></p>
<p>Escrever um livro open source é um trablho que precisa de incentivo e por isso Github Sponsor e Patreon são coisas importantes, pois além de atuarem como incetivo, são um bomr econhecimento do nosso trabalho. Escrevi bastantes livros pela casa do código, mas em especial no assunto Rust e Games eu sinto que falta alcance, e por isso gostaria de continuar produzindo esse tipo de material.</p>
<h2 id="sobre-o-livro"><a class="header" href="#sobre-o-livro">Sobre o livro</a></h2>
<p>Até o momento planejei 3 partes para este livro:</p>
<ol>
<li><a href="part-1/00-capa.html">Conceitos Básicos</a>, onde vamos falar sobre como funciona um jogo online e quais são suas limitações.</li>
<li>Jogo da cobrinha com a engine Bevy, essa é a parte menos criativa do processo e é uma cópia traduzida deste tutorial <a href="https://mbuffett.com/posts/bevy-snake-tutorial/">Bevy Snake Tutorial</a>. A diferença é que vou adicionar elementos de um jogo multiplayer local.</li>
<li>Servidor autoritário com a Bevy.</li>
</ol>
<p>ESPERO QUE APROVEITEM A LEITURA e feedbacks são bem vindos. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quem-sou-eu"><a class="header" href="#quem-sou-eu">Quem sou eu</a></h1>
<p>Eu sou uma desenolvedora de jogos na Ubisoft Winnipeg atuando no desenvolvimento de sistemas online, middlewares e ferramentas para jogos. Trabalho principalmente com C++, mas um pouco de C# e Rust. Sou autora dos livros:</p>
<ul>
<li>📖 <a href="https://www.apress.com/gp/book/9781484232156">Lean Game Development - Inglês - Apress</a></li>
<li>📖 <a href="https://www.casadocodigo.com.br/products/livro-lean-game-development">Lean Game Development - Português - Casa do Código</a></li>
<li>📖 <a href="https://www.casadocodigo.com.br/products/livro-rust-funcional-concorrente">Programação Funcional e Concorrente em Rust - Casa do Código</a></li>
<li>📖 <a href="https://www.casadocodigo.com.br/products/livro-tdd-games">TDD para Games - Casa do Código</a></li>
<li>📖 <a href="https://github.com/naomijub/web-dev-rust-book">[OPEN SOURCE] Desenvolvimento Web com Rust</a></li>
</ul>
<p>E atualmente estou desenvolvendo em paralelo a este livro o livro <a href="https://github.com/naomijub/Unity-FPS-game-with-TDD-Book">Unity FPS game with TDD - Inglês</a>.</p>
<p>Tenho atuado como evangelista voluntaria de Rust desde 2017 quando me deparei com Rust pela primeira vez e percebi que esta maravilhosa linguagem era um raio de esperança nos problemas que eu tinha no desenvolvimento de jogos com C++.</p>
<p>Hobbies como engenheira são aprender novas linguagens, em especial de paradigmas diferentes ou que pelo menos possuem uma forma bem diferente de resolver problemas, tornando Clojure e Elixir minhas duas outras linguagens favoritas. E no meu tempo livre escrever e fazer prototipos bobos de jogos como esses (quando eu estava aprendendo Java) https://github.com/naomijub/DiammondSeek e https://github.com/naomijub/PacmanLabyrinth.</p>
<p>Curiosidade sobre aprender linguagens de programação, tentei aprender Java na faculdade, mas simplesmente não entrava na minha cabeça, foi graças a XNA e aos C# que consegui aprender Java e arrumar trabalho com software corporativo. Tentei aprender Go 3 vezes e NUNCA entra na minha cabeça. Trabalhei muito com Python a ponto de dizer que era uma das minhas linguagens favoritas, mas hoje em dia eu fujo de qualquer projeto Python.</p>
<p>Passei pelas faculdades de Matematica Aplicada, Engenharia de Materiais e Ciências da Computação. Larguei a CC porque já estava cursando mestrado em inteligência artificial aplicada a engenharia de materiais e depois aiinda fiz especialização em desenvolvimento de jogos para suprir as áreas que faltavam do meu conhecimento em jogos. A empresa que mais gostei de trabalhar é a Ubiisoft DE WINNIPEG, mas outras empresas que gostei muito foram a Thoughtworks até 2018, onde conheci pessoas incríveis que são minhas amigas até hoje, e Nubank que foi um lugar de muito aprendizado.</p>
<p>Para dúvidas sobre o livro, discussões sobre o tema e correções sugiro abrir <a href="https://github.com/naomijub/Rust-game-dev/issues">issues</a> ou criar <a href="https://github.com/naomijub/Rust-game-dev">Pull Requests</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conceitos-importantes-para-o-desenvolvimento-de-serviços-de-jogos-digitais"><a class="header" href="#conceitos-importantes-para-o-desenvolvimento-de-serviços-de-jogos-digitais">Conceitos importantes para o desenvolvimento de serviços de jogos digitais</a></h1>
<ol>
<li>O problema e sua arquitetura básica.</li>
<li>Predição e reconciliação.</li>
<li>Interpolação de entidades.</li>
<li>Compensação de lag.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="o-problema-e-sua-arquitetura-básica"><a class="header" href="#o-problema-e-sua-arquitetura-básica">O problema e sua arquitetura básica.</a></h1>
<p>Neste capítulo vamos entender quais os problemas que serviços para games enfrentam e quais são algumas das formas de resolvê-los para obtermos um conjunto de serviços que tornam o desenvolvimento de jogos multiplayer uma realidade. </p>
<blockquote>
<p><em>Multiplayer</em></p>
<p>Jogos multiplayer são jogos com mais de uma pessoa jogando simultaneamente se conectando através de um servidor.</p>
</blockquote>
<h2 id="introdução"><a class="header" href="#introdução">Introdução</a></h2>
<p>Desenvolver um jogo é bastante complicado, agora desenvolver um jogo para mais de uma pessoa jogando é ainda mais complicado. Felizmente, podemos resumir os problemas que servidores de jogos possuem em duas categorias:</p>
<ol>
<li>Humanos maliciosos.</li>
<li>Física realística.</li>
</ol>
<h3 id="humanos-maliciosos"><a class="header" href="#humanos-maliciosos">Humanos Maliciosos</a></h3>
<p>Tudo começa com o desejo das pessoas de trapacear em um jogo.</p>
<p>Podemos dizer que para jogos single-player, ou de somente uma pessoa jogando, trapacear afeta a experiência, mas é uma escolha da pessoa burlar a experiência do jogo, a final a trapaça não afeta ninguém além da pessoa, porém para jogos multiplayer o cenário é diferente. Em um jogo multiplayer, uma pessoa burlando as regras do jogo pode conseguir algumas vantagens que além de afetar sua experiência, tornam a experiência das outras pessoas muito pior. Alguns exemplos que já vi na minha vida:</p>
<ul>
<li>Vida muito maior que 100%, ou seja, a pessoa possuia 1000% de vida em uma partida, tornando ela quase imortal, já que colecionava muito mais recursos.</li>
<li>Tiros duplos ou triplos, ou seja, para cada vez que a pessoa realizava um tiro, duas ou três balas eram enviadas ao mesmo tempo, reduzindo muito as chances do alvo de sobreviver.</li>
<li>Atravessar paredes, não sei bem como este mod funcionava, mas acredito que projetava a pessoa para além do objeto de colisão.</li>
<li>Paredes invisíveis, ou seja, a pessoa havia removido a renderização de objetos inanimados, o que a permitia visualizar todos os alvos antes de ser percebida.</li>
<li>Velocidade 2, ou seja, para cada passo da pessoa, o jogo a movia 2 vezes mais rápido.</li>
</ul>
<p>Tendo estes eventos em mente, podemos concluir que existe uma única solução realmente confiável para um servidor NÃO CONFIAR NO USUÁRIO.</p>
<h2 id="como-não-confiar-no-usuário"><a class="header" href="#como-não-confiar-no-usuário">Como não confiar no usuário?</a></h2>
<p>A resposta para está pergunta é na verdade bastante simples, o cliente, ou seja a pessoa jogando, deve fornecer o mínimo de informações em relação ao seu posicionamento, balas disparadas, direção, etc. Enquanto isso, o servidor deve ser autoritário, recendendo estes comandos básicos e informado para o cliente o que está acontecendo. Em outras palavras, o cliente envia comandos e botões pressionados para o servidor, o servidor executa o próximo passo do jogo e devolve ao cliente as novas informações. Isso não vai impedir que o servidor seja explorado de vulnerabilidades, mas reduzirá drasticamente a capacidade de uma pessoa jogando de trapacear. Assim, para o caso da pessoa que está dando tiros múltiplos, ela pode até ver 3 tiros saindo de sua arma, mas o servidor reconhecerá somente 1 e propagará ao resto do jogo somente 1. </p>
<p>Resumindo, o gerenciamento do estado do jogo é realizado apenas pelo servidor. Clientes enviam apenas suas interações com o controle, teclado e mouse para o servidor. O servidor atualiza o estado do jogo e envia esta informação de volta aos clientes que apenas renderizam ela em sua tela.</p>
<h2 id="o-problema-com-a-física"><a class="header" href="#o-problema-com-a-física">O problema com a física</a></h2>
<p>Parece uma solução perfeita né? Infelizmente ela funciona bem somente quando o jogo é baseado em turnos, como jogos de carta e alguns RPGs, ou a rede é em LAN, já que neste cenário a comunicação com o servidor é considerada instantânea. Para jogos como Call of Duty e Rainbow Six está estratégia vai contar com um enorme delay já que precisam se conectar com servidores distantes.</p>
<p>Assim, vamos supor o meu cenário. Mesmo que minha conexão à internet seja sensacional (mentira, isso não existe), estou em Porto Alegre e o servidor mais próximo está em São Paulo para o jogo X. Porto Alegre e São Paulo estão distantes entre si mais de 1100 km. Na física a velocidade da luz é a maior velocidade atingível por um corpo (photons no caso), ou seja 300.000 km/s no vácuo, assim a luz levaria 3,7 milisegundos para percorrer os 1100 km (1100/300000 = 0,0036667 segundos). Essa é a velocidade da luz no vácuo, parece bem otimista né? Mas neste caso estamos falando de bytes trafegando pela internet, que na prática são elétrons e pulsos de luz trafegando por um cabo, e provavelmente não em linha reta, o que deve aumentar esse valor de 3,7 por alguns microsegundos. Existe mais um fator importante em como a internet funciona, os dados trafegados pela internet são na verdade uma séries de pacotes, ou <em>hops</em>, que trafegam de um roteador ao outro, certamente abaixo da velocidade da luz. Além disso, roteadores possuem um atraso extra, já que todos os pacotes devem ser abertos, copiados e inspecionados para então serem reroteados a seus destinos finais.</p>
<p>Vamos então dizer que o atraso dos meus pacotes até São Paulo leva 25 ms, o que seria um tempo excepcional (neste momento um ping da minha máquina ao google.com está levando entre 25 e 30 ms), mas tempos de 50 ms e até 200 ms não seria impressionantes para certas situações. Agora vamos dizer que nossa jogadora apertou para atirar no momento x, isso quer dizer que nosso servidor receberá a ação de atirar 25 ms depois. Digamos que nosso servidor processe o evento em um tempo substancialmente menor que 1 milisegundo, algo como 500 us, isso quer dizer que quando o servidor responder, a jogadora receberá essa atualização 50 ms depois de ter clicado para atirar. Humanos em média enxergam 25 frames por segundo, o que indica que o delay já é maior que nossa capacidade de observação por 10 ms. Esses 10 ms de delay na nossa percepção já são suficiente para termos uma experiência ruim de jogabilidade, ou seja, o famoso <em>lag</em>, ou atraso. A imagem a seguir demonstra este efeito:</p>
<p><img src="part-1/../imagens/ping_time.jpg" alt="Diagrama de atraso na conexão cliente servidor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predição-e-reconciliação"><a class="header" href="#predição-e-reconciliação">Predição e Reconciliação</a></h1>
<p>No capítulo anterior falamos sobre o lag, ou atraso entre ação no cliente e a atualização enviada pelo servidor nos baseando no modelo de cliente servidor na qual o cliente não responde seu estado, mas sim a ação desejada, para que o servidor atualize seu estado. Um jogo que pode levar algumas frações de segundo para atualizar o estado pode ser considerado de jogabilidade ruim ou injogável devido ao lag de renderização. Assim, neste capítulo vamos explorar uma solução para minimizar este problema.</p>
<h2 id="predição-pelo-lado-do-cliente"><a class="header" href="#predição-pelo-lado-do-cliente">Predição pelo lado do cliente</a></h2>
<p>Como a maior parte dos jogos é deterministico, ou seja, não há aleatoriedade no resultado, podemos prever qual vai ser o próximo passo do jogo antes do servidor responder. Para maior parte das pessoas jogando esta experiência será &quot;idêntica&quot; ao jogo sem servidor, mas para as pessoas trapaceando a experiência não será realistica, desfavorecendo o jogo com trapaças. Assim, podemos assumir que nosso servidor receberá ações válidas para 99% dos casos, nos permitindo prever o próximo instante.</p>
<p>No cenário que descrevemos anteriormente nossa ação com o servidor levava 50 ms para atualizar o estado do jogo, para só então uma animação ser ativada (digamos que ela leve mais 50 ms) como a imagem a seguir nos mostra:</p>
<p><img src="part-1/../imagens/animation_time.jpg" alt="Diagrama de atraso na conexão cliente servidor com tempo de animação" /></p>
<p>Nessa imagem podemos ver que o atraso do servidor (50 ms) mais o tempo de animação (50 ms) fará com que percebemos o tiro apenas 100 ms depois dele ter sido realizado, ou seja, no terceiro frame que nosso olho detecta, certamente uma experiência desagradável. </p>
<p>Como o jogo nosso jogo é deterministico, podemos presumir que a ação será executada com sucesso no servidor, aplicar nossas regras locais de validação e iniciar a animação do tiro no momento em que pressionamos o botão para realizar a ação. Para a grande maioria dos casos a atualização do servidor e o final da animação vão coincidir em estado e fizemos um predição bem sucedida, fazendo com que não exista atrasos entre a ação e a renderização. Para os casos de trapaça a animação ocorrerá, mas em nada afetará o estado geral do jogo, somente afetará negativamente a experiência do usuário trapacendo.</p>
<h3 id="problemas-de-sincronização"><a class="header" href="#problemas-de-sincronização">Problemas de sincronização</a></h3>
<p>Infelizmente essa estratégia não é perfeita e problemas de sincronização ou eventos conflitantes podem acontecer. Imagine agora o cenário na qual o personagem está se movimentando e o tempo de atraso é 75 ms em vez dos 50 ms anteriores, o tempo da animação é de 30 ms e a pessoa pressiona para se movimentar para frente 2 vezes seguidas. A imagem a seguir e os passos marcados na imagem exemplificam:</p>
<p><img src="part-1/../imagens/sync_problem.jpg" alt="Diagrama com problemas de sincronização de ações" /></p>
<ol start="0">
<li>Personagem está o ponto <code>(0,0)</code> no instante 0 ms.</li>
<li>Neste mesmo instante a pessoa pressiona para se movimentar enviando uma ação para o servidor que durará 75 ms.</li>
<li>A ação do passo 1 ativou uma animação que moveu o personagem para a posição <code>(0,1)</code> 30 ms depois.</li>
<li>Na posição <code>(0,1)</code> uma nova ação de movimentação acontece, enviando esta nova ação para o servidor que durará mais 75 ms.</li>
<li>A ação do passo 3 ativou uma nova animação que moveu o personagem para a posição <code>(0,2)</code> 30 ms depois. Já se passaram 60 ms.</li>
<li>15 ms depois de terminar a ação 4, o servidor respondeu a ação 1 fazendo o personagem voltar para posição <code>(0,1)</code>. Já se passaram 75 ms.</li>
<li>30 ms depois de terminar a ação 5, o servidor respondeu a æção 3 fazendo o personagem voltar para posição <code>(0,2)</code>. Ja se passaram 105 ms.</li>
</ol>
<p>Com este detalhamento podemos ver que pelo ponto de vista da pessoa jogando, o personagem vai responder as duas primeiras ações se movimentando até a posição <code>(0,2)</code> para então voltar para posição <code>(0,1)</code> e depois ainda voltar para posição <code>(0,2)</code> gerando uma péssima experiência de jogo, forçando assim a adotarmos uma estratégia de reconciliação.</p>
<h2 id="reconciliacão-pelo-servidor"><a class="header" href="#reconciliacão-pelo-servidor">Reconciliacão pelo servidor</a></h2>
<p>A chave deste problema é entender a diferença temporal dos cliente e do servidor, já que o cliente vê o jogo em tempo real (presente) e o servidor autoritário está no passado. Assim, sempre haverá uma diferença de sequência de comandos a serem processados entre o cliente e o servidor. Felizmente isso não é muito difícil de resolver.</p>
<p>Primeiro passo é fazer com que o cliente salve suas ações em uma sequência de comandos, assim a primeira movimentação seria a ação <code>#1</code> e a segunda movimentação seria a ação <code>#2</code>. Logo, o servidor poderá respoderá responder uma ação identificando a qual comando ela pertence. A figura a seguir exemplifica o que acontece:</p>
<p><img src="part-1/../imagens/reconciliacao.jpg" alt="Diagrama de reconciliação de ações" /></p>
<ol>
<li>O evento <code>#1</code> é lancado, 30 ms depois da animação a posição <code>#1 =&gt; (0,1)</code> é registrada e 38 ms depois o servidor recebe a ação <code>#1</code>. A sequência de comandos é <code>[#1 =&gt; (0,1)]</code>.</li>
<li>O evento <code>#2</code> é lancado, 30 ms depois da animação a posição <code>#2 =&gt; (0,2)</code> é registrada e 38 ms depois o servidor recebe a ação <code>#2</code>.  A sequência de comandos é <code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>.</li>
<li>O evento <code>#1</code> é retornado pelo servidor com o valor <code>#1 =&gt; (0,1)</code>. A função <code>check</code> para o estado da sequência de comandos atual (<code>[#1 =&gt; (0,1), #2 =&gt; (0,2)]</code>) e o evento <code>#1 =&gt; (0,1)</code> recebido é executado para reconciliar. Remove todos os comandos até <code>#1 =&gt; (0,1)</code> da sequência de comandos.</li>
<li>O evento <code>#2</code> é retornado pelo servidor com o valor <code>#2 =&gt; (0,2)</code>. A função <code>check</code> para o estado da sequência de comandos atual (<code>[#2 =&gt; (0,2)]</code>) e o evento <code>#2 =&gt; (0,2)</code> recebido é executado para reconciliar. Remove todos os comandos até <code>#2 =&gt; (0,2)</code> da sequência de comandos.</li>
<li>Sequência de comandos é <code>[]</code>.</li>
</ol>
<blockquote>
<p><strong>Descrição da função <code>check</code></strong></p>
<ol>
<li>Argumentos são <strong>sequência de comandos executados</strong> e <strong>evento #</strong>.</li>
<li>Verifica se o valor de <code>#n</code> na sequência de comando é igual ao que o servidor retornou. Caso não for igual retorna erro.</li>
<li>Aplica o próximo evento, <code>#n+1</code>, ao resultado do evento <code>#n</code>. Caso o resultado de <code>#n</code> mais o evento <code>#n+1</code> não corresponder ao evento salvo na sequência de comandos para <code>#n+1</code> retornar erro.
<strong>Observação</strong>: Se o evento que o servidor responder não for <code>#n</code> esperado, podemos concluir que o pacote se perdeu ou o servidor retornou um erro, assim existem duas alternativas <strong>1.</strong> descartar todos os pacotes até o evento recebido e fazer o check, ou <strong>2.</strong> aplciar todos os eventos anteriores até o evento recebido. Particularmente vejo a soluação <strong>1</strong> sendo a mais comum, pois sabemos que o estado anterior está certo.</li>
</ol>
</blockquote>
<p>Este é um exemplo bem simples de movimentação e bastante intuitivo de visualizar, mas as aplicações de predição e reconciliação podem ser feitas em praticamente qualquer área do jogo e qualquer tipo de jogo. Imagine um jogo de corrida multiplayer e você está na linha de chegada em velocidade máxima, com um carro logo atrás de você. No próximo segundo considerando as atuais circunstâncias, é óbvio que você vai ganhar, pois você está na frente do outro carro e com uma velocidade maior, mas agora imagine que alguns milésimos antes do final da corrida a outra pessoa apertou o botão de nitro e te ultrapassou. A predição diria que seu carro ganharia a corrida, mas o servidor disse que não e você ficou em segundo lugar. Isso nos leva a um ponto interessante, mesmo em ambientes determinísticos, existe a chance da predição e da reconciliação não serem iguais, Para um cenário de fim de jogo como descrito aqui é bastante trivial a resposta, ignore a predição e responda com o resultado do servidor, porém se isso acontecer frequentemente no meio do jogo a experiência de jogabilidade vai ser ruim.</p>
<p>No próximo capítulo vamos explorar como resolver este problema de predição e reconciliação através de interpolação de entidades.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpolação-de-entidades"><a class="header" href="#interpolação-de-entidades">Interpolação de Entidades</a></h1>
<p>Nos capítulos anteriores lidamos com o problema de uma pessoa poder trapacear e como fazer com que o jogo se mantenha conciliado com um servidor autoritário dando a sensação de que o servidor não existe, porém não expandimos este problema para quando estamos lidando com mais de uma pessoa jogando online. Neste capítulo vamos explorar técnicas que nos permitem manter a jogabilidade quando várias pessoas estão interagindo umas com as outras em um ambiente online.</p>
<h2 id="lidando-com-centenas-de-ações-simultâneas"><a class="header" href="#lidando-com-centenas-de-ações-simultâneas">Lidando com centenas de ações simultâneas</a></h2>
<p>No capítulo anterior falamos sobre o servidor processar uma sequência de comandos e retornar como eventos autoritários para o cliente. Imagine agora que este cliente está alucinadamente mandando eventos para o servidor e que ele não está sozinho, pois existem mais uma dezena de clientes mandando eventos simultaneamente para o servidor. Sendo assim, atualizar o estado do jogo para cada comando recebido de cada cliente e depois transmitir o estado do jogo de volta para cada cliente consumiria muita CPU e muita banda.</p>
<p>Tendo em vista evitar o consumo desnecessário de CPU e banda outra abordagem parece fundamental. Esta nova abordagem consiste em enfileirar os comandos que os clientes enviam, sem processar eles, e em vez de atualizar o estado do jogo imediatamente para cada comando, fazemos atualizações periódicas e de baixa frequência, por exemplo 10 vezes por segundo. Este atraso entre cada update, no caso do nosso exemplo de 100 ms, é chamado de <em>time step</em>, ou passo temporal. O <em>time step</em> é definido como uma iteração de loop de update na qual todas as informações não processdas de todos clientes são aplicadas e o novo estado é transmitido para todos os clientes. Ou seja, o estado do jogo é atualizado com uma periodicidade específica de forma independente e não é afetado pela quantidade de clientes e seus comandos.</p>
<p><strong>Obs</strong>: Muitas vezes a física do jogo é atualizada em passos de tempo menor para aumentar a previsibilidade.</p>
<h2 id="updates-de-baixa-frequência"><a class="header" href="#updates-de-baixa-frequência">Updates de baixa frequência</a></h2>
<p>Seguindo com o conceito de um update de estado a cada 100 ms um novo problema aparece, os outros clientes não tem ideia de como seus oponentes estão se atualizando, gerando eventos que parecem bastante bruscos a cada atualização. Ou seja, predição e reconciliação funcionam muito bem para o lado do cliente, mas não para o resto das pessoas jogando. A imagem a seguir detalha melhor essa situação:</p>
<p><img src="part-1/../imagens/step_time.jpg" alt="Diagrama de efeitos do step time para dois clientes" /></p>
<p>Na imagem anterior podemos ver o mesmo cenário de predição e reconciliação funcionando muito bem para o <code>Cliente 1</code>, permitindo que sua jogabilidade seja coerente com a jogabilidade de um jogo single-player, porém para o <code>Cliente 2</code> podemos ver que as transições <code>(0,0) -&gt; (0, 1)</code> e <code>(0, 1) -&gt; (0, 2)</code> do <code>Cliente 1</code> são bruscas para o <code>Cliente 2</code>, já que estas atualizações dependem exclusivamente das atualizações do servidor.</p>
<p>Agora voltando ao exemplo dos carros que mencionamos no final do capítulo anterior. Estamos em uma situação na qual temos controle do nosso carro, mas o carro da outra pessoa é determinado pelo servidor. Se este carro recebe atualizações apenas a cada 100 ms, teremos uma animação péssima de seu deslocamento, nos obrigando a encontrar outra solução para melhorar a experienência. Esta outra soluação envolve fazer a predição da posição do outro carro do lado do nosso cliente, pois sabemos sua direção, sua velocidade e temos certeza que o carro não fará um movimento radical, como girar 180 graus. Sendo assim, se o outro carro está indo reto com uma velocidade de 100 km/h, podemos prever que nos próximos 100 ms o carro estará 0,2 metros a frente de onde ele está neste exato segundo. Essa predição pode parecer maravilhosa, já que ele só se deslocou 0,2 metros em linha reta, mas infelizmente 100 ms é tempo suficiente para muitas outras coisas acontecerem como uma curva aparecer, bater em um poste, desacelerar ou até mesmo frear bruscamente. Chamamos está técnica de <strong>dead reckoning</strong>. Portanto, o <strong>dead reckoning</strong> é uma técnica de predição dos movimentos de outras pessoas em jogos na qual sua posição, velocidade e direção não são afetadas de forma instantânea, permitindo uma pequena margem para prever movimentos sem grandes danos à experiência. Caso alguma ação inesperada aconteça aceitamos que vamos conviver com uma cena estranha.</p>
<blockquote>
<p><strong>Dead reckoning</strong> é originalmente uma estratégia militar para prever a próxima localização de um navio, que se move lentamente e sem grandes oscilações de direção, para que se possa prever onde um torpedo precisa ser lançado para acertar o navio.</p>
</blockquote>
<h2 id="e-para-cenários-muito-dinâmicos"><a class="header" href="#e-para-cenários-muito-dinâmicos">E para cenários muito dinâmicos?</a></h2>
<p>Como falamos anteriormente, <em>dead reckoning</em> é bom para jogos que não são tão dinâmicos, como jogos de corrida, porém para jogos na qual as pessoas jogando se movimentam constantemente, atiram, se abaixam, pulam, giram 180 graus é impossível prever o próximo passo da pessoa apenas com dados anteriores. Se aplicássemos dead reckoning em um jogo de tiro veríamos personagens se teletransportando pequenas distâncias, múltiplas balas saindo de diferentes lugares e personagens fazendo movimentos impossíveis. Sendo assim, outra estratégia é necessária para jogos de tiro, sendo essa a <strong>interpolação de entidades</strong>.</p>
<p>No cenário descrito do parágrafo anterior, temos certeza apenas de 1 coisa, que a cada 100 ms temos uma atualização das informações do estado do jogo e dos personagens. Tendo em vista que sabemos o passado todo, o truque é mostrar para pessoa jogando o que acontece entre esses dados que já sabemos. Ou seja, a solução é mostrar para a pessoa que está jogando o passado relativo dos outros personagens. Isso que chamamos de <strong>interpolação de entidades</strong>.</p>
<p>Explicando melhor, podemos dizer que no momento <code>t = n + 1</code>, que você acabou de receber, a posição do momento <code>t = n</code> é conhecida. Sendo assim, neste momento <code>t = n + 1</code> conhecemos as posições referentes a <code>t = n</code> e <code>t = n + 1</code>. Portanto, para o momento <code>t = n + 2</code> mostramos o passado, ou seja, o que ocorreu no momento <code>t = n = 1</code> e para o momento <code>t = n + 1</code> mostramos o que ocorreu no momento <code>t = n</code> do outro personagem. Deste modo o servidor está sempre mostrando as informações reais de movimentação dos outros personagens, porém com um &quot;pequeno atraso&quot; de 100 ms. A imagem a seguir exemplifica:</p>
<p><img src="part-1/../imagens/interpolation.jpg" alt="Diagrama de interpolação" /></p>
<p>O diagrama de interpolação nos mostra bem como estamos prevendo os passos intermediários. Para um momento inicial estamos com a posição <code>P(0,1)</code>, depois o servidor nos atualiza com a posição <code>P(0,1)</code> novamente, neste momento exibimos a posição que conheciamos antes do <em>step time</em>, a <code>V(0,1)</code>. Quando recebemos a posição <code>P(0,2)</code>, mantemos a posição <code>V(0,1)</code>, que havia sido entregue anteriormente pelo servidor. Agora sabemos o vetor de posições <code>[P(0, 1), #1 P(0, 1), #2 P(0, 2)]</code>, e podemos interpolar que no próximo <em>step time</em> nosso personagem inimigo vai para a posição <code>V(0,2)</code> passando pela posição <code>V(0,1.75)</code>, melhorando a experiência da pessoa jogadora.</p>
<p>Na maior parte dos casos interpolação funciona muito bem, porém existem alguns casos que pode ser importante enviar mais informações de posições intermediárias entre <code>#1</code> e <code>#2</code>. Ou seja, se atualizações de estado a cada 100 ms não são suficientes, podemos enviar as últimas 10 atualizações que ocorreram com intervalos de 10 ms, que certamente vai fazer com que seu jogo pareça mais realista. Note que está técnica faz com que cada jogadora perceba pequenas variações do ambiente do jogo em relação às outras pessoas, que geralmente não é algo perceptível. Infelizmente, nada é perfeito e existem exceções como no caso de quando damos um tiro, pois estamos atirando na personagem da outra pessoa de 100 ms atrás. É nesse caso que precisamos explorar o último tópico desta parte, compensação de lag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compensacão-de-lag"><a class="header" href="#compensacão-de-lag">Compensacão de Lag</a></h1>
<p>O cenário que temos até agora parece funcionar muito bem para percebermos movimentações, pois temos:</p>
<ul>
<li>Dado um tempo n, nosso servidor recebe informações de todos os clientes.</li>
<li>Servidor processa todas as informações e transmite as atualizações.</li>
<li>Estas atualizações são periódicas e de baixa frequência.</li>
<li>Clientes enviam informações e verificam seus efeitos localmente.</li>
<li>Clientes recebem as atualizações de estado do jogo:
<ol>
<li>Reconciliam com os efeitos que previram.</li>
<li>Interpolam os efeitos dos outros personagens.</li>
</ol>
</li>
<li>Cliente se vê no presente, mas vê os outros cliente no passado.</li>
</ul>
<p>Esta situação é geralmente ótima, a menos quando precisamos garantir situações como um tiro na cabeça, que qualquer pequena variação pode causar um erro, pois as informações de tempo e espaço são muito sensíveis. É ai que entra a compensação de lag.</p>
<p>Imagine o cenário na qual você é uma sniper mirando perfeitamente na cabeça de um personagem &quot;imóvel&quot;, um tiro dificil de errar. Você atira e, magicamente, nada acontece. Você se irrita, sai da partida e desliga o jogo pensando como pode ter errado aquele tiro perfeito e, pior, a pessoa que você devia ter matado te matou. Este é o efeito de lag temporal, pois seu tiro ocorreu em um personagem que estava 100 ms no passado, para quem gosta de física, é como se a velocidade da luz fosse muito muito muito inferior a que realmente é. Felizmente, existem algumas estratégias para resolver este efeito. Vamos detalhar como isso pode ser reolvido:</p>
<ol>
<li>Você deu um tiro, seu cliente enviou as informações para o servidor, mas desta vez enviou mais informações além do botão que você clicou, pois enviou o botão que você apertou, o exato momento temporal que você apertou o botão (e se o botão de mira estava sendo apertado) e o que estava exatamente em sua mira neste instante.</li>
<li>Como o servidor está recebendo todos momentos temporais, ele pode reconstruir os eventos temporalmente ordenados, ou seja, o servidor pode reconstruir o mundo no exato momento de seu tiro, assim como para todos outros clientes.</li>
<li>Sabendo o que sua arma estava mirando no momento de seu tiro, a cabeça de seu inimigo, seu presente passa a ser considerado como válido no servidor, já que ele compensa esta diferenca.</li>
<li>O servidor processa o tiro e transmite para todos os clientes, deixando seu oponente furioso por ter levado um headshot.</li>
</ol>
<p>E é no passo dois que a compensacão de lag ocorre.</p>
<h2 id="conclusão"><a class="header" href="#conclusão">Conclusão</a></h2>
<p>Primeira coisa que fizemos foi entender qual o grande problema do desenvolvimento de servidores para jogos, pessoas querendo trapacear, e a partir disso entendemos qual a solução básica, um cliente que só envia comandos pro servidor e um servidor autoritário. Vimos que com um servidor autoritário alguns problemas de defasamento temporal pode ocorrer entre a informação que temos e a informação que o servidor nos obriga a ter. Para reduzir estes problemas aprendemos as técncias de predição e de reconciliação, mas descobrimos problemas de sincronização com outros clientes. Para resolver os problemas de sincronização aprendemos as técncias de dead reckoning e interpolação de entidades, que são ótimas técnicas, mas ainda podem falhar na hora que ações muito sensíveis espacialmente são executadas. Para resolver este problema de ações sensíveis, aprendemos compensação de lag, mas ainda nos falta por a mão na massa. Nos próximos capítulos vamos explorar um jogo simples de tiro e um exemplo de servidor para ele.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiplayer-snake-game"><a class="header" href="#multiplayer-snake-game">Multiplayer Snake Game</a></h1>
<p>Vulgo jogo da cobrinha online e em Rust.</p>
<h2 id="sobre-esta-seção-do-livro"><a class="header" href="#sobre-esta-seção-do-livro">Sobre esta seção do livro</a></h2>
<p>Este era um projeto que surgiu inicialmente como um livro para a Casa do Código (Visivelmente minha editora favorita), mas infelizmente a engine que eu estava usando foi &quot;descontinuada&quot; e decidi que queria um livro mais vivo, que pudesse se adaptar mais rapidamente a evolução das engines, assim como novas versões do Rust e o mundo de desenvolvimento de jogos. Assim, para este livro comecei a pesquisar qual seria o jogo mais didático e menos cansativo para desenvolver na <a href="https://bevyengine.org/">Bevy Engine</a>, a nova engine promissora de Rust, optando por traduzir este <a href="https://mbuffett.com/posts/bevy-snake-tutorial/">tutorial</a> e adicionar o fator multiplayer local nele. </p>
<blockquote>
<p>A engine descontinuada que menciono é a https://amethyst.rs/.</p>
</blockquote>
<h2 id="organização"><a class="header" href="#organização">Organização</a></h2>
<ul>
<li>Sobre a Bevy Engine e configurando uma janela vazia.</li>
<li>ECS</li>
<li>Snake Game</li>
<li>Multiplayer local de Snake Game </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sobre-a-bevy"><a class="header" href="#sobre-a-bevy">Sobre a Bevy</a></h1>
<p>Bevy engine é uma das game engines mais promissoras do mercado e um grande esforço coletivo para a comunidade rust_gamedev. Se trata de uma engine orientada a dados, gratuíta e open source, sob as licenças Apache e MIT, ou seja, perfeita para qualquer projeto. Ela possui como objetivos de design:</p>
<ul>
<li>Um conjunto completo de features para jogos 2D e 3D, podendo inclusive ser aplicada para outros objetivos.</li>
<li>Simples e poderosa, mas mantendo o fácil aprendizado.</li>
<li>Orientada a dados utilizando o paradigma ECS (Entity component system, no próximo capítulo).</li>
<li>Modular, use o que quiser, adicione o que quiser, e substitua o que quiser.</li>
<li>Rápida, paralela e em Rust &lt;3.</li>
<li>Compilação rápida</li>
</ul>
<p>A atual versão da Bevy é <a href="https://crates.io/crates/bevy"><img src="https://img.shields.io/crates/v/bevy.svg" alt="Crates.io" /></a> e este livro foi desenvolvido com a versão <code>0.7</code>, mas contém guias de migração para as versões <code>0.8</code> e <code>0.9</code>. A compatibilidade com Rust esta garantida para a versão <code>1.66</code>.</p>
<h2 id="iniciando-o-projeto"><a class="header" href="#iniciando-o-projeto">Iniciando o projeto</a></h2>
<blockquote>
<p>Para iniciar um projeto com a Bevy é necessário possuir Rust e Cargo, caso você não possua basta fazer download em https://rustup.rs/.</p>
</blockquote>
<p>Vamos iniciar nosso projeto com um simples <code>cargo new bevy-snake --bin</code>, que gera um projeto executável em Rust chamado <code>bevy-snake</code>. Este projeto vai possuir um <code>Cargo.toml</code> (onde os metadados do projeto estão localizados), um <code>src/main.rs</code> e um <code>.gitignore</code>:</p>
<pre><pre class="playground"><code class="language-rust">// src/main.rs
fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<pre><code class="language-sh"># .gitignore 
/target
</code></pre>
<p>Agora adicionamos versão atual da bevy (<code>bevy = &quot;0.7&quot;</code>) a seção <code>[dependencies]</code> do Cargo.toml. Adicionamos também a crate de aleatoriedade <code>rand</code>:</p>
<pre><code class="language-toml">[dependencies]
bevy = &quot;0.7&quot;
rand = &quot;0.7&quot;
</code></pre>
<p>Com essas mudanças no <code>Cargo.toml</code> podemos começar a usar o <code>prelude</code> da bevy e criar nosso primeiro app com:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::new().run();
}
</code></pre></pre>
<h3 id="instanciando-uma-janela"><a class="header" href="#instanciando-uma-janela">Instanciando uma Janela</a></h3>
<p>Instanciar uma janela com a Bevy é bastante trivial e pode ser feito através do uso de plugins, neste caso o <code>DefaultPlugins</code> contém um conjunto básico de plugins que tornam a bevy operacional:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new().add_plugins(DefaultPlugins).run();
}
</code></pre></pre>
<p>Agora se executarmos <code>cargo run</code> veremos uma janela com fundo cinza. Por padrão, os plugins da Bevy não incluem camera, pois o uso de camera é muito variado em jogos, assim, precisamos criar nosso próprio sistema de cameras. Usaremos uma camera ortográfica 2D com o commando <code>OrthographicCameraBundle::new_2d()</code> em uma função que fará a configuração do sistema de cameras inicial alterando a variável do tipo <code>mut Commands</code>. <code>Commands</code> é um tipo muito comum ao escrever sistemas com a Bevy e é usado para enfileirar comandos com o objetivo de modificar o mundo (que chamaremos de <code>world</code>) e os recursos (que chamaremos de <code>resources</code>). Assim, na função a seguir, <code>setup_camera</code>, receberemos como argumento <code>mut commands: Commands</code> e utilizaremos ele para instanciar (chamado de <code>spawn</code>) uma nova entidade bundle com os componentes de uma câmera 2D ortográfica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
<span class="boring">}
</span></code></pre></pre>
<p>E agora basta adicionar esse função ao nosso <code>App</code> através de um <code>add_startup_system</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_plugins(DefaultPlugins)
        .run();
}

fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
</code></pre></pre>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>A Bevy é pensada de forma que todas suas partes sejam modularizáveis, assim, todas as core features da engine são implementadas como plugins que podem ser substituídos, evoluídos e customizados, além disso, os próprios jogos são encarados como plugins. Assim, se você não precisar de uma UI, basta não registrar o sistema de UI, quer um sistema de UI diferente, registre o seu próprio. Para o caso de servidores, basta não registrar o plugin <code>RenderPlugin</code>.</p>
<p>Caso você não precise de uma experiência tão avançada com a Bevy, é possível utilizar o <code>DefaultPlugins</code> que utilizamos anteriormente, que possui sistemas como Rendering, gerenciamento de assets, sistema de UI, janelas e gerenciamento de entrada de dados.</p>
<h3 id="criando-um-plugin"><a class="header" href="#criando-um-plugin">Criando um Plugin</a></h3>
<p>Para criar um plugin simplesmente precisamos implementar a trait <code>Plugin</code> em um tipo que comporte as informações necessárias. No caso do plugin que vamos implementar é apenas um <code>hello world</code> para plugins, então não precisamos de dados, criando apenas um </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HelloPlugin;

impl Plugin for HelloPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        // lógica do plugin
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora precisamos de uma função que nosso sistema vai executar, neste caso um simples <code>println</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_plugin() {
    println!(&quot;hello plugin!&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p>E adicionamos essa função como um <code>startup_system</code> no nosso plugin:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Plugin for HelloPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.add_startup_system(hello_plugin);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Por último, basta adicionarmos nosso plugin ao <code>App</code> principal e executar <code>cargo run</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_plugin(HelloPlugin)
        .add_plugins(DefaultPlugins)
        .run();
}
</code></pre></pre>
<p>Veremos algo no terminal como:</p>
<pre><code>2022-06-20T05:28:52.725036Z  INFO bevy_render::renderer: AdapterInfo { name: &quot;AMD Radeon Pro 5500M&quot;, vendor: 0, device: 0, device_type: DiscreteGpu, backend: Metal }
hello plugin!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system-ecs"><a class="header" href="#entity-component-system-ecs">Entity Component System (ECS)</a></h1>
<p>O sistema de gerenciamento de dados da Bevy é chamado de <em>Entity Component System</em>, ou <strong>ECS</strong>, e sua principal característica é a simplicidade do gerenciamento de dados. Uma boa analogia ao seu funcionamento é com bancos de dados tabulares, na qual os componentes, <em>components</em>, são os tipos de dados, ou colunas, e as entidades, <em>entities</em>, são as linhas, mais especificamente o ID das linhas. Por exemplo, você poderia ter diversas entidades com o componente <code>Health</code> e cada entidade possui um component <code>Health</code> diferente, já que NPCs, players e objetos do mundo podem ter <code>Health</code>s diferentes (<em>health</em> significa vida em inglês). Assim, o conjunto de componentes que uma entidade possui é chamado de arquétipo, <em>Archetype</em>.</p>
<p>Considerando a entidade player possuindo componentes como vida, força, ataque, defesa, inventario, as entidades inimigos com vida, força, ataque, defesa, inteligência, e a entidade planta com apenas vida, fica muito fácil escrever uma lógica de jogo que gerencia esses tipos de entidades, como verificar se uma entidade com vida encontrou outra entidade com vida, simplificando muito a criação de lógicas de jogo. Essa lógica de gerenciamento é chamado sistema, <em>system</em>. Estes sistemas são executados em paralelo pelo <em>smart scheduling algorithm</em> da Bevy e com isso devemos manter nossas entidades o mais horizontal possível, evitando grandes componentes com muitos campos. Isso influência muito a performance do sistema, pois quando mais vertical a entidade mais problemas de acesso aos dados em paralelo teremos.</p>
<blockquote>
<p>Para você que vem da orientação a objectos, no paradigma de ECS é mais comum possuir uma entidade com diversos componentes, como a entidade Player que possui os componentes Vida(u32), Posição(x, y, z), Direção(x, y, z), Escala(x, y, z), Rotação(x, y, z), Defesa(u16), Ataque(u16), Força(u16) em vez de uma classe <code>Player</code> com os campos vida: u32, posição: [x, y, z], direção: [x, y, z], escala: [x, y, z], rotação: [x, y, z], defesa: u16, ataque: u16, força: u16:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prefira isso:
// Entidade Player;

#[derive(Component)]
pub struct Vida(u32)

#[derive(Component)]
pub struct Posição(x, y, z)

#[derive(Component)]
pub struct Direção(x, y, z)

#[derive(Component)]
pub struct Escala(x, y, z)

#[derive(Component)]
pub struct Rotação(x, y, z)

#[derive(Component)]
pub struct Defesa(u16)

#[derive(Component)]
pub struct Ataque(u16)

#[derive(Component)]
pub struct Força(u16)

// Em vez disso:
pub struct Player {
    pub vida: u32, 
    pub posição: [x, y, z], 
    pub direção: [x, y, z], 
    pub escala: [x, y, z], 
    pub rotação: [x, y, z], 
    pub defesa: u16, 
    pub ataque: u16, 
    pub força: u16,
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="criando-entidades"><a class="header" href="#criando-entidades">Criando entidades</a></h2>
<p>Entidades são simplesmente IDs inteiros associados a um comando <code>spawn</code> de <code>commands</code>, <code>commands.spawn(...)</code> e para adicionar componentes basta utilizarmos a diretica <code>insert</code> em um <code>spawn</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_entity(mut commands: Commands) {
    commands
        .spawn()
        .insert(Label(&quot;Player&quot;))
        .insert(Vida(10))
        .insert(Posição(0, 2, 0))
        .insert(Direção(0, 2, 0))
        .insert(Escala(0, 2, 0))
        .insert(Rotação(0, 2, 0))
        .insert(Defesa(10))
        .insert(Ataque(10))
        .insert(Força(10));
}
<span class="boring">}
</span></code></pre></pre>
<p>Além disso, existe o conceito de <em>bundles</em>. <em>Bundles</em> são como <em>templates</em> que tornam a criação de entidades com diversos componentes mais simples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Bundle)]
struct Transform {
    posição: Posição(x, y, z),
    direção: Direção(x, y, z),
    escala: Escala(x, y, z),
    rotação: Rotação(x, y, z),
}

#[derive(Bundle)]
struct Player {
    vida: u32, 
    defesa: u16, 
    ataque: u16, 
    força: u16,

    #[bundle] // Nested bundles
    transform: Transform
}
<span class="boring">}
</span></code></pre></pre>
<p>Como podemos ver em <code>transform: Transform</code>, bundles também podem ser encadeados. Tuplas arbitrárias também são consideradas bundles. Note, que bundles não podem ser consultados com uma <em>query</em>.</p>
<h2 id="recursos-resources"><a class="header" href="#recursos-resources">Recursos (<em>Resources</em>)</a></h2>
<p>Recursos são um tipo de instância que permite armazenar um tipo de dado de forma global, independente de entidades, e qualquer tipo Rust pode ser usado como um recurso independente de implementação de traits. Existem duas formas de inicializar recursos, a primeira é definindo a trait <code>Default</code> para eles, quando eles possuem um tipo de dado simples, já a segunda é implementando a trait <code>FromWorld</code> que permite atuar sobre o recurso utilizando valores de <code>World</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct StartingLevel(usize);

struct MyFancyResource { /* stuff */ }

impl FromWorld for MyFancyResource {
    fn from_world(world: &amp;mut World) -&gt; Self {
        // You have full access to anything in the ECS from here.
        // For instance, you can mutate other resources:
        let mut x = world.get_resource_mut::&lt;MyOtherResource&gt;().unwrap();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>E para inicializar seus recursos em um App basta usar a função <code>insert_resource</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        // Caso implemente uma das traits `Default` ou `FromWorld`
        .init_resource::&lt;MyFancyResource&gt;()
        // se for necessário definir o valor inicial
        .insert_resource(StartingLevel(3))
        // ...
        .run();
}
</code></pre></pre>
<p>A decisão de quando usar recursos ou entity/component é baseada na forma e no momento em que este dado vai ser acessado, mas considerando algo como um jogo com uma unica entidade, pode ainda ser útil utilizar o padrão ECS, pois ele permite maior flexibildiade e compartilhamento de dados, que podem ser muito úteis para a evolução do jogo.</p>
<h2 id="sistemas-systems"><a class="header" href="#sistemas-systems">Sistemas (<em>Systems</em>)</a></h2>
<p>Sistemas são funções que a desenvolvedora escreve com o objetivo de ser uma unidade de lógica do jogo atuando sobre as entidades e os componentes. Os sistemas são executados e gerenciados pelas Bevy, mas somente podem ser usados com parâmetros especiais. Os parâmetros especiais são:</p>
<ul>
<li><code>Res/ResMut</code> para acessar recursos.</li>
<li><code>Query</code> para acessar componentes de uma entidade.</li>
<li><code>Commands</code> para criar e destruir entidades, componentes e recursos.</li>
<li><code>EventWriter/EventReader</code> para enviar e receber eventos.</li>
</ul>
<p>Um sistema pode conter no máximo 16 parâmetros, caso seja preciso mais parâmetros pode se agrega-los em tuplas de no máximo 16 parâmetros. Caso estes limites não sejam suficiente, é possível fazer tuplas de tuplas.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn complex_system(
    (a, mut b): (Res&lt;ResourceA&gt;, ResMut&lt;ResourceB&gt;),
    mut c: Option&lt;ResMut&lt;ResourceC&gt;&gt;,
) {
    if let Some(mut c) = c {
        // lógica
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>No sistema a cima <code>ResourceA</code> é um recurso imutável e esta compartilhando uma tupla com <code>ResourceB</code>que é um recurso mutável. Já <code>ResourceC</code> é um recurso que pode não existir e por isso está englobado por um tipo <code>Optional&lt;T&gt;</code>.</p>
<p>Existem dois tipos de funções para executar sistemas na Bevy</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    App::new()
        // ...
        // sistemas executados apenas quando o App é lançado
        .add_startup_system(init_menu)
        .add_startup_system(debug_start)

        // sistemas executados todos os frames
        .add_system(move_player)
        .add_system(enemies_ai)
        // ...
        .run();
}
</code></pre></pre>
<p>Agora vamos começar a implementar nosso snake game e aprofundar nossos conhecimentos em bevy.</p>
<p><strong>Referência: <a href="https://bevy-cheatbook.github.io/programming.html">unofficial bevy guide</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-cabeça-da-cobra"><a class="header" href="#a-cabeça-da-cobra">A Cabeça da Cobra</a></h1>
<p>Para começar o jogo precisamos do primeiro componente, neste caso a cabeça da cobra, que definirá os próximos possíveis passos, assim como para onde os blocos seguintes se moverão. Este primeiro componente se chamará <code>SnakeHead</code> e será uma struct vazia com a trait <code>Component</code> associada a ela:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Component)]
pub struct SnakeHead;
<span class="boring">}
</span></code></pre></pre>
<p>A função de <code>SnakeHead</code> é basicamente ser um marcador para as entidades do tipo snake, que nos permitirá filtrar as estas entidades quando formos fazer queries com os players. Muitos componentes não precisam de estados e podem funcionar apenas como marcadores, um padrão bastante comum no mundo ECS, já que optamos por uma estratégia de <em>has a</em> (possui um) em vez de <em>is a</em> (é um, da orientação a objetos). Outro detalhe importante é a adição de uma cor específica para a cabeça da cobra <code>const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);</code>.</p>
<p>Nosso próximo passo é gerar uma entidade snake, que possui um componente do tipo <code>SnakeHead</code>, e essa entidade pode ser gerada adicionando um sistema inicial com <code>add_startup_system(spawn_snake)</code>, dada a função <code>spawn_snake</code>:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
 
const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(spawn_snake)
       .add_plugins(DefaultPlugins)
       .run();
}
 
fn setup_camera(mut commands: Commands) {
   commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
 
#[derive(Component)]
pub struct SnakeHead;
 
fn spawn_snake(mut commands: Commands) {
   commands
       .spawn_bundle(SpriteBundle {
           sprite: Sprite {
               color: SNAKE_HEAD_COLOR,
               ..default()
           },
           transform: Transform {
               scale: Vec3::new(10.0, 10.0, 10.0),
               ..default()
           },
           ..default()
       })
       .insert(SnakeHead);
}
</code></pre></pre>
<blockquote>
<p><strong>SpriteBundle</strong></p>
<p><code>SpriteBundle</code> é um tipo de componente que agrega características comuns a uma entidade que utiliza sprites como o próprio sprite (especificidades da imagem), transform (relação de posição, escala e rotação), visibilidade, transform global e o manuseio de imagens.</p>
</blockquote>
<p>Neste caso, não temos nenhuma imagem específica como sprite, mas definimos um transform com uma escala de <code>10 x 10 x 10</code> pixels e uma cor de filtro acinzentada para a região definida pelo transform, as outras propriedades foram definidas como <code>..default()</code>. Ao executarmos <code>cargo run</code> o resultado é algo como:</p>
<p><img src="part-2/../imagens/snake_pixel.png" alt="Entidade snake com SpriteBundle" /></p>
<h2 id="nosso-primeiro-teste"><a class="header" href="#nosso-primeiro-teste">Nosso primeiro teste</a></h2>
<p>No mundo moderno, jogos sem testes estão fadados ao fracasso. Não estou dizendo que todos os jogos possuem uma bateria maravilhosa de testes automatizados, mas desde que escrevi o livro <strong>Lean Game Development</strong> até hoje, o mercado de games AAA mudou muito. Hoje em dia vejo jogos sendo desenvolvidos com TDD e com QA advogando por testes automatizados de gameplay emt todos os sistemas, garantindo uma jogabilidade equilibrada/desejada em qualquer plataforma. Hoje em dia um jogo, middleware, game server ou ferramenta sem nenhum teste esta fadado ao fracasso por conta do número excessivo de bugs e clientes infelizes. Sendo assim, é importante ter uma noção de como testar minimamente seus sistemas com a Bevy. Sendo assim, vamos aprender a escrever o teste mais simples possível, verificar se nosso sistema <code>spawn_snake</code> de fato adiciona um componente <code>SnakeHead</code> à entidade desejada.</p>
<p>Primeiro passo do teste será mover tudo que é relacionado a <code>snake</code> para um módulo chamado <code>snake.rs</code>:</p>
<p><strong><code>main.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
 
mod snake;
 
use snake::spawn_snake;
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(spawn_snake)
       .add_plugins(DefaultPlugins)
       .run();
}
 
fn setup_camera(mut commands: Commands) {
   commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
</code></pre></pre>
<p><strong><code>snake.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
 
const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
 
#[derive(Component)]
pub struct SnakeHead;
 
pub fn spawn_snake(mut commands: Commands) {
   commands
       .spawn_bundle(SpriteBundle {
           sprite: Sprite {
               color: SNAKE_HEAD_COLOR,
               ..default()
           },
           transform: Transform {
               scale: Vec3::new(10.0, 10.0, 10.0),
               ..default()
           },
           ..default()
       })
       .insert(SnakeHead);
}
<span class="boring">}
</span></code></pre></pre>
<p>Agora em Snake vamos criar um teste dentro de um módulo de testes (<code>#[cfg(test)] mod test {...}</code>) que verifique se um componente <code>SnakeHead</code> está presente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
   use super::*;
 
   #[test]
   fn entity_has_snake_head() {
       // 1 Inicialização do App
       let mut app = App::new();
 
       // 2 Adicionar o `spawn_snake` startup system
       app.add_startup_system(spawn_snake);
 
       // 3 Executar todos os sistemas pelo menos uma vez
       app.update();
 
       // 4 Fazer uma query por entidades que contenham o componente `SnakeHead`
       let mut query = app.world.query_filtered::&lt;Entity, With&lt;SnakeHead&gt;&gt;();
 
       // 5 Verificar se a contagem de componentes da query foi igual a 1
       assert_eq!(query.iter(&amp;app.world).count(), 1);
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Descrevendo o teste <code>entity_has_snake_head</code> (verifica se entidade possui componente snake head) temos como primeiro passo (<code>1</code>) criar um <code>App</code> mutável para podermos adicionar sistemas como o <code>spawn_snake</code> (<code>2</code>) e executarmos todos os sistemas pelo menos uma vez com <code>app.update()</code> (<code>3</code>). O próximo passo é realizarmos uma <code>query</code> (<code>4</code>) no sistema de ECS para procurarmos por uma entidade que possua o componente <code>SnakeHead</code> (<code>With&lt;SnakeHead&gt;</code>). Com o resultado desta <code>query</code> verificamos se a quantidade de entidades que possuem o componente <code>SnakeHead</code> é igual a <code>1</code> (<code>5</code>).</p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>O principal objetivo de queries é nos permitir acessar componentes de entidades. No código a seguir, temos uma query do tipo <code>Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;</code> que representa todas as entidades que possuam <code>Health</code> e <code>Transform</code>, com a propriedade <code>Health</code> sendo apenas leitura e a propriedade <code>Transform</code> sendo mutável. Além disso, caso o componente <code>Player</code> esteja presente, permite a leitura dele. Depois disso iteramos sobre todos os ítens dessa query, de forma mutável, para podermos alterar a propriedade transform, <code>(health, mut transform, player) in query.iter_mut()</code>. Por último, caso o componente <code>Player</code> esteja presente, sabemos que esta entidade é do tipo player e aplicamos uma lógica extra.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_zero_health(
   mut query: Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;,
) {
   // Obtem todas as entidades do tipo
   for (health, mut transform, player) in query.iter_mut() {
       eprintln!(&quot;Entity at {} has {} HP.&quot;, transform.translation, health.hp);
 
       // centraliza se `hp` é menor ou igual a `0.0`
       if health.hp &lt;= 0.0 {
           transform.translation = Vec3::ZERO;
       }
 
       if let Some(player) = player {
           // entidade é do tipo `Player`
           // lógica extra
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>para obter o ID de uma entidade com queries basta adicionar <code>Entity</code> a query e a variável <code>entity_id</code> corresponderá ao id:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// adicione `Entity` a `Query` para obter os IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
   for (entity_id, /* ... */) in q.iter() {
       // `entity_id` é o ID da entidade que estamos acessando.
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Caso exista certeza que uma query vai identificar apenas uma entidade, é possível utilizar <code>single</code> e <code>single_mut</code> para acessar seus componentes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn query_player(mut q: Query&lt;(&amp;Player, &amp;mut Transform)&gt;) {
   let (player, mut transform) = q.single_mut();
   // lógica
}
<span class="boring">}
</span></code></pre></pre>
<p>Outro recurso interessante de queries são os <em>Query Filters</em>, um tipo especial de queries que permite reduzir a quantidade de entidade que uma query retorna. <em>Query filters</em> se utilizam dos filtros <code>With</code> e <code>Without</code> para garantir que a entidade tenha (<code>With</code>) ou não tenha (<code>Without</code>) certos componentes. No exemplo a seguir, a query acessa todas as entidades com o componente <code>Health</code> que sejam  <code>Players</code> amigáveis e que opcionalmente possuam <code>PlayerName</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_player_hp(
   query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
   for (health, name) in query.iter() {
       // ...
   }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Utilizando filtros</strong></p>
<ul>
<li>Elementos adicionados em uma Tupla, como <code>(With&lt;Player&gt;, Without&lt;Enemy&gt;)</code>, são considerados <code>AND</code>/<code>E</code> lógicos.</li>
<li>Para utilizar <code>OR</code>/<code>OU</code> lógicos é preciso envolver as tuplas em um filtro do tipo <code>Or&lt;(…)&gt;</code>.</li>
</ul>
</blockquote>
<h2 id="movendo-a-cabeça-da-cobra"><a class="header" href="#movendo-a-cabeça-da-cobra">Movendo a cabeça da cobra</a></h2>
<p>Não existe o Snake game sem movimento, então o próximo passo é controlarmos os movimentos da cabeça da cobra com as teclas <code>WASD</code> ou direcionais. Para isso, podemos começar com a movimentação para cima utilizando o teste:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn snake_head_has_moved_up() {
   // Setup
   let mut app = App::new();
   let default_transform = Transform {..default()};
 
   // Adicionando sistemas
   app.add_startup_system(spawn_snake)
   .add_system(snake_movement);
 
   // Adicionando inputs de `KeyCode`s
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::W);
   app.insert_resource(input);
 
   // Executando sistemas pelo menos uma vez
   app.update();
 
   // Query para obter entidades com `SnakeHead` e `Transform`
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
 
   // Verificando se o valor de Y no `Transform` mudou
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert!(default_transform.translation.y &lt; transform.translation.y);
       assert_eq!(default_transform.translation.x, transform.translation.x);
   })
}
<span class="boring">}
</span></code></pre></pre>
<p>Neste teste adicionamos um <code>Transform</code> com valores padrão de <code>translation</code> para comparar quando o transform da query mudar, adicionamos um novo sistema de movimento <code>add_system(snake_movement)</code> e criamos um recurso que gerencia inputs de teclado <code>Input::&lt;KeyCode&gt;::default()</code>, na qual setamos seu evento <code>press</code> como <code>KeyCode::W</code>. Para resolver este teste precisamos criar o sistema <code>snake_movement</code>, que é bastante trivial neste caso, apenas um sistema que busca por um query contendo <code>&amp;SnakeHead</code> e <code>&amp;Transform</code>, depois modifica o valor de Y de forma que sempre aumente:</p>
<pre><pre class="playground"><code class="language-rust">// snake.rs
pub fn snake_movement(mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;) {
   for (_head, mut transform) in head_positions.iter_mut() {
       transform.translation.y += 1.;
   }
}
 
// main.rs
// ...
mod snake;
use snake::{spawn_snake, snake_movement};
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(spawn_snake)
       .add_plugins(DefaultPlugins)
       .add_system(snake_movement)
       .run();
}
// ...
</code></pre></pre>
<h3 id="controlando-a-direção-de-movimento"><a class="header" href="#controlando-a-direção-de-movimento">Controlando a direção de movimento</a></h3>
<p>Nosso movimento atual está longe de ser realista ou funcional, para isso precisamos que a cobra se movimente com base nas teclas <code>wasd</code> e podemos começar com um teste que move a cobra 1 unidade para cima, verificando que apenas o <code>y</code> mudou em relacao ao original, depois uma unidade para direita, verificando que apenas o <code>x</code> mudou em relação ao anterior. Por último, um novo teste movendo para baixo e para esquerda, verificando se as posições são inferiores às originais em <code>x</code> e <code>y</code>. Assim, o primeiro teste fica:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn snake_head_moves_up_and_right() {
   // Setup
   let mut app = App::new();
   let default_transform = Transform {..default()};
 
   // Adiciona systemas
   app.add_startup_system(spawn_snake)
   .add_system(snake_movement);
 
   // Testa movimento para cima
   let mut up_transform = Transform {..default()};
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::W);
   app.insert_resource(input);
   app.update();
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert!(default_transform.translation.y &lt; transform.translation.y);
       assert_eq!(default_transform.translation.x, transform.translation.x);
       up_transform = transform.to_owned();
   });
 
   // Testa movimento para direita
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::D);
   app.insert_resource(input);
   app.update();
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert_eq!(up_transform.translation.y , transform.translation.y);
       assert!(up_transform.translation.x &lt; transform.translation.x);
   })
}
<span class="boring">}
</span></code></pre></pre>
<p>Ao executarmos este teste percebemos que a linha <code>assert_eq!(up_transform.translation.y , transform.translation.y);</code> falha pois nosso <code>transform.translation.y</code> está maior que o anterior, que faz sentido, já que nosso sistema de movimento está apenas aumentando o <code>y</code> a cada update. Para resolvermos isso, podemos adicionar os comandos para se mover com <code>w</code> e com <code>d</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// snake.rs
pub fn snake_movement(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;
) {
   for (_head, mut transform) in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Teste passando, então podemos fazer o segundo teste, movimento para baixo e para esquerda. O teste é basicamente igual ao anterior, mas reduzimos algumas linhas:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn snake_head_moves_down_and_left() {
   // Setup
   let mut app = App::new();
   let default_transform = Transform {..default()};
 
   app.add_startup_system(spawn_snake)
   .add_system(snake_movement);
 
   // Movimenta para baixo
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::S);
   app.insert_resource(input);
   app.update();
 
 
   // Movimenta para esquerda
   let mut input = Input::&lt;KeyCode&gt;::default();
   input.press(KeyCode::A);
   app.insert_resource(input);
   app.update();
 
   // Assert
   let mut query = app.world.query::&lt;(&amp;SnakeHead, &amp;Transform)&gt;();
   query.iter(&amp;app.world).for_each(|(_head, transform)| {
       assert!(default_transform.translation.y &gt; transform.translation.y);
       assert!(default_transform.translation.x &gt; transform.translation.x);
   })
}
<span class="boring">}
</span></code></pre></pre>
<p>Como esperado, o teste falha e podemos implementar as condições que faltam de pressionar o teclado, <code>s</code> e <code>a</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn snake_movement(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;(&amp;SnakeHead, &amp;mut Transform)&gt;
) {
   for (_head, mut transform) in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
       if keyboard_input.pressed(KeyCode::A) {
           transform.translation.x -= 1.;
       }
       if keyboard_input.pressed(KeyCode::S) {
           transform.translation.y -= 1.;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Tudo passa e podemos ir para o próximo passo, explicar e melhorar este código. O argumento <code>keyboard_input</code> é um recurso que contém os eventos relacionados a tecla que foi pressionada no <code>input</code>, ou seja, <code>Res&lt;Input&lt;KeyCode&gt;&gt;,</code>. Nossa query faz sentido e está funcional, porém, como não estamos utilizando o componente <code>SnakeHead</code>, representado por <code>_head</code>, podemos mudar nossa query para <code>Query&lt;&amp;mut Transform, With&lt;SnakeHead&gt;&gt;</code>, que altera nosso código para utilizar apenas o transform como variável:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn snake_movement(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;&amp;mut Transform, With&lt;SnakeHead&gt;&gt;
) {
   for mut transform in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
       if keyboard_input.pressed(KeyCode::A) {
           transform.translation.x -= 1.;
       }
       if keyboard_input.pressed(KeyCode::S) {
           transform.translation.y -= 1.;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Como mencionamos antes sobre o <code>With</code>, ele nos permite buscar todas as entidades que possuam o componente <code>SnakeHead</code>, mas explícita para a Bevy que não nos importamos com o conteúdo de <code>SnakeHead</code>, apenas com o <code>Transform</code>. Isso é importante pois quanto menos componentes o sistema precisar acessar, mais a bevy conseguirá paralelizar as coisas.</p>
<h2 id="ci"><a class="header" href="#ci">CI</a></h2>
<p>Uma coisa bastante importante enquanto desenvolvemos é termos um sistema de integração contínua executando. No caso do Rust no Github eu recomendo utilizar o <em>Github Actions</em> e minha configuração base para projetos Rust é:</p>
<pre><code class="language-yaml">name: Rust
 
on:
 push:
   branches: [ &quot;main&quot; ]
 pull_request:
   branches: [ &quot;*&quot; ]
 
env:
 CARGO_TERM_COLOR: always
 
jobs:
 build:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v3
   - name: Install alsa and udev
     run: sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev
   - name: Build
     run: cargo build --release --verbose
    
 test:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v2
   - name: Install alsa and udev
     run: sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev
   - name: tests
     run: cargo test -- --nocapture
  fmt:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v2
   - name: FMT
     run: cargo fmt -- --check
 
 clippy:
   runs-on: ubuntu-latest
 
   steps:
   - uses: actions/checkout@v2
   - name: Install alsa and udev
     run: sudo apt-get update; sudo apt-get install --no-install-recommends libasound2-dev libudev-dev libwayland-dev libxkbcommon-dev
   - name: install-clippy
     run: rustup component add clippy
   - name: clippy
     run: cargo clippy -- -W clippy::pedantic --deny &quot;warnings&quot;
 
</code></pre>
<p>Ao executarmos o CI, percebemos que a formatação não estava correta, que pode ser corrigida com <code>cargo fmt</code>, e há algumas sugestões de linting em relação a nomenclatura das funções e structs no módulo e declaração de argumentos. A questão de nomenclatura solicita que funções e structs não comecem com o nome do módulo. A declaração de argumentos solicita que o tipo de <code>keyboard_input</code> seja passado como referência <code>keyboard_input: &amp;Res&lt;Input&lt;KeyCode&gt;&gt;</code>, porém isso quebra a injeção de recursos da bevy, necessitando assim que o lint seja descartado com <code>#[allow(clippy::needless_pass_by_value)]</code>. Meu único problema com a questão de nomenclatura é perder o contexto de que os sistemas e as structs quando utilizamos importações absolutas em vez de qualificadas. A solução é utilizar importações qualificadas. O código ficou assim:</p>
<pre><pre class="playground"><code class="language-rust">// Snake.rs
use bevy::prelude::*;
 
const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
 
#[derive(Component)]
pub struct Head;
 
pub fn spawn_system(mut commands: Commands) {
   commands
       .spawn_bundle(SpriteBundle {
           sprite: Sprite {
               color: SNAKE_HEAD_COLOR,
               ..default()
           },
           transform: Transform {
               scale: Vec3::new(10.0, 10.0, 10.0),
               ..default()
           },
           ..default()
       })
       .insert(Head);
}
 
#[allow(clippy::needless_pass_by_value)]
pub fn movement_system(
   keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
   mut head_positions: Query&lt;&amp;mut Transform, With&lt;Head&gt;&gt;,
) {
   for mut transform in head_positions.iter_mut() {
       if keyboard_input.pressed(KeyCode::D) {
           transform.translation.x += 1.;
       }
       if keyboard_input.pressed(KeyCode::W) {
           transform.translation.y += 1.;
       }
       if keyboard_input.pressed(KeyCode::A) {
           transform.translation.x -= 1.;
       }
       if keyboard_input.pressed(KeyCode::S) {
           transform.translation.y -= 1.;
       }
   }
}
 
#[cfg(test)]
mod test {
   use super::*;
 
   #[test]
   fn entity_has_snake_head() {
       // Setup app
       let mut app = App::new();
 
       // Add startup system
       app.add_startup_system(spawn_system);
 
       // Run systems
       app.update();
 
       let mut query = app.world.query_filtered::&lt;Entity, With&lt;Head&gt;&gt;();
       assert_eq!(query.iter(&amp;app.world).count(), 1);
   }
 
   #[test]
   fn snake_head_has_moved_up() {
       // Setup
       let mut app = App::new();
       let default_transform = Transform { ..default() };
 
       // Add systems
       app.add_startup_system(spawn_system)
           .add_system(movement_system);
 
       // Add input resource
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::W);
       app.insert_resource(input);
 
       // Run systems
       app.update();
 
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert!(default_transform.translation.y &lt; transform.translation.y);
           assert_eq!(default_transform.translation.x, transform.translation.x);
       })
   }
 
   #[test]
   fn snake_head_moves_up_and_right() {
       // Setup
       let mut app = App::new();
       let default_transform = Transform { ..default() };
 
       // Add systems
       app.add_startup_system(spawn_system)
           .add_system(movement_system);
 
       // Move Up
       let mut up_transform = Transform { ..default() };
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::W);
       app.insert_resource(input);
       app.update();
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert!(default_transform.translation.y &lt; transform.translation.y);
           assert_eq!(default_transform.translation.x, transform.translation.x);
           up_transform = transform.to_owned();
       });
 
       // Move Right
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::D);
       app.insert_resource(input);
       app.update();
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert_eq!(up_transform.translation.y, transform.translation.y);
           assert!(up_transform.translation.x &lt; transform.translation.x);
       })
   }
 
   #[test]
   fn snake_head_moves_down_and_left() {
       // Setup
       let mut app = App::new();
       let default_transform = Transform { ..default() };
 
       // Add systems
       app.add_startup_system(spawn_system)
           .add_system(movement_system);
 
       // Move down
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::S);
       app.insert_resource(input);
       app.update();
 
       // Move Left
       let mut input = Input::&lt;KeyCode&gt;::default();
       input.press(KeyCode::A);
       app.insert_resource(input);
       app.update();
 
       // Assert
       let mut query = app.world.query::&lt;(&amp;Head, &amp;Transform)&gt;();
       query.iter(&amp;app.world).for_each(|(_head, transform)| {
           assert!(default_transform.translation.y &gt; transform.translation.y);
           assert!(default_transform.translation.x &gt; transform.translation.x);
       })
   }
}
 
// Main.rs
use bevy::prelude::*;
 
mod snake;
 
fn main() {
   App::new()
       .add_startup_system(setup_camera)
       .add_startup_system(snake::spawn_system)
       .add_plugins(DefaultPlugins)
       .add_system(snake::movement_system)
       .run();
}
 
fn setup_camera(mut commands: Commands) {
   commands.spawn_bundle(OrthographicCameraBundle::new_2d());
}
 
</code></pre></pre>
<p>A seguir vamos criar o conceito de Grid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grade-de-movimento"><a class="header" href="#grade-de-movimento">Grade de Movimento</a></h1>
<p>Nosso sistema de movimentação tem utilizado coordenadas da janela para fazer a movimentação, sendo o ponto <code>(0,0)</code> o centro da janela e cada unidade corresponde a um pixel, porém o snake game utiliza um sistema de grade. Assim, precisamos definir uma grade básica com tamanho da grade de <code>10 x 10</code> e células da grade com mais de 1 pixel para evitar janelas de 10 px por 10 px. Além disso, definir uma grade a aprtir do centro é bastante complexo, por isso vamos utilizar nosso próprio sistema de coordenadas e criar um sistema que faça a conversão. Nosso primeiro passo é adicionar constantes referentes ao tamnho da arena. É importante que estas constantes sejam definidas fora, pois quando iniciarmos o modo multiplayer <code>10 x 10</code> será muito pequena. </p>
<pre><code class="language-rs">// main.rs
mod snake;

const GRID_WIDTH: u32 = 10;
const GRID_HEIGHT: u32 = 10;

fn main() {
    // ...
}
</code></pre>
<p>As constantes <code>GRID_WIDTH</code> e <code>GRID_HEIGHT</code> referemm a largura da arena e a altura da arena, respectivamente. Agora criamos um novo módulo <code>components</code> que é responsável por gerenciar componentes básicos e transversair do jogo, como posição (<code>Position</code>) e tamanho de célula (<code>Size</code>):</p>
<pre><code class="language-rs">// main.rs
mod snake;
pub mod components;

const GRID_WIDTH: u32 = 10;
const GRID_HEIGHT: u32 = 10;
// ...

// components.rs
use bevy::prelude::Component;

#[derive(Component, Clone, Debug, PartialEq, Eq)]
pub struct Position {
    pub x: i32,
    pub y: i32,
}

#[derive(Component, Debug, PartialEq)]
pub struct Size {
    pub width: f32,
    pub height: f32,
}

impl Size {
    pub fn square(x: f32) -&gt; Self {
        Self {
            width: x,
            height: x,
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn sized_square_is_created_calling_square_fn() {
        let expected = Size {width: 3.14, height: 3.14};
        let actual = Size::square(3.14);

        assert_eq!(actual, expected);
    }
}
</code></pre>
<p>No arquivo de components precisamos apenas importar a trait <code>Component</code> e definir as structs <code>Position</code> com <code>x, y</code> e <code>Size</code> com <code>width,height</code>. O único teste presente é o <code>sized_square_is_created_calling_square_fn</code> pois ele testa se um quadrado de lado <code>f</code> é criado quando chamamos a função <code>Size::square</code>. Ou seja, <code>Size::square</code> é um método para ajudar a gerar células, ou qualquer outra coisa que tenha tamanho, de altura e largura iguais. Outra coisa importante de salientar são as várias traits derivadas em <code>Position</code>, no futuro elas devem nos ajudar a utilizar <code>Position</code>. Próximo passo é incorporar estes componentes na cobra que temos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::components::{Position, Size};

const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);

#[derive(Component)]
pub struct Head;

pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: SNAKE_HEAD_COLOR,
                ..default()
            },
            transform: Transform {
                scale: Vec3::new(10.0, 10.0, 10.0),
                ..default()
            },
            ..default()
        })
        .insert(Head) // Remover ;
        .insert(Position { x: 5, y: 5 }) // &lt;-
        .insert(Size::square(0.8));  // &lt;-
}
<span class="boring">}
</span></code></pre></pre>
<p>Se executarmos os testes agora, vamos ver que não há nenhuma alteração significativa, pois todos os testes seguem passando. Agora precisamos de uma função auxiliar para gerenciar a escala de cáda célula da cobra e da grade, assim como uma função que faça a correspondência entre posição na grade e posição na janela. Vamos começar com a mais fácil, escala, que chamaremos de <code>size_scaling</code>. Antes, criamos um módulo chamado <code>grid</code> e movemos <code>GRID_WIDTH</code>e <code>GRID_HEIGHT</code> para este módulo:</p>
<pre><code class="language-rs">// grid.rs
use bevy::prelude::*;
use crate::components::Size;

const GRID_WIDTH: u32 = 10;
const GRID_HEIGHT: u32 = 10;

pub fn size_scaling(windows: Res&lt;Windows&gt;, mut q: Query&lt;(&amp;Size, &amp;mut Transform)&gt;) {
    let window = windows.get_primary().unwrap();
    for (sprite_size, mut transform) in q.iter_mut() {
        scale_sprite(transform.as_mut(), sprite_size, window);
    }
}

fn scale_sprite(transform: &amp;mut Transform, sprite_size: &amp;Size, window: &amp;Window) {
    transform.scale = Vec3::new(
        sprite_size.width / GRID_WIDTH as f32 * window.width() as f32,
        sprite_size.height / GRID_HEIGHT as f32 * window.height() as f32,
        1.0,
    );
}

#[cfg(test)]
mod test {
    use bevy::window::WindowId;
    use raw_window_handle::{RawWindowHandle, WebHandle};
    use crate::{components::Size};

    use super::*;

    #[test]
    fn transform_has_correct_scale_for_window() {
        // Setup
        let expected_transform = Transform { scale: Vec3::new(20., 20., 1.,),..default() };
        let mut default_transform = Transform { scale: Vec3::new(2., 3., 4.,),..default() };
        let sprite_size = Size::square(1.);

        // Create window
        let mut descriptor = WindowDescriptor::default();
        descriptor.height = 200.;
        descriptor.width = 200.;
        let raw_window_handle = RawWindowHandle::Web(WebHandle::empty());
        let window = Window::new(WindowId::new(), &amp;descriptor, 200, 200, 1., None, raw_window_handle);

        // Apply scale
        scale_sprite(&amp;mut default_transform, &amp;sprite_size, &amp;window);

        assert_eq!(default_transform, expected_transform);
    }
}
</code></pre>
<p>Infelizmente, o recurso <code>Windows</code> é bastante complicado de testar pois causa muitos problemas com o sistema de sincronização e agendamento do ECS da Bevy, por isto, neste caso não vamos testar o sistema em si, mas sim a lógica que o sistema chama, a função <code>scale_sprite</code>. A lógica de <code>size_scaling</code> é a seguinte: Se algo possui uma <code>Size.width</code> e uma <code>Size.height</code>, neste caso <code>sprite_size.width</code> e <code>sprite_size.height</code>, igual a 1.0, em uma grade de tamanho 40, em uma janela de tamanho 400 px, então a largura deveria ser 10, pois <code>1.0 / 40. * 400. = 10</code>. Ou seja, para este teste, os valores iniciais de <code>default_transform</code> não importam, apenas os valores préconfigurados de <code>Size</code>, <code>Window</code>, <code>GRID_WIDTH</code>e <code>GRID_HEIGHT</code>.</p>
<p>Note que no teste estamos utilizando a biblioteca <code>raw_window_handle</code>, na versão <code>0.4.3</code>, para gerar as informações de window e que criamos uma janela de <code>200 x 200</code>.</p>
<p>A próxima função é a responsável por transformar a posição em uma coordenada de janela, então, de novo, não poderemos testar o sistema em si, apenas os blocos lógicos que serão divididos em 2:</p>
<ol>
<li>Função <code>convert</code> responsável por calcular o fator de conversão de posição para window.</li>
<li>Aplicar a conversão ao <code>Transform.translation</code>, posição na janela.</li>
</ol>
<p>Vamos criar 2 testes para <code>convert</code>:</p>
<pre><code class="language-rs">#[test]
fn convert_position_x_for_grid_width() {
    let x = convert(4., 400., GRID_WIDTH as f32);

    assert_eq!(x, -20.)
}

#[test]
fn convert_position_y_for_grid_height() {
    let y = convert(5., 400., GRID_HEIGHT as f32);

    assert_eq!(y, 20.)
}
</code></pre>
<p>Estes testes tem como principal objetivo, impedir mudanças que quebrem o código, assim, sua implementação é apenas:</p>
<pre><code class="language-rs">fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    pos / grid_side_lenght * bound_window - (bound_window / 2.) + (tile_size / 2.)
}
</code></pre>
<p>Calculamos o <code>tilesize</code> como o tamanho da janela dividido pela quantidade de elementos da grade. Depois a posição passa a ser em relação à grade, algo como <code>5/ 10 = 0.5</code> multilicado pelo tamanho da window, porém como a bevy o ponto <code>(0,0)</code> é no centro da janela, precisamos deslocal meia janela (<code>- (bound_window / 2.)</code>) e centralizar o tile com <code>+ (tile_size / 2.)</code>. </p>
<p>Próximo passo é criar a função que executa a translação do valor do componente <code>Position</code> para o correspondente da posição na janela no componente <code>Transform</code>, como é uma função muito simples, vamos adicionar apenas um teste básico:</p>
<pre><code class="language-rs">fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(pos.x as f32, window.width() as f32, GRID_WIDTH as f32),
        convert(pos.y as f32, window.height() as f32, GRID_HEIGHT as f32),
        0.0,
    );
}

// mod test:
#[test]
fn translate_position_to_window() {
    let position = Position {x: 2, y: 8};
    let mut default_transform= Transform::default();
    let expected = Transform { translation: Vec3::new(-100., 140., 0.,),..default() };

    // Create window
    let mut descriptor = WindowDescriptor::default();
    descriptor.height = 400.;
    descriptor.width = 400.;
    let raw_window_handle = RawWindowHandle::Web(WebHandle::empty());
    let window = Window::new(WindowId::new(), &amp;descriptor, 400, 400, 1., None, raw_window_handle);
    
    // Apply translation
    translate_position(&amp;mut default_transform, &amp;position, &amp;window);

    assert_eq!(default_transform, expected);
}
</code></pre>
<p>Agora agregando tudo na função <code>position_translation</code> temos:</p>
<pre><code class="language-rs">pub fn position_translation(windows: Res&lt;Windows&gt;, mut q: Query&lt;(&amp;Position, &amp;mut Transform)&gt;) {
    let window = windows.get_primary().unwrap();
    for (pos, mut transform) in q.iter_mut() {
        translate_position(transform.as_mut(), pos, window);
    }
}

fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    pos / grid_side_lenght * bound_window - (bound_window / 2.) + (tile_size / 2.)
}

fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(pos.x as f32, window.width() as f32, GRID_WIDTH as f32),
        convert(pos.y as f32, window.height() as f32, GRID_HEIGHT as f32),
        0.0,
    );
}
</code></pre>
<p>Próximo passo é adicionar os sistemas que criamos à função main utilizando o <code>App::Builder</code>. Este sistema é um caso especial, pois deve ser executado após o método update já que qualquer componente que seja adicionado no update corrente será visivel somente no próximo estágio (por exemplo <code>PostUpdate</code> e <code>Draw</code>) e as funções  <code>position_translation</code> e <code>size_scaling</code> somente conseguiram ver nodos novos da cobra ou comidas nova no estágio seguinte. Esta configuração especial é representada utilizando o <code>CoreStage::PostUpdate</code>  na função de adicionar sistemas  <code>add_system_set_to_stage</code>:</p>
<pre><code class="language-rs">// main
pub mod grid;

fn main() {
    App::new()
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_system(snake::movement_system)
        .add_system_set_to_stage(
            CoreStage::PostUpdate,
            SystemSet::new()
                .with_system(grid::position_translation)
                .with_system(grid::size_scaling),
        )
        .run();
}
</code></pre>
<p><img src="part-2/../imagens/simpleblock.png" alt="Resultado do código até agora" /></p>
<h2 id="corrigindo-a-movimentação-na-grade"><a class="header" href="#corrigindo-a-movimentação-na-grade">Corrigindo a Movimentação na Grade</a></h2>
<p>Até agora nosso sistema de movimento, <code>snake::movement_system</code>, era baseado em movimentar o componente <code>Transform</code> pela janela, porém com a implementação de grade precisamos atualizar o sistema para utilizar o componente <code>Position</code>. Primeiro passo será atualizar os testes para utilizar <code>Position</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// snake.rs
#[cfg(test)]
mod test {
    // ...

    #[test]
    fn snake_head_has_moved_up() {
        // Setup
        let mut app = App::new();
        let default_position = Position{x: 3, y: 4}; // &lt;--

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system);

        // Add input resource
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);

        // Run systems
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(&amp;default_position, position);  // &lt;--
        })
    }

    #[test]
    fn snake_head_moves_up_and_right() {
        // Setup
        let mut app = App::new();
        let up_position = Position{x: 3, y: 4};  // &lt;--

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system);

        // Move Up
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(position, &amp;up_position);  // &lt;--
        });

        let up_right_position = Position{x: 4, y: 4};  // &lt;--

        // Move Right
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::D);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(&amp;up_right_position, position);  // &lt;--
        })
    }

    #[test]
    fn snake_head_moves_down_and_left() {
        // Setup
        let mut app = App::new();
        let down_left_position = Position{x: 2, y: 2};  // &lt;--

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system);

        // Move down
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::S);
        app.insert_resource(input);
        app.update();
        
        // Move Left
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::A);
        app.insert_resource(input);
        app.update();

        // Assert
        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();  // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| {  // &lt;--
            assert_eq!(&amp;down_left_position, position);  // &lt;--
        })
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>Como agora estamos lidando com valores inteiros, nossos testes podem verificar se a posição mudou com <code>assert_eq!</code> em vez de utilizar expressões lógicas com <code>assert!</code>. Além disso, Position inicial com o valor <code>Position { x: 3, y: 3 }</code>, por isso os valores são maiores que <code>0</code>. Ao executarmos os testes veremos que todas as positions estão iguais a ``Position { x: 3, y: 3 }`, corrigimos isso modificando a função de input:</p>
<pre><code class="language-rs">// snake.rs
#[allow(clippy::needless_pass_by_value)]
pub fn movement_system(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut head_positions: Query&lt;&amp;mut Position, With&lt;Head&gt;&gt;,
) {
    for mut position in head_positions.iter_mut() {
        if keyboard_input.pressed(KeyCode::D) {
            position.x += 1;
        }
        if keyboard_input.pressed(KeyCode::W) {
            position.y += 1;
        }
        if keyboard_input.pressed(KeyCode::A) {
            position.x -= 1;
        }
        if keyboard_input.pressed(KeyCode::S) {
            position.y -= 1;
        }
    }
}
</code></pre>
<p>Agora sim, movimentamos o bloco célula a célula, infelizmente muito sensivel.</p>
<h2 id="configurando-a-janela"><a class="header" href="#configurando-a-janela">Configurando a Janela</a></h2>
<p>Próximo passo é fazermos com que a janela seja mais coerente com o snake game, já que por padrão a janela do snake game é quadrada enquanto a janela padrão da bevy é retangular. Para fazer isso, precisamos adicionar um recurso chamado <code>WindowDescriptor</code> que nos permite configurar o tamanha da tela e o título da janela:</p>
<pre><code class="language-rs">// mains.rs

fn main() {
    App::new()
        .insert_resource(WindowDescriptor {
            title: &quot;Snake Game&quot;.to_string(),
            width: 500.0,
            height: 500.0,
            ..default()         
        }) // &lt;--
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_system(snake::movement_system)
        .add_system_set_to_stage(
            CoreStage::PostUpdate,
            SystemSet::new()
                .with_system(grid::position_translation)
                .with_system(grid::size_scaling),
        )
        .run();
}
</code></pre>
<p>Outra mudança que pode ser interessante fazer é mudar o fundo da tela para ficar um pouco mais escuro, podemos fazer isso adicionando o recurso <code>.insert_resource(ClearColor(Color::rgb(0.04, 0.04, 0.04)))</code> depois do <code>WindowDescriptor</code>. Próximo passo é fazermos a comida aparecer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gerador-de-comidas"><a class="header" href="#gerador-de-comidas">Gerador de Comidas</a></h1>
<p>Nosso próximo passo é começarmos um sistema que gere comidas de forma aleatória pela grade. O primeiro passo é definir qual sera a cor da comida. Como pretendemos fazer um jogo multiplayer, não faz sentido termos comidas coloridas, já que estas serão dos jogadores, sendo assim podemos criar um módulo chamado <code>food</code> e adicionar a constante <code>const FOOD_COLOR: Color = Color::rgb(1.0, 1.0, 1.0)</code>. Próximo passo é criamos um componente chamado <code>Food</code> para representar a comida:</p>
<pre><code class="language-rs">// food.rs
#[derive(Component)]
pub struct Food;
</code></pre>
<p>Próximo passo é criarmos um sistema que gera uma comida em um local aleatório da grade. Como este sistema utiliza aleatoriedade, podemos utilizar uma biblioteca de <code>property testing</code> semelhante a <em>proptest</em> do python, a <em>propcheck</em> do Elixir e a <em>quickcheck</em> do Haskell, chamada <code>proptest</code> para gerar centenas de cenários de teste. Para isso, adicionamos <code>proptest = &quot;1.0.0&quot;</code> como uma <code>dev-dependencies</code> no Cargo.toml e para utilizarmos basta utilizar a macro <code>proptest!</code> e determinar os valores a serem executados (ou quantidade de cenários) como argumento da função de teste como em <code>_execution in 0u32..1000</code>:</p>
<pre><code class="language-rs">#[cfg(test)]
mod test {
    use crate::components::Position;

    use super::*;
    use proptest::prelude::*;

    proptest!{
        #[test]
        fn spawns_food_inplace(_execution in 0u32..1000) {
            // Setup app
            let mut app = App::new();

            // Add startup system
            app.add_startup_system(spawn_system);

            // Run systems
            app.update();

            let mut query = app.world.query_filtered::&lt;&amp;Position, With&lt;Food&gt;&gt;();
            assert_eq!(query.iter(&amp;app.world).count(), 1);
            query.iter(&amp;app.world).for_each(|position| {
                let x = position.x;
                let y = position.y;

                assert!(x &gt;= 0 &amp;&amp; x as i32 &lt;= (GRID_WIDTH -1) as i32);
                assert!(y &gt;= 0 &amp;&amp; y as i32 &lt;= (GRID_HEIGHT -1) as i32);
            })
        }
    }
}
</code></pre>
<p>A vantagem de um proptest é que ele permite executar diversos cenários e podemos definir regras de limite para falha, executando centenas de cenários em poucos segundos. Para este teste passar, precisamos implementar a função <code>spawn_system</code> para o módulo <code>food</code>:</p>
<pre><code class="language-rs">// food.rs
pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: FOOD_COLOR,
                ..default()
            },
            ..default()
        })
        .insert(Food)
        .insert(Position {
            x: (random::&lt;u16&gt;() % GRID_WIDTH) as i16,
            y: (random::&lt;u16&gt;() % GRID_HEIGHT) as i16,
        })
        .insert(Size::square(0.8));
}
</code></pre>
<p>O próximo passo é adicionar o sistema a <code>App</code> na função <code>main</code>, porém este sistema tem uma pegadinha. Como não queremos que o sistema gere uma nova comdia para cada frame, precisamos definir um tempo de intervalo para as comidas serem geradas. Como este cenário de executar uma função somente a cada x segundos é muito comum no desenvolvimento de jogos a Bevy nos disponibiliza a struct <code>FixedTimestep</code> que nos permite definir um passo (<code>step</code>) em segundos, que será usada com a função <code>with_run_criteria</code>:</p>
<pre><code class="language-rs">// main.rs
pub mod food;

fn main() {
    App::new()
        .insert_resource(WindowDescriptor {
            title: &quot;Snake Game&quot;.to_string(),
            width: 500.0,
            height: 500.0,
            ..default()
        }) // &lt;--
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_system(snake::movement_system)
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(FixedTimestep::step(1.0)) // &lt;-- Pegadinha
                .with_system(food::spawn_system), // &lt;-- Sistema
        ) // &lt;--
        .add_system_set_to_stage(
            CoreStage::PostUpdate,
            SystemSet::new()
                .with_system(grid::position_translation)
                .with_system(grid::size_scaling),
        )
        .run();
}
</code></pre>
<p>Próximo passo será melhorar o movimento da cabeça da cobra, tornando ele mais lento e cadenciado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="melhorando-a-cadência-do-movimento"><a class="header" href="#melhorando-a-cadência-do-movimento">Melhorando a Cadência do Movimento</a></h1>
<p>O atual movimento da cobra está ligado aos comandos do teclado diferentemente do snale game que a cobra se movimenta independente dos comandos do teclado e a cada x segundos, em vez de a cada frame. Para podermos fazer com que a cobra se movimente independente dos comandos do teclado, precisamos de uma forma de armazenar a direção que ela está se movimentando, além de evitar que a cobra vá para a direção oposta. Assim, precisamos criar o enum que armazena a direção e criar uma função que indica a direção oposta.</p>
<pre><code class="language-rs">// components.rs
#[test]
fn opposite_direction() {
    assert_eq!(Direction::Up.opposite(), Direction::Down);
    assert_eq!(Direction::Down.opposite(), Direction::Up);
    assert_eq!(Direction::Right.opposite(), Direction::Left);
    assert_eq!(Direction::Left.opposite(), Direction::Right);
}

// ...
#[derive(PartialEq, Debug, Copy, Clone)]
pub enum Direction {
    Left,
    Up,
    Right,
    Down,
}

impl Direction {
    pub fn opposite(self) -&gt; Self {
        match self {
            Self::Left =&gt; Self::Right,
            Self::Right =&gt; Self::Left,
            Self::Up =&gt; Self::Down,
            Self::Down =&gt; Self::Up,
        }
    }
}
</code></pre>
<p>Em uma etapa inicial do desenvolvimento, eu adicionaria Direction como um componente na entidade cobra, porém, a medida que a cobra ficar maior, vai ser difícil sincronizar a direção de cada elemento. Sabendo disso, vamos fazer um pouco de overengineering, e colocar <code>Direction</code> como elemento do componente <code>snake::Head</code>. Além disso, definimos a direção padrão como <code>Direction::Up</code> utilizando a trait <code>Default</code>:</p>
<pre><code class="language-rs">// snake.rs

#[derive(Component)]
pub struct Head {
    direction: Direction
}

impl Default for Head {
    fn default() -&gt; Self {
        Self { direction: Direction::Up }
    }
}

pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: SNAKE_HEAD_COLOR,
                ..default()
            },
            transform: Transform {
                scale: Vec3::new(10.0, 10.0, 10.0),
                ..default()
            },
            ..default()
        })
        .insert(Head::default() ) // &lt;--
        .insert(Position { x: 3, y: 3 })
        .insert(Size::square(0.8));
}
</code></pre>
<h2 id="separando-o-movimento-em-duas-etapas"><a class="header" href="#separando-o-movimento-em-duas-etapas">Separando o movimento em duas etapas</a></h2>
<p>Agora que nossa cobra possui uma direção armazenada na cabeça podemos mudar seu sistema de movimento para que seja executado a cada 0.15 segundos, fazemos isso da mesma forma que fizemos com o sistema de geração de comidas:</p>
<pre><code class="language-rs">fn main() {
    App::new()
        // ...
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(FixedTimestep::step(1.0))
                .with_system(food::spawn_system),
        )
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(FixedTimestep::step(0.150)) // &lt;--
                .with_system(snake::movement_system), // &lt;--
        ) 
        .run();
}
</code></pre>
<p>Nosso sistema de movimento está atrelado à translação da cobra em uma posição para cada tecla que apertarmos e agora sabemos que o sistema de movimento deve ser independente do sistema de direção, que vamos chamar de <code>snake::movement_input_system</code>. Então precisamos que o sistema de input/direção aconteça antes do sistema de movimento, e, ainda, precisamos garantir que o sistema de movimento aconteça a cada <code>0.15</code> segundos. Para solucionar este problema, vamos adicionar uma função especial para sistemas <code>before</code>. Para utilizar está função, precisamos adicionar o sistema de input que vamos criar e indicar que ele deve ocorrer antes do sistema de movimento com <code>.add_system(snake::movement_input_system.before(snake::movement_system))</code>, adicione ao <code>App::new()</code> na função main. Agora vamos para o sistema <code>movement_input_system</code>.</p>
<p>Primeira coisa que devemos fazer é alterar os testes para considerar que o <code>snake::movement_system</code> recebe uma query com <code>Position</code> e <code>snake::Head</code>, além de considerar que o movimento é feito com base no enum <code>Direction</code> contido dentro de <code>snake::Head</code>:</p>
<pre><code class="language-rs">// snake.rs
#[test]
    fn snake_starts_moviment_up() { // &lt;-- novo teste
        // Setup app
        let mut app = App::new();

        // Add startup system
        app.add_startup_system(spawn_system);

        // Run systems
        app.update();

        let mut query = app.world.query::&lt;&amp;Head&gt;();
        let head = query.iter(&amp;app.world).next().unwrap();
        assert_eq!(head.direction, Direction::Up);
    }

    #[test]
    fn snake_head_has_moved_up() {
        // Setup
        let mut app = App::new();
        let default_position = Position { x: 3, y: 4 };

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system)
            .add_system(movement_input_system.before(movement_system)); // &lt;--

        // Add input resource
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);

        // Run systems
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
        query.iter(&amp;app.world).for_each(|(head, position)| {
            assert_eq!(&amp;default_position, position);
            assert_eq!(head.direction, Direction::Up); // &lt;-- novo assert
            
        })
    }

    #[test]
    fn snake_head_moves_up_and_right() {
        // Setup
        let mut app = App::new();
        let up_position = Position { x: 3, y: 4 };

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system)
            .add_system(movement_input_system.before(movement_system)); // &lt;--

        // Move Up
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
        query.iter(&amp;app.world).for_each(|(_head, position)| {
            assert_eq!(position, &amp;up_position);
        });

        let up_right_position = Position { x: 4, y: 4 };

        // Move Right
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::D);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
        query.iter(&amp;app.world).for_each(|(head, position)| {
            assert_eq!(&amp;up_right_position, position);
            assert_eq!(head.direction, Direction::Right);
        })
    }

    #[test]
    fn snake_head_moves_down_and_left() {
        // Setup
        let mut app = App::new();
        let down_left_position = Position { x: 2, y: 2 };

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system)
            .add_system(movement_input_system.before(movement_system)); // &lt;--

        // Move Left
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::A);
        app.insert_resource(input);
        app.update();

         // Move down
         let mut input = Input::&lt;KeyCode&gt;::default();
         input.press(KeyCode::S);
         app.insert_resource(input);
         app.update();

        // Assert
        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
        query.iter(&amp;app.world).for_each(|(head, position)| {
            assert_eq!(&amp;down_left_position, position);
            assert_eq!(head.direction, Direction::Down);
        })
    }

    #[test]
    fn snake_cannot_start_moving_down() { // &lt;-- novo teste
         // Setup
         let mut app = App::new();
         let down_left_position = Position { x: 3, y: 4 };
 
         // Add systems
         app.add_startup_system(spawn_system)
             .add_system(movement_system)
             .add_system(movement_input_system.before(movement_system));
 
          // Move down
          let mut input = Input::&lt;KeyCode&gt;::default();
          input.press(KeyCode::S);
          app.insert_resource(input);
          app.update();
 
         // Assert
         let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
         query.iter(&amp;app.world).for_each(|(_head, position)| {
             assert_eq!(&amp;down_left_position, position);
         })
    }

</code></pre>
<blockquote>
<p>Novos testes: <code>snake_starts_moviment_up</code> que checa se a cobra inicia seu movimento para cima. <code>snake_cannot_start_moving_down</code> checa que não é possível se movimentar na direção oposta.</p>
</blockquote>
<p>Com estes testes sabemos que o movement system agora deve receber uma query com a posição mutável e com a <code>Head</code> para obtermos a direção. Com base na direção, movemos a posição da cabeça:</p>
<pre><code class="language-rs">pub fn movement_system(mut heads: Query&lt;(&amp;mut Position, &amp;Head)&gt;) {
    if let Some((mut pos, head)) = heads.iter_mut().next() {
        match &amp;head.direction {
            Direction::Left =&gt; {
                pos.x -= 1;
            }
            Direction::Right =&gt; {
                pos.x += 1;
            }
            Direction::Up =&gt; {
                pos.y += 1;
            }
            Direction::Down =&gt; {
                pos.y -= 1;
            }
        };
    }
}
</code></pre>
<p>Já o <code>movement_input_system</code> recebe uma leitura de teclado (<code>KeyCode</code>) e muda a direção com base nesta leitura do teclado e evita mudanças na direção oposta:</p>
<pre><code class="language-rs">pub fn movement_input_system(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, 
    mut heads: Query&lt;&amp;mut Head&gt;) {
    if let Some(mut head) = heads.iter_mut().next() {
        let dir: Direction = if keyboard_input.pressed(KeyCode::A) {
            Direction::Left
        } else if keyboard_input.pressed(KeyCode::S) {
            Direction::Down
        } else if keyboard_input.pressed(KeyCode::W) {
            Direction::Up
        } else if keyboard_input.pressed(KeyCode::D) {
            Direction::Right
        } else {
            head.direction
        };
        if dir != head.direction.opposite() {
            head.direction = dir;
        }
    }
}
</code></pre>
<p>Ao executarmos <code>cargo run</code> podemos ver a cobra se movimentando sozinha e obedecendo o sistema de direção. Próximo passo é adicionarmos o rabo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adicionando-um-rabo-a-cobra"><a class="header" href="#adicionando-um-rabo-a-cobra">Adicionando um Rabo a Cobra</a></h1>
<p>O rabo da cobra é uma parte um pouco mais complexa, pois para cada segmento é preciso saber o próximo segmento e para onde cada segmento esta se movendo. Assim, a forma mais simples de resolver este problema é adicionando todos os segmentos do rabo da cobra em um <code>Vec</code> e manter eles em um recurso ordenado em vez de entidades e componentes simples. Essa mudança nos garante que quando atualizarmos a posição de um segmento, atualizamos seu valor com relação ao segmento anterior. Isso pode ser feito iterando sobre todos os segmentos em pares com a função <a href="https://doc.rust-lang.org/std/slice/struct.Windows.html"><code>windows</code></a> que nos permite acessar o elemento anterior e o atual da lista. Outro elemento importante é que precisamos definir uma cor para o rabo da cobra, define que seria um tom de rosa com:</p>
<pre><code class="language-rs">// snake.rs
const SNAKE_SEGMENT_COLOR: Color = Color::rgb(0.8, 0.0, 0.8);
</code></pre>
<p>Agora que definimos uma cor, podemos começar a pensar no primeiro teste. O teste mais simples para este caso parece ser verificar se a entidade relacionada aos segmentos da cobra possui 2 segmento inicialmente:</p>
<pre><code class="language-rs">// snake.rs
#[test]
fn entity_snake_has_two_segments() {
    // Setup app
    let mut app = App::new();

    // Adicionar sistema de spawn e recurso com segmentos
    app
        .insert_resource(Segments::default())
        .add_startup_system(spawn_system);

    // Executar sistema
    app.update();

    // Buscar todas entidades com componente `Segment`
    let mut query = app.world.query_filtered::&lt;Entity, With&lt;Segment&gt;&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 2);
}
</code></pre>
<p>Executando esse teste vemos que precisamos adicionar o recurso <code>Segments</code> ao nosso código, um vetor de entidades como falamos anteriormente:</p>
<pre><code class="language-rs">// snake.rs
#[derive(Default, Deref, DerefMut)]
pub struct Segments(Vec&lt;Entity&gt;);
</code></pre>
<p>Com isso, precisamos reescrever nosso <code>snake::spawn_system</code> para utilizar <code>Segments</code>. Como é um startup system, será executado para iniciar entidades do jogo:</p>
<pre><code class="language-rs">pub fn spawn_system(mut commands: Commands, mut segments: ResMut&lt;Segments&gt;) {
    *segments = Segments(vec![
        commands
            .spawn_bundle(SpriteBundle {
                sprite: Sprite {
                    color: SNAKE_HEAD_COLOR,
                    ..default()
                },
                transform: Transform {
                    scale: Vec3::new(10.0, 10.0, 10.0),
                    ..default()
                },
                ..default()
            })
            .insert(Head::default())
            .insert(Segment)
            .insert(Position { x: 3, y: 3 })
            .insert(Size::square(0.8))
            .id(),
    ]);
}
</code></pre>
<p>Neste novo <code>spawn_system</code> recebemos o recurso <code>Segments</code> como um recurso mutável <code>mut segments: ResMut&lt;Segments&gt;</code> e definimos <code>segments</code> através de uma dereferência mutável, <code>#[derive(.., DerefMut)]</code>, reasignando o <code>Segment::default()</code>, que equivale a um vetor vazio, ao nosso recem adicionado componente. Outra mudança que precisamos fazer é adicionar o recurso <code>Segments</code> ao nosso startup do app na <code>main.rs</code> e em todos testes de <code>snake.rs</code>:</p>
<pre><code class="language-rs">// main.rs

fn main() {
    App::new()
        .insert_resource(WindowDescriptor {
            title: &quot;Snake Game&quot;.to_string(),
            width: 500.0,
            height: 500.0,
            ..default()
        })
        .insert_resource(snake::Segments::default()) // &lt;-- adicionar
        .add_startup_system(snake::spawn_system)
        // ...
        .run();
}

// snake.rs
#[test]
fn entity_has_snake_head() {
    let mut app = App::new();

    app
        .insert_resource(Segments::default()) // &lt;-- adicionar em todos testes
        .add_startup_system(spawn_system);

    app.update();

    let mut query = app.world.query_filtered::&lt;Entity, With&lt;Head&gt;&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 1);
}
</code></pre>
<p>Agora, executando nossos testes percebemos que o novo teste, <code>entity_snake_has_two_segments</code>, falha por possuir somente uma entidade. Para isso, precisamos criar um novo sistema que adiciona um novo <code>Segment</code> em posição específica e retorna uma <code>Entity</code> id para adicionarmos no recurso <code>Segments</code>. Este sistema que cria um novo segmento é bastante semelhante ao segmento que instancia a cobra em si, <code>spawn_system</code>, sua maior diferença é o fato de que passamos uma posição, <code>Position</code>, como argumento para o segmento e que o tamanho do quadrado é menor, com coloração diferente.</p>
<pre><code class="language-rs">pub fn spawn_segment_system(mut commands: Commands, position: Position) -&gt; Entity {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: SNAKE_SEGMENT_COLOR,
                ..default()
            },
            transform: Transform {
                    scale: Vec3::new(10.0, 10.0, 10.0),
                    ..default()
                },
            ..default()
        })
        .insert(Segment)
        .insert(position)
        .insert(Size::square(0.65))
        .id()
}
</code></pre>
<p>Com este novo sistema, podemos adicionar um segmento extra no nosso <code>snake::spawn_system</code>, que armazenará os segmentos cabeça e o recem criado como entidades em <code>Segments</code>:</p>
<pre><code class="language-rs">pub fn spawn_system(mut commands: Commands, mut segments: ResMut&lt;Segments&gt;) {
    *segments = Segments(vec![
        commands
            .spawn_bundle(SpriteBundle {
                sprite: Sprite {
                    color: SNAKE_HEAD_COLOR,
                    ..default()
                },
                transform: Transform {
                    scale: Vec3::new(10.0, 10.0, 10.0),
                    ..default()
                },
                ..default()
            })
            .insert(Head::default())
            .insert(Segment)
            .insert(Position { x: 3, y: 3 })
            .insert(Size::square(0.8))
            .id(),
            spawn_segment_system(commands, Position { x: 3, y: 2 }), // &lt;-- novo segmento
    ]);
}
</code></pre>
<p>Ao executarmos os teste agora, vemos que todos passam e podemos focar no próximo passo, fazer os segmentos se moverem seguindo a cabeça.</p>
<h2 id="fazendo-o-rabo-seguir-a-cabeça"><a class="header" href="#fazendo-o-rabo-seguir-a-cabeça">Fazendo o rabo seguir a cabeça</a></h2>
<p>Anteriormente já falamos que os segmentos da cobra estão armazenados em um <code>Vec</code> e podemos iterar sobre pares destes elementos utilizando a função <code>windows</code>, agora nos falta entender como criar um teste para verificar se um segmento assume a posição de seu antecessor ao andar, mantendo a direção de movimento. Assim, nosso novo teste considera que a cobra é inicializada na posição <code>x = 3</code> e <code>y = 3</code>, e seu segmento extra em <code>x = 3</code> e <code>y = 2</code>. A primeira parte do teste define as novas posições da cabeça, <code>Head</code>, e do segment, <code>Segment</code>, com <code>let new_position_head_right = Position { x: 4, y: 3 };</code> e <code>let new_position_segment_right = Position { x: 3, y: 3 };</code>, ou seja, <code>Head</code> se move para <code>x = 4</code> e <code>y = 3</code> e segment para <code>x = 3</code> e <code>y = 3</code> ao apertarmos a tecla <code>D</code> e executarmos um novo update:</p>
<pre><code class="language-rs">#[test]
fn snake_segment_has_followed_head() {
    // Setup
    let mut app = App::new();
    let new_position_head_right = Position { x: 4, y: 3 };
    let new_position_segment_right = Position { x: 3, y: 3 };

    // Adiciona os systemas
    app.insert_resource(Segments::default())
        .add_startup_system(spawn_system)
        .add_system(movement_system)
        .add_system(movement_input_system.before(movement_system));

    // adiciona resource apertando a tecla D, movimento para direita
    let mut input = Input::&lt;KeyCode&gt;::default();
    input.press(KeyCode::D);
    app.insert_resource(input);

    // executa sistemas
    app.update();

    let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
    query.iter(&amp;app.world).for_each(|(head, position)| {
        // garante que nova posição da cabeçá é esperada:
        assert_eq!(&amp;new_position_head_right, position); 
        // garante que nova direção é para direita:
        assert_eq!(head.direction, Direction::Right);
    });

    let mut query = app.world.query::&lt;(&amp;Segment, &amp;Position, Without&lt;Head&gt;)&gt;();
    query.iter(&amp;app.world).for_each(|(_segment, position, _)| {
        // garante que nova posição do segmento é esperada:
        assert_eq!(&amp;new_position_segment_right, position);
    });
    // ...
}
</code></pre>
<p>Por descargo de consciência podemos adicionar mais uma parte ao teste que muda a direção de movimento da cobra para cima:</p>
<pre><code class="language-rs">#[test]
fn snake_segment_has_followed_head() {
    // Setup
    let mut app = App::new();
    let new_position_head_right = Position { x: 4, y: 3 };
    let new_position_segment_right = Position { x: 3, y: 3 };

    // Adiciona os systemas
    app.insert_resource(Segments::default())
        .add_startup_system(spawn_system)
        .add_system(movement_system)
        .add_system(movement_input_system.before(movement_system));

    // adiciona resource apertando a tecla D, movimento para direita
    let mut input = Input::&lt;KeyCode&gt;::default();
    input.press(KeyCode::D);
    app.insert_resource(input);

    // executa sistemas
    app.update();

    let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
    query.iter(&amp;app.world).for_each(|(head, position)| {
        // garante que nova posição da cabeça é esperada:
        assert_eq!(&amp;new_position_head_right, position); 
        // garante que nova direção é para direita:
        assert_eq!(head.direction, Direction::Right);
    });

    let mut query = app.world.query::&lt;(&amp;Segment, &amp;Position, Without&lt;Head&gt;)&gt;();
    query.iter(&amp;app.world).for_each(|(_segment, position, _)| {
        // garante que nova posição do segmento é esperada:
        assert_eq!(&amp;new_position_segment_right, position);
    });

    // NOVAS POSIÇÕES ESPERADAS
    let new_position_head_up = Position { x: 4, y: 4 }; // &lt;--
    let new_position_segment_up = Position { x: 4, y: 3 }; // &lt;--

    // adiciona resource apertando a tecla W, movimento para cima
    let mut input = Input::&lt;KeyCode&gt;::default();
    input.press(KeyCode::W); // &lt;--
    app.insert_resource(input);

    // executa sistemas de novo
    app.update();

    let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
    query.iter(&amp;app.world).for_each(|(head, position)| {
        // garante que nova posição da cabeça é esperada:
        assert_eq!(&amp;new_position_head_up, position);
        // garante que nova direção da cabeça é esperada:
        assert_eq!(head.direction, Direction::Up); 
    });

    let mut query = app.world.query::&lt;(&amp;Segment, &amp;Position, Without&lt;Head&gt;)&gt;();
    query.iter(&amp;app.world).for_each(|(_segment, position, _)| {
        // garante que nova posição do segmento é esperada:
        assert_eq!(&amp;new_position_segment_up, position);
    })
}
</code></pre>
<p>Ao exercutarmos este código veremos que o assert <code>assert_eq!(&amp;new_position_segment_right, position);</code> falha indicando que o segmento não se moveu, mas a cabeça se moveu. Como estamos falando de movimento, sabemos que precisamos alterar o sistema <code>movement_system</code> para incluir uma iteração sobre os elementos de <code>Segments</code>. Assim a primeira alteração é adicionar o recurso <code>segments</code> nos argumentos do sistema, <code>segments: ResMut&lt;Segments&gt;</code>. Depois disso vamos precisar extrair duas queries diferentes para posição, <code>Position</code>, e cabeça, <code>Head</code>, já que agora nem todas posições terão cabeças, mas todas posições terão <code>Segment</code>, fazemos isso com as queries <code>mut heads: Query&lt;(Entity, &amp;Head)&gt;</code> e <code>mut positions: Query&lt;(Entity, &amp;Segment, &amp;mut Position)&gt;</code>. Precisamos de <code>Segment</code>, pois <code>Food</code> também possui <code>Position</code> e queremos evitar iterar por elementos desnecessarios em um ECS.</p>
<p>O código que vamos adicionar ao <code>movement_system</code> é simples, basicamente iteramos por <code>segments</code> dois a dois elementos por vez e adicionamos a posição do elementos anterior, <code>entity[0]</code>, na posição do elemento posterior, <code>entity[1]</code>. Algo como:</p>
<pre><code class="language-rs">(*segments).windows(2).for_each(|entity| {
    if let Ok((_, _segment, mut position)) = positions.get_mut(entity[1]) {
        if let Ok((_, _, mut new_position)) = positions.get_mut(entity[0]) {
            *position = new_position.clone();
        }
    };
});
</code></pre>
<p>Infelizmente, esse código em particular não compila devido ao fato de acessarmos <code>positions</code> como referência mutável duas vezes, inverter uma referência imutável e outra mutável também não funcionaria devida a uma regra do borrow checker do Rust que impede que um mesmo valor seja acesso como mutável e imutável no mesmo bloco. O mesmo acontece com duas referências diferentes mutáveis no mesmo bloco, o compilador não teria garantia que ambas não mutaria o mesmo valor ao mesmo tempo. Uma solução para este problema é adicionar um clone de <code>positions</code>, mas podemos fazer este clone ser mais inteligente, transformando ele em um <code>HashMap</code> na qual a chave é a entidade e a position é o valor, para depois acessarmos este clone de <code>positions</code> de forma imutável:</p>
<pre><code class="language-rs">pub fn movement_system(
    segments: ResMut&lt;Segments&gt;,
    mut heads: Query&lt;(Entity, &amp;Head)&gt;,
    mut positions: Query&lt;(Entity, &amp;Segment, &amp;mut Position)&gt;,
) {
    // Criar um hashmap clonado de positions com `Entity =&gt; Position`
    let positions_clone: HashMap&lt;Entity, Position&gt; = positions
        .iter()
        .map(|(entity, _segment, position)| (entity, position.clone()))
        .collect();
    // Acessar a cabeça (única existente por hora)
    if let Some((id, head)) = heads.iter_mut().next() {
        // Iterar sobre segments 2 a 2
        (*segments).windows(2).for_each(|entity| {
            // Acessar a posição da `entity[1]` em positions
            if let Ok((_, _segment, mut position)) = positions.get_mut(entity[1]) {
                // Acessar a posição da `entity[0]` em positions_clone
                if let Some(new_position) = positions_clone.get(&amp;entity[0]) {
                    // Substituir position por new_position
                    *position = new_position.clone();
                }
            };
        });

        // mesmo código de antes para mover a cabeça
        let _ = positions.get_mut(id).map(|(_, _segment, mut pos)| {
            match &amp;head.direction {
                Direction::Left =&gt; {
                    pos.x -= 1;
                }
                Direction::Right =&gt; {
                    pos.x += 1;
                }
                Direction::Up =&gt; {
                    pos.y += 1;
                }
                Direction::Down =&gt; {
                    pos.y -= 1;
                }
            };
        });
    }
}
</code></pre>
<p>Agora sim, nosso teste passa e se executarmos <code>cargo run</code> vemos que o segmento rosa sempre segue a cabeça. Próximo passo é entender como criar um sistema para expandir a cobra ao comer.</p>
<h2 id="alimentando-a-cobra"><a class="header" href="#alimentando-a-cobra">Alimentando a cobra</a></h2>
<p>Faz algum tempo que nossa cobra está rodeada de comida, mas não pode comer, por isso chegou a hora de elaborarmos um teste que vai garatir que nossa cobra possa comer e que ela vai crescer ao comer. Nosso teste vai partir de um setup um pouco mais complexo, pois agora precisamos registrar um evento de crescimento, <code>GrowthEvenet</code>, precisamos registrar a última posição do vetor de segmentos, <code>LastTailPosition</code>, o nosso antigo sistema de spawn de comida, <code>crate::food::spawn_system</code>, e um system set organizado o que acontece primeiro. Algo como o seguinte bloco:</p>
<pre><code class="language-rs">app.insert_resource(Segments::default())
    .insert_resource(LastTailPosition::default())
    .add_event::&lt;GrowthEvent&gt;()
    .add_startup_system(spawn_system)
    .add_system(crate::food::spawn_system)
    .add_system_set(
        SystemSet::new()
            .with_system(movement_system)
            .with_system(eating_system.after(movement_system))
            .with_system(growth_system.after(eating_system))
    );
</code></pre>
<p>Depois disso teremos dois updates, primeiro update cria o contexto de mundo e nos permite verificar que uma comida foi spawnada e que a cobra possui dois segmentos:</p>
<pre><code class="language-rs">app.update();

let mut query = app.world.query::&lt;(&amp;Segment, &amp;Position)&gt;();
assert_eq!(query.iter(&amp;app.world).count(), 2);
let mut query = app.world.query::&lt;(&amp;Food, &amp;Position)&gt;();
assert_eq!(query.iter(&amp;app.world).count(), 1);
</code></pre>
<p>Por último, executamos mais uma vez o update e verificamos se a cobra possui 3 segmentos agora:</p>
<pre><code class="language-rs">app.update();

let mut query = app.world.query::&lt;(&amp;Segment, &amp;Position)&gt;();
assert_eq!(query.iter(&amp;app.world).count(), 3);
</code></pre>
<p>Infelizmente, um teste somento com isso não nos garantiria sucesso, já que o <code>crate::food::spawn_system</code> gera uma posição aleatória dentro do grid, para isso precisamos modificar a função <code>crate::food::spawn_system</code> para termos controle  da posição que a comida vai surgir. Fazemos isso adicionado uma macro de compilação exclusiva de teste, <code>cfg!</code>:</p>
<pre><code class="language-rs">// food.rs
#[allow(clippy::cast_possible_wrap)]
pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: FOOD_COLOR,
                ..default()
            },
            ..default()
        })
        .insert(Food)
        .insert(Position {
            x: if cfg!(test) { 3 } else { (random::&lt;u16&gt;() % GRID_WIDTH) as i16 }, // &lt;--
            y: if cfg!(test) { 5 } else { (random::&lt;u16&gt;() % GRID_HEIGHT) as i16 }, // &lt;--
        })
        .insert(Size::square(0.65));
}
</code></pre>
<p>Agora sim, nosso teste poderá fazer sentido ao compilar:</p>
<pre><code class="language-rs">// snake.rs
#[test]
fn snake_grows_when_eating() {
    // Setup
    let mut app = App::new();

    // sistemas
    app.insert_resource(Segments::default())
        .insert_resource(LastTailPosition::default())
        .add_event::&lt;GrowthEvent&gt;()
        .add_startup_system(spawn_system)
        .add_system(crate::food::spawn_system)
        .add_system_set(
            SystemSet::new()
                .with_system(movement_system)
                .with_system(eating_system.after(movement_system))
                .with_system(growth_system.after(eating_system))
        );

    // update de configuração
    app.update();

    let mut query = app.world.query::&lt;(&amp;Segment, &amp;Position)&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 2);
    let mut query = app.world.query::&lt;(&amp;Food, &amp;Position)&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 1);

    // update de execução
    app.update();

    let mut query = app.world.query::&lt;(&amp;Segment, &amp;Position)&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 3);
}
</code></pre>
<p>Pronto, agora podemos ir jantar, mas, infelizmente, nossa  cobra ainda não. Para isso, começamos com o <code>snake::eating_system</code>. O objetivo de <code>snake::eating_system</code> é simples, iterar sobre todas as entidades com componente comida, <code>Food</code>, e ver se a posição delas, <code>Position</code>, é igual a <code>Position</code> das entidades com <code>Head</code>. Caso, a firmação anterior seja verdade, removemos, <code>despawn</code>, a entidade <code>Food</code> e lançamos no sistema um evento para crescer a cobra, <code>GrowthEvent</code>, na sua última posição, <code>pub struct LastTailPosition(Option&lt;Position&gt;)</code>. Um detalhe importante, é que para publicar um evento, <code>EventWriter</code>, precisamos registrar esse evento no <code>App</code>, com <code>add_event::&lt;GrowthEvent&gt;()</code>, o mesmo vale para lermos os eventos, <code>EventReader</code>.</p>
<pre><code class="language-rs">pub struct GrowthEvent;

#[derive(Default)]
pub struct LastTailPosition(Option&lt;Position&gt;);

pub fn eating_system(
    mut commands: Commands,
    mut growth_writer: EventWriter&lt;GrowthEvent&gt;,
    food_positions: Query&lt;(Entity, &amp;Position), With&lt;Food&gt;&gt;,
    head_positions: Query&lt;&amp;Position, With&lt;Head&gt;&gt;,
) {
    for head_pos in head_positions.iter() {
        for (ent, food_pos) in food_positions.iter() {
            if food_pos == head_pos {
                commands.entity(ent).despawn();
                growth_writer.send(GrowthEvent);
            }
        }
    }
}
</code></pre>
<p>Na função anterior, recebemos um <code>EventWriter</code> do tipo <code>GrowthEvent</code>, que vai publicar quaisquer eventos necessários, uma query com todas as entidades e posições de comidas, <code>Query&lt;(Entity, &amp;Position), With&lt;Food&gt;&gt;</code> e uma query com a posição das cabeças, no caso, apenas uma, <code>Query&lt;&amp;Position, With&lt;Head&gt;&gt;</code>. Iteramos por tudo e checamos se as posições são iguais para então removermos a entidade associada a comida e publicarmos um evento de crescimento. Próximo passo é lermos o evento com <code>EventReader&lt;GrowthEvent&gt;</code> e adicionarmos um clone da última posição do rabo, como um novo segmento, aos segmentos, <code>Segments</code>:</p>
<pre><code class="language-rs">pub fn growth_system(
    commands: Commands,
    last_tail_position: Res&lt;LastTailPosition&gt;,
    mut segments: ResMut&lt;Segments&gt;,
    mut growth_reader: EventReader&lt;GrowthEvent&gt;,
) {
    if growth_reader.iter().next().is_some() {
        segments.push(spawn_segment_system(commands, last_tail_position.0.clone().unwrap()));
    }
}
</code></pre>
<p>Nosso teste está quase passando, precisamos adicionar a informação da última posição de segmentos quando nos movimentamos, senão <code>LastTailPosition</code>será sempre <code>None</code> e nossa cobra não crescerá. Para isso, adicionamos o recuso mutável, <code>ResMut</code>, ao sistema <code>movement_system</code> e no final dele, buscamos a última posição dos segmentos:</p>
<pre><code class="language-rs">pub fn movement_system(
    segments: ResMut&lt;Segments&gt;,
    mut last_tail_position: ResMut&lt;LastTailPosition&gt;,
    mut heads: Query&lt;(Entity, &amp;Head)&gt;,
    mut positions: Query&lt;(Entity, &amp;Segment, &amp;mut Position)&gt;,
) {
    let positions_clone: HashMap&lt;Entity, Position&gt; = positions
        .iter()
        .map(|(entity, _segment, position)| (entity, position.clone()))
        .collect();
    if let Some((id, head)) = heads.iter_mut().next() {
        (*segments).windows(2).for_each(|entity| {
            if let Ok((_, _segment, mut position)) = positions.get_mut(entity[1]) {
                if let Some(new_position) = positions_clone.get(&amp;entity[0]) {
                    *position = new_position.clone();
                }
            };
        });
        // ...
        *last_tail_position = LastTailPosition(Some(positions_clone.get(segments.last().unwrap()).unwrap().clone())); // &lt;--
    }
}
</code></pre>
<p>Aghora sim, nosso teste passa! Sabrmos que podemos utilizar <code>unwrap</code>, pois a cobra inicia seu movimento com 2 segmentos e sabemos que ambos os segmentos possuem <code>Position</code>, assim, <code>positions_clone.get</code> , também, nunca será <code>None</code>. Possivelmente precisaremos adicionar alguns <code>.insert_resource(LastTailPosition::default())</code>no setup dos testes.</p>
<p>No próximo capítulo vamos aprender um pouco mais sobre colisões.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colisões"><a class="header" href="#colisões">Colisões</a></h1>
<p>Uma parte muito importante de jogos é a definição dos critérios de perda ou derrota. No caso do snake game, há dois critérios:</p>
<ol>
<li>A cobra &quot;come&quot; um pedaço dela mesma.</li>
<li>A cobra sai dos limites, ou paredes, do jogo.</li>
</ol>
<p>Testar a cobra comendo um pedaço dela mesma é bastante complicado considerando um cenário na qual as comidas surgem de forma aleátoria, pois a cobra precisa possuir pelo menos 5 segmentos para que ocorra uma colisão da cabeça da cobra com um segmento. Neste caso, um teste de gameplay seria mais fácil e possivelmente mais valioso, porém não é algo que planejei dentro do escopo deste livro. Por outro lado, testar que a cobra sai dos limites do jogo é bastante trivial, basta definir uma direção e garantir que após <code>n</code> updates, a cobra vai colidir com as paredes. Uma vez que a condição de colisão ocorreu, podemos publicar um evento de game end, e pausa o jogo com um status de jogo. Único teste que não vou escrever neste caso é o teste de colisão com a parede de baixo, mas seria igual aos outros, porém com 3 updates extras para fazer retorno e mudar a direção para baixo.</p>
<p>O primeiro teste consite basicamente em fazer com que a cobra se movimente para cima até ultrapassar a parede superior e ai detectamos um componente do tipo <code>GameEndEvent::GameOver</code>, derivado do evento <code>GameEndEvent</code>. Adicionaremos este teste em um novo módulo chamado <code>game.rs</code>:</p>
<pre><code class="language-rs">#[test]
fn game_end_event_with_game_over() {
    // Setup
    let mut app = App::new();

    // Sistemas
    app.insert_resource(Segments::default())
        .insert_resource(LastTailPosition::default())
        .add_event::&lt;GameEndEvent&gt;() // &lt;--
        .add_startup_system(snake::spawn_system)
        .add_system(snake::movement_system)
        .add_system(snake::movement_input_system.before(snake::movement_system))
        .add_system(game_over_system.after(snake::movement_system)); // &lt;--

    // tecla para cima
    let mut input = Input::&lt;KeyCode&gt;::default();
    input.press(KeyCode::W);
    app.insert_resource(input);

    // executgar sistema algumas vezes
    app.update(); // x: 3, y: 4
    app.update(); // x: 3, y: 5
    app.update(); // x: 3, y: 6
    app.update(); // x: 3, y: 7
    app.update(); // x: 3, y: 8
    app.update(); // x: 3, y: 9

    // Verificar que não há componente de game end
    let mut query = app.world.query::&lt;&amp;GameEndEvent&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 0);

    app.update(); // x: 3, y: 10

    // Verificar que há componente de game end
    let mut query = app.world.query::&lt;&amp;GameEndEvent&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 1);
}
</code></pre>
<p>Com este teste podemos começar a implementar o primeiro critério de falha, que neste caso seria <code>y</code> da posição da cabça menor que zero ou maior ou igual a <code>GRID_HEIGHT</code>, ou seja, <code>head.position.y &lt; 0 || head.position.y &gt;= GRID_HEIGHT</code>. Na função <code>snake::movement_system</code>, temos acesso a <code>head.position</code> dentro do block que contém o <code>match head.direction</code>, assim podemos adicionar a condicional de posições depois do match e publicar o evento <code>GameEndEvent::GameOver</code> pelo <code>EventWriter</code> que precisamos adicionar nos argumentos da função:</p>
<pre><code class="language-rs">pub fn movement_system(
    segments: ResMut&lt;Segments&gt;,
    mut last_tail_position: ResMut&lt;LastTailPosition&gt;,
    mut game_end_writer: EventWriter&lt;GameEndEvent&gt;, // &lt;-- Adicionar EventWriter
    mut heads: Query&lt;(Entity, &amp;Head)&gt;,
    mut positions: Query&lt;(Entity, &amp;Segment, &amp;mut Position)&gt;,
    game_end: Query&lt;&amp;GameEndEvent&gt;,
) {
    let positions_clone: HashMap&lt;Entity, Position&gt; = positions
        .iter()
        .map(|(entity, _segment, position)| (entity, position.clone()))
        .collect();
    if let Some((id, head)) = heads.iter_mut().next() {
        (*segments).windows(2).for_each(|entity| {
            if let Ok((_, _segment, mut position)) = positions.get_mut(entity[1]) {
                if let Some(new_position) = positions_clone.get(&amp;entity[0]) {
                    *position = new_position.clone();
                }
            };
        });
        
        let _ = positions.get_mut(id).map(|(_, _segment, mut pos)| {
            match &amp;head.direction {
                Direction::Left =&gt; {
                    pos.x -= 1;
                }
                Direction::Right =&gt; {
                    pos.x += 1;
                }
                Direction::Up =&gt; {
                    pos.y += 1;
                }
                Direction::Down =&gt; {
                    pos.y -= 1;
                }
            };
            if pos.y &lt; 0
                || pos.y as u16 &gt;= GRID_HEIGHT // &lt;-- Condicional de limites do grid
            {
                game_end_writer.send(GameEndEvent::GameOver); // &lt;-- publicar evento
            }
        });
        
        *last_tail_position = LastTailPosition(Some(
            positions_clone
                .get(segments.last().unwrap())
                .unwrap()
                .clone(),
        ));
    }
}
</code></pre>
<p>Agora todos os testes que lidam com <code>movement_system</code> falham e é preciso adicionar <code>.add_event::&lt;GameEndEvent&gt;()</code> ao setup de sistemas, além disso, adicione a função <code>main</code>. Outro elemento importante é adicionar o <code>GameEndEvent</code>, que vamos adicionar no móduclo <code>components.rs</code>:</p>
<pre><code class="language-rs">// components.rs

#[derive(Component, Clone, Debug, PartialEq, Eq)]
pub enum GameEndEvent {
    GameOver,
}

impl Default for GameEndEvent {
    fn default() -&gt; Self {
        Self::GameOver
    }
}
</code></pre>
<p>Perfeito, mas o teste ainda não passa, pois não temos nenhum sistema escutando pelo evento <code>GameEndEvent</code>, podemos adicionar um sistema <code>game_over_system</code> que adicionará o componente <code>GameEndEvent::GameOver</code> que buscamos no teste. Este sistema verificará se existe algum evento do tipo <code>GameEndEvent</code>, se houver cria uma entidade com <code>GameEndEvent::GameOver</code> como componente e print no console <code>&quot;Game Over!&quot;</code>;</p>
<pre><code class="language-rs">// game.rs

pub fn game_over_system(mut commands: Commands, mut reader: EventReader&lt;GameEndEvent&gt;) {
    if reader.iter().next().is_some() {
        commands.spawn().insert(GameEndEvent::GameOver);
        println!(&quot;{}&quot;, GameEndEvent::GameOver);
    }
}
</code></pre>
<p>Para printar no console um enum podemos implementar a trait Display:</p>
<pre><code class="language-rs">// components.rs

impl Display for GameEndEvent {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            GameEndEvent::GameOver =&gt; write!(f, &quot;Game Over!&quot;),
        }
    }
}
</code></pre>
<p>Agora nosso teste passa, mas quero adicionar um assert extra no nosso teste, que a posição da cobra não mudará após um game over. Fazemos isso adicionando uma verificação que a posição após o <code>GameEndEvent::GameOver</code> não mudará mesmo após updates.</p>
<pre><code class="language-rs">#[test]
fn game_end_event_with_game_over() {
    // ...

    let mut query = app.world.query::&lt;&amp;GameEndEvent&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 1);

    let mut query = app.world.query_filtered::&lt;&amp;Position, With&lt;Head&gt;&gt;();
    let position_at_gameover = query.iter(&amp;app.world).next().unwrap();
    let snake_position_after_game_over = position_at_gameover.clone();

    app.update();

    let mut query = app.world.query_filtered::&lt;&amp;Position, With&lt;Head&gt;&gt;();
    let position_after_gameover = query.iter(&amp;app.world).next().unwrap();

    assert_eq!(snake_position_after_game_over, position_after_gameover.clone());
}
</code></pre>
<p>Essa mudança é facilmente resolvida adicionando uma query que busca por um <code>GameEndEvent</code>, <code>Query&lt;&amp;GameEndEvent&gt;</code>, e verificando se ela não está vazia em um <code>if</code>:</p>
<pre><code class="language-rs">pub fn movement_system(
    segments: ResMut&lt;Segments&gt;,
    mut last_tail_position: ResMut&lt;LastTailPosition&gt;,
    mut game_end_writer: EventWriter&lt;GameEndEvent&gt;,
    heads: Query&lt;(Entity, &amp;Head)&gt;,
    mut positions: Query&lt;(Entity, &amp;Segment, &amp;mut Position)&gt;,
    game_end: Query&lt;&amp;GameEndEvent&gt;, // &lt;-- GameEndEvent Query
) {
    // ...
    if let Some((id, head)) = heads.iter().next() {
        (*segments).windows(2).for_each(|entity| {
            if let Ok((_, _segment, mut position)) = positions.get_mut(entity[1]) {
                if let Some(new_position) = positions_clone.get(&amp;entity[0]) {
                    *position = new_position.clone();
                }
            };
        });
        if game_end.is_empty() {  // &lt;-- if verificando se houve um evento de fimd e jogo
            let _ = positions.get_mut(id).map(|(_, _segment, mut pos)| {
                match &amp;head.direction {
                    // ...
                };
                if pos.y &lt; 0
                    || pos.y as u16 &gt;= GRID_HEIGHT
                {
                    game_end_writer.send(GameEndEvent::GameOver);
                }
            });
        }
        // ...
    }
}
</code></pre>
<p>Próximo teste é verificar se o mesmo acontece se movendo para esquerda e para a direita. Começamos pela esquerda:</p>
<pre><code class="language-rs">#[test]
fn game_end_event_with_game_over_when_moving_left() {
    // Setup
    let mut app = App::new();

    // Add systems
    app.insert_resource(Segments::default())
        .insert_resource(LastTailPosition::default())
        .add_event::&lt;GameEndEvent&gt;()
        .add_startup_system(snake::spawn_system)
        .add_system(snake::movement_system)
        .add_system(snake::movement_input_system.before(snake::movement_system))
        .add_system(game_over_system.after(snake::movement_system));

    // Add new input resource
    let mut input = Input::&lt;KeyCode&gt;::default();
    input.press(KeyCode::A);
    app.insert_resource(input);

    // Run systems again
    app.update(); // x: 2, y: 3
    app.update(); // x: 1, y: 3
    app.update(); // x: 0, y: 3

    let mut query = app.world.query::&lt;&amp;GameEndEvent&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 0);

    app.update(); // x: -1, y: 3

    let mut query = app.world.query::&lt;&amp;GameEndEvent&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 1);

}
</code></pre>
<p>Com isso adicionamos a verificação se <code>head.position</code> não é menor que zero:</p>
<pre><code class="language-rs">pub fn movement_system(
    // ...
) {
    // ...
    if let Some((id, head)) = heads.iter().next() {
        // ...
        if game_end.is_empty() {  // &lt;-- if verificando se houve um evento de fimd e jogo
            let _ = positions.get_mut(id).map(|(_, _segment, mut pos)| {
                match &amp;head.direction {
                    // ...
                };
                if pos.x &lt; 0 // &lt;-- Nova Verificação
                    || pos.y &lt; 0
                    || pos.y as u16 &gt;= GRID_HEIGHT
                {
                    game_end_writer.send(GameEndEvent::GameOver);
                }
            });
        }
        // ...
    }
}
</code></pre>
<p>Depois, repetimos o teste se movendo para direita e com uma verificação se <code>head.position.x</code> maior ou igual a <code>GRID_WIDTH</code>:</p>
<pre><code class="language-rs">#[test]
fn game_end_event_with_game_over_when_moving_right() {
    // Setup
    let mut app = App::new();

    // Add systems
    app.insert_resource(Segments::default())
        .insert_resource(LastTailPosition::default())
        .add_event::&lt;GameEndEvent&gt;()
        .add_startup_system(snake::spawn_system)
        .add_system(snake::movement_system)
        .add_system(snake::movement_input_system.before(snake::movement_system))
        .add_system(game_over_system.after(snake::movement_system));

    // Add new input resource
    let mut input = Input::&lt;KeyCode&gt;::default();
    input.press(KeyCode::D);
    app.insert_resource(input);

    // Run systems again
    app.update(); // x: 4, y: 3
    app.update(); // x: 5, y: 3
    app.update(); // x: 6, y: 3
    app.update(); // x: 7, y: 3
    app.update(); // x: 8, y: 3
    app.update(); // x: 9, y: 3
    app.update(); // x: 10, y: 3

    let mut query = app.world.query::&lt;&amp;GameEndEvent&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 1);
}
</code></pre>
<pre><code class="language-rs">pub fn movement_system(
    // ...
) {
    // ...
    if let Some((id, head)) = heads.iter().next() {
        // ...
        if game_end.is_empty() {  
            let _ = positions.get_mut(id).map(|(_, _segment, mut pos)| {
                match &amp;head.direction {
                    // ...
                };
                if pos.x &lt; 0
                    || pos.y &lt; 0
                    || pos.x as u16 &gt;= GRID_WIDTH // &lt;-- Nova verificação
                    || pos.y as u16 &gt;= GRID_HEIGHT
                {
                    game_end_writer.send(GameEndEvent::GameOver);
                }
            });
        }
        // ...
    }
}
</code></pre>
<h2 id="colidindo-com-o-rabo"><a class="header" href="#colidindo-com-o-rabo">Colidindo com o rabo</a></h2>
<p>Como mencionei antes, escrever um teste para este cenário é um pouco mais trabalhoso que eu gostariae acaba sendo mais fácil fazer com alguma ferramenta de testes automatizados, mas caso você queira um desafio, para escrever este teste você pode executar o sistema de spawn de segmentos (<code>spawn_segment_system</code>) com posições, <code>Position</code>, especificas e ao realizar um update a posição de <code>Head</code> vai ser igual a posição de um elemento do rabo. Agora vamos ao código, é uma mudança muito simples em movement system, basta adicionarmos mais uma cláusula <code>if</code> que checa se a posição de <code>Head</code> é a mesma que qualquer posição de <code>Segment</code>, infelizmente não temos uma estrutura de dados que possui todas a <code>Positions</code> com <code>Segments</code> identificadas, mas possuimos <code>positions_clone</code> que é um <code>HashMap&lt;Entity, Position&gt;</code>. </p>
<p>Para descobrirmos o valor de position que não contém <code>Head</code> precisamos filtrar por todas <code>Positions</code>, cuja <code>Entity</code> correspondente não é igual ao <code>id</code> de <code>Head</code>, algo como <code>positions_clone.iter().filter(|(k, _)| k != &amp;&amp;id)</code>. Com isso, teremos um iterável que possui todos os pares <code>Entity, Position</code> que não correspondem ao conjunto <code>Entity, Position, Head</code> e podemos continuar iterando somente com <code>Positions</code> adicionando <code>.map(|(_, v)| v)</code>, para depois verificamos se existe qualquer <code>Position</code> que equivale ao par <code>Head, Position</code>, utilizando o valor da variável <code>pos</code>, <code>.any(|segment_position| &amp;*pos == segment_position)</code>.  Adicionamos esta lógica logo após o outro if de game over e publicamos outro <code>GameEndEvent::GameOver</code>:</p>
<pre><code class="language-rs">pub fn movement_system(
    segments: ResMut&lt;Segments&gt;,
    mut last_tail_position: ResMut&lt;LastTailPosition&gt;,
    mut game_end_writer: EventWriter&lt;GameEndEvent&gt;,
    heads: Query&lt;(Entity, &amp;Head)&gt;,
    mut positions: Query&lt;(Entity, &amp;Segment, &amp;mut Position)&gt;,
    game_end: Query&lt;&amp;GameEndEvent&gt;,
) {
    let positions_clone: HashMap&lt;Entity, Position&gt; = positions
        .iter()
        .map(|(entity, _segment, position)| (entity, position.clone()))
        .collect();
    if let Some((id, head)) = heads.iter().next() {
        // ...
        if game_end.is_empty() {
            let _ = positions.get_mut(id).map(|(_, _segment, mut pos)| {
                match &amp;head.direction {
                    // ...
                };
                if pos.x &lt; 0
                    || pos.y &lt; 0
                    || pos.x as u16 &gt;= GRID_WIDTH
                    || pos.y as u16 &gt;= GRID_HEIGHT
                {
                    game_end_writer.send(GameEndEvent::GameOver);
                }

                if positions_clone.iter()
                    .filter(|(k, _)| k != &amp;&amp;id)
                    .map(|(_, v)| v)
                    .any(|segment_position| &amp;*pos == segment_position)
                {
                    game_end_writer.send(GameEndEvent::GameOver);
                }
            });
        }
        // ...
    }
}
</code></pre>
<p>Agora é hora de um teste manual e voilá, &quot;a cobra morde o rabo!&quot;. Proxima colisão que devemos impedir é a de comidas surgindo em posições já ocupadas. </p>
<h2 id="colisões-de-surgimento-de-comdias"><a class="header" href="#colisões-de-surgimento-de-comdias">Colisões de surgimento de comdias</a></h2>
<p>Particularmente não sou fã dessa, pois na minha concepção uma comida deveria poder surgir embaixo da cobra, desde que não seja na cabeça, mas vale a explicação pelo exemplo. Assim, o teste que vamos escrever é bastante simples, pois vamos apenas checar se a quantidade de entidades com os componentes <code>Food</code> e <code>Position</code> é <code>1</code>, apesar de termos dois updates. Podemos fazer isso por conta  da condição de <code>spawn</code> associada a testes em <code>food::spawn_system</code>, quando utilizados <code>if cfg!(test)</code> com valores pré-fixados.</p>
<pre><code class="language-rs">#[test]
fn food_only_spawns_once() {
    // Setup
    let mut app = App::new();

    // Add systems
    app.add_system(spawn_system);


    // Run systems
    app.update();

    let mut query = app.world.query::&lt;(&amp;Food, &amp;Position)&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 1);

    // Run systems
    app.update();

    let mut query = app.world.query::&lt;(&amp;Food, &amp;Position)&gt;();
    assert_eq!(query.iter(&amp;app.world).count(), 1)
}
</code></pre>
<p>A solução para este teste é bastante simples, Precisamos obter uma posição que não coincide com outra posição, fazemos isso com um iterador infinito, que procura pela primeira posição que não coincide com outra. Esse iterator pode ser feita com um <code>Range</code> do tipo <code>(0..)</code> (de <code>0</code> a infinito), depois criamos instâncias aleatórias de <code>Position</code> e procuramos por uma <code>Position</code> que não está contida em um <code>HashSet</code> de <code>Position</code>.</p>
<pre><code class="language-rs">(0..)
    .map(|_| Position {
        x: if cfg!(test) {
            3
        } else {
            (random::&lt;u16&gt;() % GRID_WIDTH) as i16
        },
        y: if cfg!(test) {
            5
        } else {
            (random::&lt;u16&gt;() % GRID_HEIGHT) as i16
        },
    })
    .find(|position| !positions_set.contains(position))
</code></pre>
<p><code>positions_set</code> é o <code>HashSet&lt;Position&gt;</code> que falamos antes, podemos criar ele através de <code>let positions_set: HashSet&lt;&amp;Position&gt; = positions.iter().collect();</code>, porém <code>Position</code> não implementa a trait <code>Hash</code>, que é facilmente resolvível adicionando a macro <code>Hash</code> ao <code>derive</code> de <code>Position</code>:</p>
<pre><code class="language-rs">#[derive(Component, Clone, Debug, PartialEq, Eq, Hash)]
pub struct Position {
    pub x: i16,
    pub y: i16,
}
</code></pre>
<p>Agora, precisamos adicionar uma comida ao jogo apenas se o retorno de find é existente, <code>Option::Some</code>:</p>
<pre><code class="language-rs">pub fn spawn_system(mut commands: Commands, positions: Query&lt;&amp;Position&gt;) {
    let positions_set: HashSet&lt;&amp;Position&gt; = positions.iter().collect();

    if let Some(position) = (0..)
        .map(|_| Position {
            x: if cfg!(test) {
                3
            } else {
                (random::&lt;u16&gt;() % GRID_WIDTH) as i16
            },
            y: if cfg!(test) {
                5
            } else {
                (random::&lt;u16&gt;() % GRID_HEIGHT) as i16
            },
        })
        .find(|position| !positions_set.contains(position))
    {
        commands
            .spawn_bundle(SpriteBundle {
                sprite: Sprite {
                    color: FOOD_COLOR,
                    ..default()
                },
                ..default()
            })
            .insert(Food)
            .insert(position)
            .insert(Size::square(0.65));
    }
}
</code></pre>
<p>Para resolvermos esse problema, encapsulamos nosso iterador infinito em um <code>if let</code> e em caso de <code>Option::Some</code>, adicionamos uma nova comida. Porém, do jeito que escrevemos o iterador infinito vai quebrar os testes já que nunca vai encontrar uma <code>Position</code> válida em testes. Assim, podemos fazer uma aproximação para o tamanho do grid, <code>(0..(GRID_WIDTH * GRID_HEIGHT))</code>:</p>
<pre><code class="language-rs">pub fn spawn_system(mut commands: Commands, positions: Query&lt;&amp;Position&gt;) {
    let positions_set: HashSet&lt;&amp;Position&gt; = positions.iter().collect();

    if let Some(position) = (0..(GRID_WIDTH * GRID_HEIGHT))
        .map(|_| Position {
            x: if cfg!(test) {
                3
            } else {
                (random::&lt;u16&gt;() % GRID_WIDTH) as i16
            },
            y: if cfg!(test) {
                5
            } else {
                (random::&lt;u16&gt;() % GRID_HEIGHT) as i16
            },
        })
        .find(|position| !positions_set.contains(position))
    {
        commands
            .spawn_bundle(SpriteBundle {
                sprite: Sprite {
                    color: FOOD_COLOR,
                    ..default()
                },
                ..default()
            })
            .insert(Food)
            .insert(position)
            .insert(Size::square(0.65));
    }
}
</code></pre>
<p>Agora sim, testes passando e comidas surgem de forma eficiente. Próximo passo antes de começar o multiplayer será atualizar o jogo para as duas versões mais novas da Bevy (0.8 e 0.9).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrando-versões-da-bevy"><a class="header" href="#migrando-versões-da-bevy">Migrando versões da Bevy</a></h1>
<p>A equipe da Bevy fez um trabalho sensacional auxiliando equipes que usam a engine a manter seus códigos atulizados com as novas versões e guias futuros podem ser encontrados em https://bevyengine.org/learn/book/migration-guides/. Neste momento a última versão é a 0.9, portanto migraremos para versão 0.8 e depois para 0.9.</p>
<h2 id="migrando-para-versão-08"><a class="header" href="#migrando-para-versão-08">Migrando para versão 0.8</a></h2>
<p>Para iniciarmos a migração basta mudarmos a versão da <code>bevy</code> no Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
bevy = { version = &quot;0.8&quot;, features = [&quot;dynamic&quot;] }
rand = &quot;0.7&quot;
</code></pre>
<p>Depois ao executar um <code>cargo check</code> veremos que já no arquivo <code>main.rs</code> há dois erros:</p>
<ol>
<li><code>OrthographicCameraBundle</code> é uma struct não declarada. Basta substituir <code>OrthographicCameraBundle::new_2d()</code> por <code>Camera2dBundle::default()</code>.</li>
<li><code>FixedTimestep</code> não foi encontrado no módulo <code>core</code>. Isso acontece pois <code>FixedTimestep</code> e todas as coisas relacionadas a tempo foram movidas para o módulo time, assim mude o import para <code>use bevy::{time::FixedTimestep, prelude::*};</code>.</li>
</ol>
<p>Migração pronta!</p>
<h2 id="migrando-para-versão-09"><a class="header" href="#migrando-para-versão-09">Migrando para versão 0.9</a></h2>
<p>A migração para versão 0.9 é um pouco mais trabalhosa, pois algumas inferfaces da API mudaram.</p>
<h3 id="spawn"><a class="header" href="#spawn">Spawn</a></h3>
<p>Agora para utilizar a função <code>Commands.spawn</code> precisamos enviar uma tupla com quais serão os componentes spawnados, como era feito em  <code>spawn_bundle</code>, ou utilizar <code>spawn_empty</code> para criar uma entidade vazia. Além disso, <code>spawn_bundle</code> passa a ser deprecada. Assim a mudança fica:</p>
<pre><code class="language-rs">// Antigo
commands.spawn().insert_bundle((A, B, C));
// Novo
commands.spawn((A, B, C));
</code></pre>
<p>No nosso código, essa mudança reflete nos módulos <code>game.rs</code>:</p>
<pre><code class="language-rs">pub fn game_over_system(mut commands: Commands, mut reader: EventReader&lt;GameEndEvent&gt;) {
    if reader.iter().next().is_some() {
        commands.spawn_empty().insert(GameEndEvent::GameOver);
        println!(&quot;{}&quot;, GameEndEvent::GameOver);
    }
}
</code></pre>
<p>E mudamos <code>spawn_bundle</code> por <code>spawn</code> em <code>food.rs</code>, assim como em vários lugares de <code>snake.rs</code>:</p>
<pre><code class="language-rs">pub fn spawn_system(mut commands: Commands, positions: Query&lt;&amp;Position&gt;) {
    let positions_set: HashSet&lt;&amp;Position&gt; = positions.iter().collect();

    if let Some(position) = (0..(GRID_WIDTH * GRID_HEIGHT))
        .map(|_| Position {
            x: if cfg!(test) {
                3
            } else {
                (random::&lt;u16&gt;() % GRID_WIDTH) as i16
            },
            y: if cfg!(test) {
                5
            } else {
                (random::&lt;u16&gt;() % GRID_HEIGHT) as i16
            },
        })
        .find(|position| !positions_set.contains(position))
    {
        commands
            .spawn(SpriteBundle {
                sprite: Sprite {
                    color: FOOD_COLOR,
                    ..default()
                },
                ..default()
            })
            .insert(Food)
            .insert(position)
            .insert(Size::square(0.65));
    }
}
</code></pre>
<p>Outra possível otimização é:</p>
<pre><code class="language-rs">commands
    .spawn((SpriteBundle {
        sprite: Sprite {
            color: FOOD_COLOR,
            ..default()
        },
        ..default()
    }, Food, Size::square(0.65)))
    .insert(position);
</code></pre>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<p>Uma mudança importante para resources é que agora todo resource precisa implementar a trait <code>Resource</code> através da macro derive, então no  módulo <code>snake.rs</code> precisamos adicionar:</p>
<pre><code class="language-rs">#[derive(Default, Deref, DerefMut, Resource)] // &lt;-- Resource
pub struct Segments(Vec&lt;Entity&gt;);

#[derive(Default, Resource)] // &lt;-- Resource
pub struct LastTailPosition(Option&lt;Position&gt;);
</code></pre>
<p>Além disso, o jeito de adicionar <code>WindowDescriptor</code> ao <code>App</code> mudou, pois agora o <code>WindowDescriptor</code> é parte do <code>WindowPlugin</code>, que deve ser configurado em <code>DefaultPlugins</code>:</p>
<pre><code class="language-rs">fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(WindowPlugin {
        window: WindowDescriptor {
            title: &quot;Snake Game&quot;.to_string(),
            width: 500.0,
            height: 500.0,
            ..default()
        },
        ..default()
      }))
        // REMOVER
        // .insert_resource(WindowDescriptor {
        //     title: &quot;Snake Game&quot;.to_string(),
        //     width: 500.0,
        //     height: 500.0,
        //     ..default()
        // })
        // .add_plugins(DefaultPlugins)
        .insert_resource(snake::Segments::default())
        .insert_resource(snake::LastTailPosition::default())
        .add_event::&lt;GrowthEvent&gt;()
        .add_event::&lt;GameEndEvent&gt;()
        .add_startup_system(setup_camera)
        .add_startup_system(snake::spawn_system)
        // ...
}     
</code></pre>
<p>Last thing on handling <code>Window</code> resource, the <code>Window::new</code> function now receives an Optional <code>raw_handle</code>, então nos testes em <code>grid.rs</code> devemos remover <code>let raw_window_handle = Some(RawWindowHandle::Web(WebHandle::empty()));</code> e modificar Window para:</p>
<pre><code class="language-rs"> let window = Window::new(
    WindowId::new(),
    &amp;descriptor, 400, 400, 1., None,
    None, // &lt;--
);
</code></pre>
<p>Migrações concluídas com esse código, caso ocorra alguma incompatibilidade com uma versão nova, por favor abra uma <a href="https://github.com/naomijub/Rust-game-dev/issues">issue</a> ou um PR nos repositórios do github <a href="https://github.com/naomijub/Rust-game-dev">livro</a> e <a href="https://github.com/naomijub/bevy-snake">codigo</a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiplayer-local"><a class="header" href="#multiplayer-local">Multiplayer Local</a></h1>
<p><strong>CORRIGIR ACENTOS EM TECLADO COMPATIVEL</strong>
Primeiro passo para entendermos um jogo multiplayer é criarmos as regras para o jogo executar corretamente no modo multiplayer, podemos fazer isso adicionando mais um player de forma local. O suporte ao multiplayer exige uma pequena refatoração, que sera por onde comecaremos.</p>
<h2 id="refatorando"><a class="header" href="#refatorando">Refatorando</a></h2>
<p>Com a atualização do Rust para versão <code>1.66</code>, o linter do Rust sugeriu algumas novas refatorações bem simples, mas muito bem observadas no modulo <code>grid</code>. A primeira é na função <code>translate_position</code> e na função <code>scale_sprite</code> que possuiam um casting desnecessário, podendo-se remover o <code>as f32</code> das chamadas de funções <code>window.width()</code> e <code>window.height()</code>:</p>
<pre><code class="language-rs">// Grid.rs
// Antes
fn scale_sprite(transform: &amp;mut Transform, sprite_size: &amp;Size, window: &amp;Window) {
    transform.scale = Vec3::new(
        sprite_size.width / GRID_WIDTH as f32 * window.width() as f32,
        sprite_size.height / GRID_HEIGHT as f32 * window.height() as f32,
        1.0,
    );
}

fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(pos.x as f32, window.width() as f32, GRID_WIDTH as f32),
        convert(pos.y as f32, window.height() as f32, GRID_HEIGHT as f32),
        0.0,
    );
}

// Depois
fn scale_sprite(transform: &amp;mut Transform, sprite_size: &amp;Size, window: &amp;Window) {
    transform.scale = Vec3::new(
        sprite_size.width / GRID_WIDTH as f32 * window.width(),
        sprite_size.height / GRID_HEIGHT as f32 * window.height(),
        1.0,
    );
}

fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(pos.x as f32, window.width(), GRID_WIDTH as f32),
        convert(pos.y as f32, window.height(), GRID_HEIGHT as f32),
        0.0,
    );
}
</code></pre>
<p>A segunda refatoração é, no mesmo módulo, a simplificação da função <code>convert</code> para utilizar a função <code>mul_add</code> em vez de uma multiplicação seguida por uma adição. A vantagem do uso de <code>mul_add</code> é que reduz os erros por arrendondamento que poderiam ser causados pelo uso de <code>f32</code>:</p>
<pre><code class="language-rs">// grid.rs
// Antes
fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    pos / grid_side_lenght * bound_window - (bound_window / 2.) + (tile_size / 2.)
}

// Depois
fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    (pos / grid_side_lenght).mul_add(bound_window, -bound_window / 2.) + (tile_size / 2.)
}
</code></pre>
<blockquote>
<p><strong>Trait <code>MulAdd</code></strong> equivale a representar <code>(self * a) + b</code> e tem como sintaxe <code>fn mul_add&lt;A: Self, B: Self&gt;(self, a: A, b: B) -&gt; Self</code>.</p>
</blockquote>
<p>Outra refatoração que fiz foi para melhorar os resultados de testes em modo <code>release</code>  e em Windows, utilizando a biblioteca <code>approx = &quot;0.5.1&quot;</code>. Esta biblioteca garante uma comparação mais correta de epsilons de f32. Assim, podemos mudar todos os testes que contém comaprações de f32 para utilizar o <code>assert_relative_eq</code>, que recebe um epsilon de valor de erro na comparação:</p>
<pre><code class="language-rs">// grid.rs
mod test {
    use super::*;
    use approx::assert_relative_eq;

    fn convert_position_x_for_grid_width() {
        let x = convert(4., 400., GRID_WIDTH as f32);

        assert_relative_eq!(x, -20., epsilon = 0.00001);
    }

    #[test]
    fn convert_position_y_for_grid_height() {
        let x = convert(5., 400., GRID_HEIGHT as f32);

        assert_relative_eq!(x, 20., epsilon = 0.00001);
    }
    // ...
}
</code></pre>
<p>Por último, vamos atualizar os testes com múltiplas chamadas de <code>app.update()</code>. Fazemos isso substituíndo todas as linhas por um <code>for</code> com range:</p>
<pre><code class="language-rs">// Antes
app.update(); // 3 + 1
app.update(); // 3 + 2
app.update(); // 3 + 3
app.update(); // 3 + 4
app.update(); // 3 + 5
app.update(); // 3 + 6

// Depois
for _ in 0..6 {
    app.update(); // 3 + _
}
</code></pre>
<h2 id="criando-outro-player"><a class="header" href="#criando-outro-player">Criando Outro Player</a></h2>
<p>A primeira coisa que precisamos para começar a dar suporte para multiplayer local é adicionarmos o conceito de player, ou seja, um componente chamado <code>Player</code> que possui um <code>id</code> com o id do player, podemos fazer isso no módulo <code>components.rs</code>. Além disso, vale a pena criar uma função constante para retornar o valor de <code>id</code>:</p>
<pre><code class="language-rs">#[derive(Component, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Player {
    id: u8,
}

impl Player {
    pub const fn id(&amp;self) -&gt; usize {
        self.id as usize
    }
}
</code></pre>
<p>Depois disso, podemos aumentar o tamanho do mapa para que duas cobras possam andar juntas sem se colidir constantemente, fazemos isso mudando o valor da janela gerada no <code>WindowPlugin</code> para <code>1000f32</code>:</p>
<pre><code class="language-rs">.add_plugins(DefaultPlugins.set(WindowPlugin {
    window: WindowDescriptor {
        title: &quot;Snake Game&quot;.to_string(),
        width: 1000.0,
        height: 1000.0,
        ..default()
    },
    // ...
</code></pre>
<p>Somente esta mudança não garante mais espaço para duas cobras, assim, em <code>grid.rs</code> aumentamos a quantidade de tiles de <code>10</code> para <code>20</code>, mas apenas em modo release. Definimos compilação em modo <code>debug</code> com a flag de compilação <code>#[cfg(debug_assertions)]</code> e modo <code>release</code> com a flag de compilação <code>#[cfg(not(debug_assertions))]</code>, um <code>not</code> a mais:</p>
<pre><code class="language-rs">#[cfg(debug_assertions)]
pub(crate) const GRID_WIDTH: u16 = 10;
#[cfg(not(debug_assertions))]
pub(crate) const GRID_WIDTH: u16 = 20;
#[cfg(debug_assertions)]
pub(crate) const GRID_HEIGHT: u16 = 10;
#[cfg(not(debug_assertions))]
pub(crate) const GRID_HEIGHT: u16 = 20;
</code></pre>
<h3 id="testando-com-uma-janela-maior"><a class="header" href="#testando-com-uma-janela-maior">Testando com uma janela maior</a></h3>
<p>Essa mudança fará com que uma série de testes falhem em modo <code>release</code>, necessário para windows, assim, as correções passam a ser utilizar asserts ou declarações diferentes em modo <code>debug</code> e modo <code>release</code>. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Grid.rs
fn convert_position_x_for_grid_width() {
    let x = convert(4., 400., GRID_WIDTH as f32);

    #[cfg(debug_assertions)] // &lt;-- DEBUG
    assert_relative_eq!(x, -20., epsilon = 0.00001); // &lt;-- DEBUG
    #[cfg(not(debug_assertions))] // &lt;-- RELEASE
    assert_relative_eq!(x, -110., epsilon = 0.00001); // &lt;-- RELEASE
}

#[test]
fn translate_position_to_window() {
    let position = Position { x: 2, y: 8 };
    let mut default_transform = Transform::default();
    let expected = Transform {
        #[cfg(debug_assertions)] // &lt;-- DEBUG
        translation: Vec3::new(-100., 140., 0.), // &lt;-- DEBUG
        #[cfg(not(debug_assertions))] // &lt;-- RELEASE
        translation: Vec3::new(-150., -29.999996, 0.), // &lt;-- RELEASE
        ..default()
    };

    let mut descriptor = WindowDescriptor::default();
    descriptor.height = 400.;
    descriptor.width = 400.;
    let window = Window::new(WindowId::new(), &amp;descriptor, 400, 400, 1., None, None);
    translate_position(&amp;mut default_transform, &amp;position, &amp;window);
    
    assert_eq!(default_transform, expected);
}
<span class="boring">}
</span></code></pre></pre>
<p>Mais exemplos podem ser encontrados no <a href="https://github.com/naomijub/bevy-snake/pull/14/files">PR#14</a>, inclusive as mudanças para os testes das próximas partes.</p>
<h2 id="utilizando-player"><a class="header" href="#utilizando-player">Utilizando <code>Player</code></a></h2>
<p>Primeira mudança que fiz foi algo bem simples, mas muito representativo, adicionar uma outra cor de segmentos de cobra, <code>SNAKE_SEGMENT_COLOR</code> virou:</p>
<pre><code class="language-rs">const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);
const SNAKE1_SEGMENT_COLOR: Color = Color::rgb(0.8, 0.0, 0.8); // &lt;--
const SNAKE2_SEGMENT_COLOR: Color = Color::rgb(0., 0.8, 0.8); // &lt;--
</code></pre>
<p>Próximo passo é adicionarmos uma referência ao vetor de segmentos da segunda cobra, podemos fazer isso modificando a struct <code>Segments</code> para <code>pub struct Segments([Vec&lt;Entity&gt;; 2]);</code>, que significa que nossa struct <code>Segments</code> possui um array de tamanho 2 do tipo Vetor de <code>Entity</code>, assim o id do player 1 será <code>0</code> e o id do player 2 será <code>1</code>, conforme o sistema de indexação de arrays. Essa pequena mudança quebra todo nosso código para <code>snake.rs</code>, mas vou tentar explicar como ajustar as funções do modo mais lógico possível.</p>
<h3 id="sistema-de-geração-de-cobras-spawn"><a class="header" href="#sistema-de-geração-de-cobras-spawn">Sistema de Geração de Cobras (Spawn)</a></h3>
<p>Agora nosso sistema de spawn exige que segments seja um Array com dois vetores de entidades, para isso podemos refatorar o código dentro de <code>spawn_system</code> para ser reutilizável. Fazemos isso criando a função privada <code>spawn_entity_with_segment</code>, que recebe uma referência mutável de <code>Commands</code> e um <code>u8</code> que corresponderá ao id do Player. É importante que o segmento da cabeça da cobra seja ciente de qual seu <code>player_id</code>, para isso adicionamos essa informação nos componentes da primeira entidade, <code>.insert(components::Player { id: player_id })</code>, e que player 1 e player 2 não iniciem na mesma posição, para isso utilizamos um <code>if/else</code> na posição X do componente <code>Position</code>, defindindo a posição do player 1 em <code>x = 3</code>, e do player 2 em <code>x = GRID_WIDTH - 3</code>, <code>if player_id == 0 { 3 } else { (GRID_WIDTH - 3) as i16 }</code>:</p>
<pre><code class="language-rs">fn spawn_entity_with_segment(commands: &amp;mut Commands, player_id: u8) -&gt; Vec&lt;Entity&gt; {
    vec![
        commands
            .spawn(SpriteBundle {
                sprite: Sprite {
                    color: SNAKE_HEAD_COLOR,
                    ..default()
                },
                transform: Transform {
                    scale: Vec3::new(10.0, 10.0, 10.0),
                    ..default()
                },
                ..default()
            })
            .insert(components::Player { id: player_id })
            .insert(Head::default())
            .insert(Segment)
            .insert(Position {
                x: if player_id == 0 {
                    3
                } else {
                    (GRID_WIDTH - 3) as i16
                },
                y: 3,
            })
            .insert(Size::square(0.8))
            .id(),
        spawn_segment_system(
            commands,
            Position {
                x: if player_id == 0 {
                    3
                } else {
                    (GRID_WIDTH - 3) as i16
                },
                y: 2,
            },
            player_id,
        ),
    ]
}
</code></pre>
<p>Com essa mudança podemos atualizar a função <code>spawn_system</code> para chamar a função <code>spawn_entity_with_segment</code> para ambos os players:</p>
<pre><code class="language-rs">pub fn spawn_system(mut commands: Commands, mut segments: ResMut&lt;Segments&gt;) {
    *segments = Segments([
        spawn_entity_with_segment(&amp;mut commands, 0),
        spawn_entity_with_segment(&amp;mut commands, 1),
    ]);
}
</code></pre>
<p>Note que <code>spawn_entity_with_segment</code> recebe como argumento <code>commands: &amp;mut Commands</code> e por isso, devemos modificar o tipo de <code>commands</code> em <code>spawn_segment_system</code> para corresponder a mesma referência mutável. É nesta função, <code>spawn_segment_system</code> que vamos definir a cor dos segmentos de player que criamos anteriormente, com <code>if player_id == 0 { SNAKE1_SEGMENT_COLOR } else { SNAKE2_SEGMENT_COLOR }</code>:</p>
<pre><code class="language-rs">pub fn spawn_segment_system(commands: &amp;mut Commands, position: Position, player_id: u8) -&gt; Entity {
    commands
        .spawn(SpriteBundle {
            sprite: Sprite {
                color: if player_id == 0 {
                    SNAKE1_SEGMENT_COLOR
                } else {
                    SNAKE2_SEGMENT_COLOR
                },
                ..default()
            },
            transform: Transform {
                scale: Vec3::new(10.0, 10.0, 10.0),
                ..default()
            },
            ..default()
        })
        .insert(Segment)
        .insert(position)
        .insert(Size::square(0.65))
        .id()
}
</code></pre>
<h3 id="sistema-de-movimento"><a class="header" href="#sistema-de-movimento">Sistema de Movimento</a></h3>
<p>A base para o sistema de movimento é fazer com que o <code>wasd</code> mova o player 1 e as setas (<code>arrows</code>) movam o player 2. Agora, nosso <code>movement_input_system</code> não pode se restringir a iterar sobre <code>heads</code> apenas com <code>.next()</code>, já que sabemos que há pelo menos dois elementos em <code>heads</code>. Além disso, precisamos de uma forma de determinar de qual player estamos falando, por isso adicionamos o componente <code>Player</code> na <code>Query</code> de <code>heads</code>, <code>mut heads: Query&lt;(&amp;mut Head, &amp;Player)&gt;</code>, e iteramos sobre todos os elementos com um <code>iter_mut().for_each((mut head, player)| { ... })</code>. O resto do código segue a mesma lógica de antes:</p>
<pre><code class="language-rs">pub fn movement_input_system(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut heads: Query&lt;(&amp;mut Head, &amp;Player)&gt;,
) {
    heads.iter_mut().for_each(|(mut head, player)| {
        let dir: Direction = if player.id() == 0 {
            if keyboard_input.pressed(KeyCode::A) {
                Direction::Left
            } else if keyboard_input.pressed(KeyCode::S) {
                Direction::Down
            } else if keyboard_input.pressed(KeyCode::W) {
                Direction::Up
            } else if keyboard_input.pressed(KeyCode::D) {
                Direction::Right
            } else {
                head.direction
            }
        } else if player.id() == 1 {
            if keyboard_input.pressed(KeyCode::Left) {
                Direction::Left
            } else if keyboard_input.pressed(KeyCode::Down) {
                Direction::Down
            } else if keyboard_input.pressed(KeyCode::Up) {
                Direction::Up
            } else if keyboard_input.pressed(KeyCode::Right) {
                Direction::Right
            } else {
                head.direction
            }
        } else {
            head.direction
        };
        if dir != head.direction.opposite() {
            head.direction = dir;
        }
    });
}
</code></pre>
<p>A mudança no <code>movement_system</code> é essencialmente a mesma, agora precisamos adicionar a informação de <code>Player</code> na <code>Query</code> de <code>heads</code>, <code>heads: Query&lt;(Entity, &amp;Head, &amp;Player)&gt;,</code>, e refatorar a iteração sobre <code>heads</code> para ser um <code>for</code> em vez de um <code>.next()</code>, considerando que agora possuimos o <code>id</code> de <code>Player</code>, que causa colisão com o antigo <code>id</code>, que mudei para <code>entity_id</code>. Note que estamos destruturando o valor de <code>Player</code> em <code>id</code> ao utilizarmos <code>Player { id }</code> no <code>for</code> loop. A única outra grande mudança é que agora para acessarmos <code>segments</code>, precisamos indicar qual o <code>player_id</code> do segment, fazemos isso substituindo as referências a <code>segments</code> por <code>segments[player_id]</code>:</p>
<pre><code class="language-rs">pub fn movement_system(
    segments: ResMut&lt;Segments&gt;,
    mut last_tail_position: ResMut&lt;LastTailPosition&gt;,
    mut game_end_writer: EventWriter&lt;GameEndEvent&gt;,
    heads: Query&lt;(Entity, &amp;Head, &amp;Player)&gt;,
    mut positions: Query&lt;(Entity, &amp;Segment, &amp;mut Position)&gt;,
    game_end: Query&lt;&amp;GameEndEvent&gt;,
) {
    let positions_clone: HashMap&lt;Entity, Position&gt; = positions
        .iter()
        .map(|(entity, _segment, position)| (entity, position.clone()))
        .collect();
    for (entity_id, head, Player { id }) in heads.iter() {
        let player_id = (*id) as usize;
        (*segments[player_id]).windows(2).for_each(|entity| {
            if let Ok((_, _segment, mut position)) = positions.get_mut(entity[1]) {
                if let Some(new_position) = positions_clone.get(&amp;entity[0]) {
                    *position = new_position.clone();
                }
            };
        });
        if game_end.is_empty() {
            let _ = positions.get_mut(entity_id).map(|(_, _segment, mut pos)| {
                match &amp;head.direction {
                    Direction::Left =&gt; {
                        pos.x -= 1;
                    }
                    Direction::Right =&gt; {
                        pos.x += 1;
                    }
                    Direction::Up =&gt; {
                        pos.y += 1;
                    }
                    Direction::Down =&gt; {
                        pos.y -= 1;
                    }
                };
                if pos.x &lt; 0
                    || pos.y &lt; 0
                    || pos.x as u16 &gt;= GRID_WIDTH
                    || pos.y as u16 &gt;= GRID_HEIGHT
                {
                    game_end_writer.send(GameEndEvent::GameOver);
                }

                if positions_clone
                    .iter()
                    .filter(|(k, _)| k != &amp;&amp;entity_id)
                    .map(|(_, v)| v)
                    .any(|segment_position| &amp;*pos == segment_position)
                {
                    game_end_writer.send(GameEndEvent::GameOver);
                }
            });
        }
        *last_tail_position = LastTailPosition(Some(
            positions_clone
                .get(segments[player_id].last().unwrap())
                .unwrap()
                .clone(),
        ));
    }
}
</code></pre>
<h3 id="sistema-de-crescimento"><a class="header" href="#sistema-de-crescimento">Sistema de crescimento</a></h3>
<p>A única mudança realmente significativa no sistema de crescimento é que o evento <code>GrowthEvent</code> precisa ter informação de qual player deve crescer, fazmos isso adicionando a informação de player ao <code>GrowthEvent</code>:</p>
<pre><code class="language-rs">pub struct GrowthEvent {
    pub player_id: u8,
}
</code></pre>
<p>Agora, nosso <code>eating_system</code>, precisa transmitir a informação do <code>id</code> do <code>Player</code> para o <code>GrowthEvent</code>, fazemos isso adicionando <code>Player</code> a query de <code>head_positions</code>, <code>head_positions: Query&lt;(&amp;Position, &amp;Player), With&lt;Head&gt;&gt;,</code> e definindo o <code>id</code> destruturado como <code>player_id</code>  em <code>GrowthEvent</code>:</p>
<pre><code class="language-rs">pub fn eating_system(
    mut commands: Commands,
    mut growth_writer: EventWriter&lt;GrowthEvent&gt;,
    food_positions: Query&lt;(Entity, &amp;Position), With&lt;Food&gt;&gt;,
    head_positions: Query&lt;(&amp;Position, &amp;Player), With&lt;Head&gt;&gt;,
) {
    for (head_pos, Player { id }) in head_positions.iter() {
        for (ent, food_pos) in food_positions.iter() {
            if food_pos == head_pos {
                commands.entity(ent).despawn();
                growth_writer.send(GrowthEvent { player_id: *id });
            }
        }
    }
}
</code></pre>
<p>A próxima mudança é fazer com que o sistema de crescimento reconheça as informações relativas a <code>player_id</code>, contidas em <code>GrowthEvent</code>. Como pode haver mais de um evento no <code>EventBuffer</code>, precisamos iterar sobre o <code>growth_reader</code> com um <code>for_each</code>, em vez de um <code>.next()</code>, além disso, para garantir um sistema robusto, fazemos uma checagem se o <code>player_id</code> é menor que o tamanho do array <code>segments</code>, já que vamos acessar o array utilizando indexação sem checagem, <code>segments.[player_id]</code>. As outras mudanças simplesmente refletem as mudanças esperadas em <code>spawn_segment_system</code>:</p>
<pre><code class="language-rs">pub fn growth_system(
    mut commands: Commands,
    last_tail_position: Res&lt;LastTailPosition&gt;,
    mut segments: ResMut&lt;Segments&gt;,
    mut growth_reader: EventReader&lt;GrowthEvent&gt;,
) {
    growth_reader.iter().for_each(|event| {
        let player_id = event.player_id as usize;
        if player_id &lt; segments.len() {
            segments[player_id].push(spawn_segment_system(
                &amp;mut commands,
                last_tail_position.0.clone().unwrap(),
                event.player_id,
            ));
        }
    });
}
</code></pre>
<h2 id="corrigindo-os-bugs-finais"><a class="header" href="#corrigindo-os-bugs-finais">Corrigindo os bugs finais</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiplayer-online"><a class="header" href="#multiplayer-online">Multiplayer Online</a></h1>
<p><strong>ESTE CAPÍTULO SERÁ INICIADO SOMENTE APÓS OUTROS PROJETOS FOREM CONCLUÍDOS</strong> (~Março 2023)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>

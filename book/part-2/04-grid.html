<!DOCTYPE HTML>
<html lang="pt" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Grade de Movimento - Desenvolvimento de Jogos online com Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01-quemsou.html"><strong aria-hidden="true">1.1.</strong> Quem sou eu? (Sobre a autora)</a></li></ol></li><li class="chapter-item expanded "><a href="../part-1/00-capa.html"><strong aria-hidden="true">2.</strong> Conceitos Básicos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-1/01-arq.html"><strong aria-hidden="true">2.1.</strong> Arquitetura de servidores</a></li><li class="chapter-item expanded "><a href="../part-1/02-prd-rec.html"><strong aria-hidden="true">2.2.</strong> Predição e Reconciliação</a></li><li class="chapter-item expanded "><a href="../part-1/03-interpolacao.html"><strong aria-hidden="true">2.3.</strong> Interpolação de Entidades</a></li><li class="chapter-item expanded "><a href="../part-1/04-lag.html"><strong aria-hidden="true">2.4.</strong> Compensacão de Lag</a></li></ol></li><li class="chapter-item expanded "><a href="../part-2/00-intro.html"><strong aria-hidden="true">3.</strong> Multiplayer Local Snake Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-2/01-bevy.html"><strong aria-hidden="true">3.1.</strong> Sobre a Bevy</a></li><li class="chapter-item expanded "><a href="../part-2/02-ecs.html"><strong aria-hidden="true">3.2.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="../part-2/03-cabeca.html"><strong aria-hidden="true">3.3.</strong> A Cabeça da Cobra</a></li><li class="chapter-item expanded "><a href="../part-2/04-grid.html" class="active"><strong aria-hidden="true">3.4.</strong> Grade de Movimento</a></li><li class="chapter-item expanded "><a href="../part-2/05-spawnfood.html"><strong aria-hidden="true">3.5.</strong> Gerador de Comidas</a></li><li class="chapter-item expanded "><a href="../part-2/06-cadencia.html"><strong aria-hidden="true">3.6.</strong> Melhorando a Cadência do Movimento</a></li><li class="chapter-item expanded "><a href="../part-2/07-rabo.html"><strong aria-hidden="true">3.7.</strong> Adicionando um Rabo a Cobra</a></li><li class="chapter-item expanded "><a href="../part-2/08-colisoes.html"><strong aria-hidden="true">3.8.</strong> Colisões</a></li><li class="chapter-item expanded "><a href="../part-2/09-migrando-versoes.html"><strong aria-hidden="true">3.9.</strong> Migrando versões da Bevy</a></li><li class="chapter-item expanded "><a href="../part-2/10-multiplayer.html"><strong aria-hidden="true">3.10.</strong> Multiplayer Local</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Desenvolvimento de Jogos online com Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="grade-de-movimento"><a class="header" href="#grade-de-movimento">Grade de Movimento</a></h1>
<p>Nosso sistema de movimentação tem utilizado coordenadas da janela para fazer a movimentação, sendo o ponto <code>(0,0)</code> o centro da janela e cada unidade corresponde a um pixel, porém o snake game utiliza um sistema de grade. Assim, precisamos definir uma grade básica com tamanho da grade de <code>10 x 10</code> e células da grade com mais de 1 pixel para evitar janelas de 10 px por 10 px. Além disso, definir uma grade a partir do centro é bastante complexo, por isso vamos utilizar nosso próprio sistema de coordenadas e criar um sistema que faça a conversão. Nosso primeiro passo é adicionar constantes referentes ao tamnho da arena. É importante que estas constantes sejam definidas fora, pois quando iniciarmos o modo multiplayer <code>10 x 10</code> será muito pequena.</p>
<pre><code class="language-rs">// main.rs
mod snake;

const GRID_WIDTH: u16 = 10;
const GRID_HEIGHT: u16 = 10;

fn main() {
    // ...
}
</code></pre>
<p>As constantes <code>GRID_WIDTH</code> e <code>GRID_HEIGHT</code> referemm a largura da arena e a altura da arena, respectivamente. Agora criamos um novo módulo <code>components</code> que é responsável por gerenciar componentes básicos e transversair do jogo, como posição (<code>Position</code>) e tamanho de célula (<code>Size</code>):</p>
<pre><code class="language-rs">// main.rs
mod snake;
pub mod components;

const GRID_WIDTH: u16 = 10;
const GRID_HEIGHT: u16 = 10;
// ...

// components.rs
use bevy::prelude::Component;

#[derive(Component, Clone, Debug, PartialEq, Eq)]
pub struct Position {
    pub x: i16,
    pub y: i16,
}

#[derive(Component, Debug, PartialEq)]
pub struct Size {
    pub width: f32,
    pub height: f32,
}

impl Size {
    #[must_use]
    pub fn square(x: f32) -&gt; Self {
        Self {
            width: x,
            height: x,
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn sized_square_is_created_calling_square_fn() {
        let expected = Size {width: 3.14, height: 3.14};
        let actual = Size::square(3.14);

        assert_eq!(actual, expected);
    }
}
</code></pre>
<p>No arquivo de components precisamos apenas importar a trait <code>Component</code> e definir as structs <code>Position</code> com <code>x, y</code> e <code>Size</code> com <code>width,height</code>. O único teste presente é o <code>sized_square_is_created_calling_square_fn</code> pois ele testa se um quadrado de lado <code>f</code> é criado quando chamamos a função <code>Size::square</code>. Ou seja, <code>Size::square</code> é um método para ajudar a gerar células, ou qualquer outra coisa que tenha tamanho, de altura e largura iguais. Precisamos também usar o <code>#[must_use]</code> que a função precisa ser usada e evitarmos um warning no clippy. Outra coisa importante de salientar são as várias traits derivadas em <code>Position</code>, no futuro elas devem nos ajudar a utilizar <code>Position</code>. Próximo passo é incorporar estes componentes na cobra que temos:</p>
<p><code>snake.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::components::{Position, Size};
use bevy::prelude::*;


const SNAKE_HEAD_COLOR: Color = Color::rgb(0.7, 0.7, 0.7);

#[derive(Component)]
pub struct Head;

pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn(SpriteBundle {
            sprite: Sprite {
                color: SNAKE_HEAD_COLOR,
                ..default()
            },
            transform: Transform {
                scale: Vec3::new(10.0, 10.0, 10.0),
                ..default()
            },
            ..default()
        })
        .insert(Head) // Remover ;
        .insert(Position { x: 5, y: 5 }) // &lt;-
        .insert(Size::square(0.8));  // &lt;-
}
<span class="boring">}</span></code></pre></pre>
<p>Se executarmos os testes agora, vamos ver que não há nenhuma alteração significativa, pois todos os testes seguem passando. Agora precisamos de uma função auxiliar para gerenciar a escala de cáda célula da cobra e da grade, assim como uma função que faça a correspondência entre posição na grade e posição na janela. Vamos começar com a mais fácil, escala, que chamaremos de <code>size_scaling</code>. Antes, criamos um módulo chamado <code>grid</code> e movemos <code>GRID_WIDTH</code>e <code>GRID_HEIGHT</code> para este módulo:</p>
<pre><code class="language-rs">// grid.rs
use bevy::prelude::*;
use bevy::{prelude::*, window::PrimaryWindow};


const GRID_WIDTH: u16 = 10;
const GRID_HEIGHT: u16 = 10;

#[allow(clippy::missing_panics_doc)]
#[allow(clippy::needless_pass_by_value)]
pub fn size_scaling(
    primary_window: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    mut q: Query&lt;(&amp;Size, &amp;mut Transform)&gt;,
) {
    let window = primary_window.get_single().unwrap();
    for (sprite_size, mut transform) in &amp;mut q.iter_mut() {
        scale_sprite(transform.as_mut(), sprite_size, window);
    }
}

fn scale_sprite(transform: &amp;mut Transform, sprite_size: &amp;Size, window: &amp;Window) {
    transform.scale = Vec3::new(
        sprite_size.width / f32::from(GRID_WIDTH) * window.width(),
        sprite_size.height / f32::from(GRID_HEIGHT) * window.height(),
        1.0,
    );
}


#[cfg(test)]
mod test {
    use bevy::window::WindowResolution;
    use crate::components::Size;

    use super::*;

    #[test]
    fn transform_has_correct_scale_for_window() {
        // Setup
        let expected_transform = Transform { scale: Vec3::new(20., 20., 1.,),..default() };
        let mut default_transform = Transform { scale: Vec3::new(2., 3., 4.,),..default() };
        let sprite_size = Size::square(1.);

        // Create window
        let window = Window {
            resolution: WindowResolution::new(200., 200.),
            ..default()
        };


        // Apply scale
        scale_sprite(&amp;mut default_transform, &amp;sprite_size, &amp;window);

        assert_eq!(default_transform, expected_transform);
    }
}
</code></pre>
<p>Infelizmente, o recurso <code>Window</code> é bastante complicado de testar pois causa muitos problemas com o sistema de sincronização e agendamento do ECS da Bevy, por isto, neste caso não vamos testar o sistema em si, mas sim a lógica que o sistema chama, a função <code>scale_sprite</code>. A lógica de <code>size_scaling</code> é a seguinte: Se algo possui uma <code>Size.width</code> e uma <code>Size.height</code>, neste caso <code>sprite_size.width</code> e <code>sprite_size.height</code>, igual a 1.0, em uma grade de tamanho 40, em uma janela de tamanho 400 px, então a largura deveria ser 10, pois <code>1.0 / 40. * 400. = 10</code>. Ou seja, para este teste, os valores iniciais de <code>default_transform</code> não importam, apenas os valores préconfigurados de <code>Size</code>, <code>Window</code>, <code>GRID_WIDTH</code>e <code>GRID_HEIGHT</code>.
Colocamos também <code>#[allow(clippy::missing_panics_doc)]</code> <code>#[allow(clippy::needless_pass_by_value)]</code> na função por alguns conflitos com a API atual do bevy e o clippy isso pode não ser necessário em versões futuras.</p>
<p>A próxima função é a responsável por transformar a posição em uma coordenada de janela, então, de novo, não poderemos testar o sistema em si, apenas os blocos lógicos que serão divididos em 2:</p>
<ol>
<li>Função <code>convert</code> responsável por calcular o fator de conversão de posição para window.</li>
<li>Aplicar a conversão ao <code>Transform.translation</code>, posição na janela.</li>
</ol>
<p>Vamos criar 2 testes para <code>convert</code>:</p>
<pre><code class="language-rs">#[test]
fn convert_position_x_for_grid_width() {
    let x = convert(4., 400., GRID_WIDTH as f32);

    assert_eq!(x, -20.)
}

#[test]
fn convert_position_y_for_grid_height() {
    let y = convert(5., 400., GRID_HEIGHT as f32);

    assert_eq!(y, 20.)
}
</code></pre>
<p>Estes testes tem como principal objetivo, impedir mudanças que quebrem o código, assim, sua implementação é apenas:</p>
<pre><code class="language-rs">fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    pos / grid_side_lenght * bound_window - (bound_window / 2.) + (tile_size / 2.)
}
</code></pre>
<p>Calculamos o <code>tilesize</code> como o tamanho da janela dividido pela quantidade de elementos da grade. Depois a posição passa a ser em relação à grade, algo como <code>5/ 10 = 0.5</code> multilicado pelo tamanho da window, porém como a bevy o ponto <code>(0,0)</code> é no centro da janela, precisamos deslocal meia janela (<code>- (bound_window / 2.)</code>) e centralizar o tile com <code>+ (tile_size / 2.)</code>.</p>
<p>Próximo passo é criar a função que executa a translação do valor do componente <code>Position</code> para o correspondente da posição na janela no componente <code>Transform</code>, como é uma função muito simples, vamos adicionar apenas um teste básico:</p>
<pre><code class="language-rs">fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(f32::from(pos.x), window.width(), f32(GRID_WIDTH)),
        convert(f32::from(pos.y), window.height(), f32::from(GRID_HEIGHT)),
        0.0,
    );
}

// mod test:
#[test]
fn translate_position_to_window() {
    let position = Position {x: 2, y: 8};
    let mut default_transform= Transform::default();
    let expected = Transform { translation: Vec3::new(-100., 140., 0.,),..default() };

    // Create window
    let window = Window::new(WindowId::new(), &amp;descriptor, 400, 400, 1., None, raw_window_handle);
            let window = Window {
            resolution: WindowResolution::new(400., 400.),
            ..default()
        };

    
    // Apply translation
    translate_position(&amp;mut default_transform, &amp;position, &amp;window);

    assert_eq!(default_transform, expected);
}
</code></pre>
<p>Agora agregando tudo na função <code>position_translation</code> temos:</p>
<pre><code class="language-rs">#[allow(clippy::missing_panics_doc)]
#[allow(clippy::needless_pass_by_value)]
pub fn position_translation(
    primary_window: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    mut q: Query&lt;(&amp;Position, &amp;mut Transform)&gt;,
) {
    let window = primary_window.get_single().unwrap();
    for (pos, mut transform) in &amp;mut q.iter_mut() {
        translate_position(transform.as_mut(), pos, window);
    }
}

fn convert(pos: f32, bound_window: f32, grid_side_lenght: f32) -&gt; f32 {
    let tile_size = bound_window / grid_side_lenght;
    pos / grid_side_lenght * bound_window - (bound_window / 2.) + (tile_size / 2.)
}

fn translate_position(transform: &amp;mut Transform, pos: &amp;Position, window: &amp;Window) {
    transform.translation = Vec3::new(
        convert(f32::from(pos.x), window.width(), f32::from(GRID_WIDTH)),
        convert(f32::from(pos.y), window.height(), f32::from(GRID_HEIGHT)),
        0.0,
    );
}

</code></pre>
<p>Próximo passo é adicionar os sistemas que criamos à função main utilizando o <code>App::Builder</code>. Este sistema é um caso especial, pois deve ser executado após o método update já que qualquer componente que seja adicionado no update corrente será visivel somente no próximo estágio (por exemplo <code>PostUpdate</code> e <code>Draw</code>) e as funções  <code>position_translation</code> e <code>size_scaling</code> somente conseguiram ver nodos novos da cobra ou comidas nova no estágio seguinte. Esta configuração especial é representada utilizando o <code>PostUpdate</code>  na função de adicionar sistemas  <code>add_systems</code>:</p>
<pre><code class="language-rs">// main
use bevy::prelude::*;

pub mod components;
pub mod grid;
mod snake;

fn main() {
    App::new()
        .add_systems(Startup, setup_camera)
        .add_systems(Startup, snake::spawn_system)
        .add_plugins(DefaultPlugins)
        .add_systems(Update, snake::movement_system)
        .add_systems(PostUpdate, (grid::position_translation, grid::size_scaling))
        .run();
}

fn setup_camera(mut commands: Commands) {
    commands.spawn(Camera2dBundle::default());
}

</code></pre>
<p><img src="../imagens/simpleblock.png" alt="Resultado do código até agora" /></p>
<h2 id="corrigindo-a-movimentação-na-grade"><a class="header" href="#corrigindo-a-movimentação-na-grade">Corrigindo a Movimentação na Grade</a></h2>
<p>Até agora nosso sistema de movimento, <code>snake::movement_system</code>, era baseado em movimentar o componente <code>Transform</code> pela janela, porém com a implementação de grade precisamos atualizar o sistema para utilizar o componente <code>Position</code>. Primeiro passo será atualizar os testes para utilizar <code>Position</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// snake.rs
#[cfg(test)]
mod test {
    // ...

    #[test]
    fn snake_head_has_moved_up() {
        // Setup
        let mut app = App::new();
        let default_position = Position { x: 5, y: 6 }; // &lt;--

        // Adicionando sistemas
        app.add_systems(Startup, spawn_system)
            .add_systems(Update, movement_system);

        // Adicionando inputs de `KeyCode`s
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);

        // Executando sistemas pelo menos uma vez
        app.update();

        //Assert
        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;(); // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| { // &lt;--
            assert_eq!(&amp;default_position, position); // &lt;--
        })
    }
    #[test]
    fn snake_head_moves_up_and_right() {
        // Setup
        let mut app = App::new();
        let up_position = Position { x: 5, y: 6 }; // &lt;--

        // Adiciona systemas
        app.add_systems(Startup, spawn_system)
            .add_systems(Update, movement_system);

        // Testa movimento para cima
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;(); // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| { // &lt;--
            assert_eq!(position, &amp;up_position); // &lt;--
        });

        let up_right_position = Position { x: 6, y: 6 }; // &lt;--

        // Testa movimento para direita
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::D);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;(); // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| { // &lt;--
            assert_eq!(&amp;up_right_position, position); // &lt;--
        })
    }
    #[test]
    fn snake_head_moves_down_and_left() {
        // Setup
        let mut app = App::new();
        let down_left_position = Position { x: 4, y: 4 }; // &lt;--

        app.add_systems(Startup, spawn_system)
            .add_systems(Update, movement_system);

        // Movimenta para baixo
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::S);
        app.insert_resource(input);
        app.update();

        // Movimenta para esquerda
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::A);
        app.insert_resource(input);
        app.update();

        // Assert
        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;(); // &lt;--
        query.iter(&amp;app.world).for_each(|(_head, position)| { // &lt;--
            assert_eq!(&amp;down_left_position, position); // &lt;--
        })
    }
}

<span class="boring">}</span></code></pre></pre>
<p>Como agora estamos lidando com valores inteiros, nossos testes podem verificar se a posição mudou com <code>assert_eq!</code> em vez de utilizar expressões lógicas com <code>assert!</code>. Além disso, Position inicial com o valor <code>Position { x: 3, y: 3 }</code>, por isso os valores são maiores que <code>0</code>. Ao executarmos os testes veremos que todas as positions estão iguais a ``Position { x: 3, y: 3 }`, corrigimos isso modificando a função de input:</p>
<pre><code class="language-rs">// snake.rs
#[allow(clippy::needless_pass_by_value)]
pub fn movement_system(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut head_positions: Query&lt;&amp;mut Position, With&lt;Head&gt;&gt;,
) {
    for mut position in head_positions.iter_mut() {
        if keyboard_input.pressed(KeyCode::D) {
            position.x += 1;
        }
        if keyboard_input.pressed(KeyCode::W) {
            position.y += 1;
        }
        if keyboard_input.pressed(KeyCode::A) {
            position.x -= 1;
        }
        if keyboard_input.pressed(KeyCode::S) {
            position.y -= 1;
        }
    }
}
</code></pre>
<p>Agora sim, movimentamos o bloco célula a célula, infelizmente muito sensivel.</p>
<h2 id="configurando-a-janela"><a class="header" href="#configurando-a-janela">Configurando a Janela</a></h2>
<p>Próximo passo é fazermos com que a janela seja mais coerente com o snake game, já que por padrão a janela do snake game é quadrada enquanto a janela padrão da bevy é retangular. Para fazer isso, precisamos customizar o plugin <code>WindowsPlugin</code> dos plugins padrões do bevy, assim ele vai nos permitir configurar o tamanha da tela e o título da janela:</p>
<pre><code class="language-rs">// mains.rs
fn main() {
    App::new()
        .add_systems(Startup, setup_camera)
        .add_systems(Startup, snake::spawn_system)
        .add_plugins(
            DefaultPlugins
                .set(WindowPlugin {
                    primary_window: Some(Window {
                        resolution: (500.0, 500.0).into(),
                        title: "Snake".into(),
                        resizable: false,
                        ..default()
                    }),
                    ..default()
                })
                .build(),
        )
        .add_systems(PostUpdate, (grid::position_translation, grid::size_scaling))
        .add_systems(Update, snake::movement_system)
        .add_systems(PostUpdate, (grid::position_translation, grid::size_scaling))
        .run();
}
</code></pre>
<p>Outra mudança que pode ser interessante fazer é mudar o fundo da tela para ficar um pouco mais escuro, podemos fazer isso adicionando o recurso <code>.insert_resource(ClearColor(Color::rgb(0.04, 0.04, 0.04)))</code> depois do <code>WindowDescriptor</code>. Próximo passo é fazermos a comida aparecer.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part-2/03-cabeca.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part-2/05-spawnfood.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part-2/03-cabeca.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part-2/05-spawnfood.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

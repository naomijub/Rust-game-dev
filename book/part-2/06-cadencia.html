<!DOCTYPE HTML>
<html lang="pt" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Melhorando a Cadência do Movimento - Desenvolvimento de Jogos online com Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../0-capa.html"><strong aria-hidden="true">1.</strong> Capa</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01-quemsou.html"><strong aria-hidden="true">1.1.</strong> Quem sou eu? (Sobre a autora)</a></li></ol></li><li class="chapter-item expanded "><a href="../part-1/00-capa.html"><strong aria-hidden="true">2.</strong> Conceitos Básicos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-1/01-arq.html"><strong aria-hidden="true">2.1.</strong> Arquitetura de servidores</a></li><li class="chapter-item expanded "><a href="../part-1/02-prd-rec.html"><strong aria-hidden="true">2.2.</strong> Predição e Reconciliação</a></li><li class="chapter-item expanded "><a href="../part-1/03-interpolacao.html"><strong aria-hidden="true">2.3.</strong> Interpolação de Entidades</a></li><li class="chapter-item expanded "><a href="../part-1/04-lag.html"><strong aria-hidden="true">2.4.</strong> Compensacão de Lag</a></li></ol></li><li class="chapter-item expanded "><a href="../part-2/00-intro.html"><strong aria-hidden="true">3.</strong> Multiplayer Local Snake Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../part-2/01-bevy.html"><strong aria-hidden="true">3.1.</strong> Sobre a Bevy</a></li><li class="chapter-item expanded "><a href="../part-2/02-ecs.html"><strong aria-hidden="true">3.2.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="../part-2/03-cabeca.html"><strong aria-hidden="true">3.3.</strong> A Cabeça da Cobra</a></li><li class="chapter-item expanded "><a href="../part-2/04-grid.html"><strong aria-hidden="true">3.4.</strong> Grade de Movimento</a></li><li class="chapter-item expanded "><a href="../part-2/05-spawnfood.html"><strong aria-hidden="true">3.5.</strong> Gerador de Comidas</a></li><li class="chapter-item expanded "><a href="../part-2/06-cadencia.html" class="active"><strong aria-hidden="true">3.6.</strong> Melhorando a Cadência do Movimento</a></li><li class="chapter-item expanded "><a href="../part-2/07-rabo.html"><strong aria-hidden="true">3.7.</strong> Adicionando um Rabo a Cobra</a></li><li class="chapter-item expanded "><a href="../part-2/08-colisoes.html"><strong aria-hidden="true">3.8.</strong> Colisões</a></li><li class="chapter-item expanded "><a href="../part-2/09-migrando-versoes.html"><strong aria-hidden="true">3.9.</strong> Migrando versões da Bevy</a></li><li class="chapter-item expanded "><a href="../part-2/10-multiplayer.html"><strong aria-hidden="true">3.10.</strong> Multiplayer Local</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Desenvolvimento de Jogos online com Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="melhorando-a-cadência-do-movimento"><a class="header" href="#melhorando-a-cadência-do-movimento">Melhorando a Cadência do Movimento</a></h1>
<p>O atual movimento da cobra está ligado aos comandos do teclado diferentemente do snake game que a cobra se movimenta independente dos comandos do teclado e a cada x segundos, em vez de a cada frame. Para podermos fazer com que a cobra se movimente independente dos comandos do teclado, precisamos de uma forma de armazenar a direção que ela está se movimentando, além de evitar que a cobra vá para a direção oposta. Assim, precisamos criar o enum que armazena a direção e criar uma função que indica a direção oposta.</p>
<pre><code class="language-rs">// components.rs
#[test]
fn opposite_direction() {
    assert_eq!(Direction::Up.opposite(), Direction::Down);
    assert_eq!(Direction::Down.opposite(), Direction::Up);
    assert_eq!(Direction::Right.opposite(), Direction::Left);
    assert_eq!(Direction::Left.opposite(), Direction::Right);
}

// ...
#[derive(PartialEq, Debug, Copy, Clone)]
pub enum Direction {
    Left,
    Up,
    Right,
    Down,
}

impl Direction {
    pub fn opposite(self) -&gt; Self {
        match self {
            Self::Left =&gt; Self::Right,
            Self::Right =&gt; Self::Left,
            Self::Up =&gt; Self::Down,
            Self::Down =&gt; Self::Up,
        }
    }
}
</code></pre>
<p>Em uma etapa inicial do desenvolvimento, eu adicionaria Direction como um componente na entidade cobra, porém, a medida que a cobra ficar maior, vai ser difícil sincronizar a direção de cada elemento. Sabendo disso, vamos fazer um pouco de overengineering, e colocar <code>Direction</code> como elemento do componente <code>snake::Head</code>. Além disso, definimos a direção padrão como <code>Direction::Up</code> utilizando a trait <code>Default</code>:</p>
<pre><code class="language-rs">// snake.rs

#[derive(Component)]
pub struct Head {
    direction: Direction
}

impl Default for Head {
    fn default() -&gt; Self {
        Self { direction: Direction::Up }
    }
}

pub fn spawn_system(mut commands: Commands) {
    commands
        .spawn_bundle(SpriteBundle {
            sprite: Sprite {
                color: SNAKE_HEAD_COLOR,
                ..default()
            },
            transform: Transform {
                scale: Vec3::new(10.0, 10.0, 10.0),
                ..default()
            },
            ..default()
        })
        .insert(Head::default() ) // &lt;--
        .insert(Position { x: 5, y: 5 })
        .insert(Size::square(0.8));
}
</code></pre>
<h2 id="separando-o-movimento-em-duas-etapas"><a class="header" href="#separando-o-movimento-em-duas-etapas">Separando o movimento em duas etapas</a></h2>
<p>Agora que nossa cobra possui uma direção armazenada na cabeça podemos mudar seu sistema de movimento para que seja executado a cada 0.15 segundos, fazemos isso da mesma forma que fizemos com o sistema de geração de comidas:</p>
<pre><code class="language-rs">fn main() {
    App::new()
        .add_systems(Startup, setup_camera)
        .add_systems(Startup, snake::spawn_system)
        .insert_resource(ClearColor(Color::rgb(0.04, 0.04, 0.04)))
        .add_plugins(
            DefaultPlugins
                .set(WindowPlugin {
                    primary_window: Some(Window {
                        resolution: (500.0, 500.0).into(),
                        title: "Snake".into(),
                        resizable: false,
                        ..default()
                    }),
                    ..default()
                })
                .build(),
        )
        .add_systems(PostUpdate, (grid::position_translation, grid::size_scaling))
        .add_systems(Update, snake::movement_system)
        .add_systems(
            Update,
            food::spawn_system.run_if(on_timer(Duration::from_secs_f32(1.0))),
        )
        .add_systems(
            Update,
            snake::movement_system.run_if(on_timer(Duration::from_secs_f32(0.150))),
        )
        .add_systems(PostUpdate, (grid::position_translation, grid::size_scaling))
        .run();
}
</code></pre>
<p>Nosso sistema de movimento está atrelado à translação da cobra em uma posição para cada tecla que apertarmos e agora sabemos que o sistema de movimento deve ser independente do sistema de direção, que vamos chamar de <code>snake::movement_input_system</code>. Então precisamos que o sistema de input/direção aconteça antes do sistema de movimento, e, ainda, precisamos garantir que o sistema de movimento aconteça a cada <code>0.15</code> segundos. Para solucionar este problema, vamos adicionar uma função especial para sistemas <code>before</code>. Para utilizar está função, precisamos adicionar o sistema de input que vamos criar e indicar que ele deve ocorrer antes do sistema de movimento com <code>.add_systems(Update, snake::movement_input_system.before(snake::movement_system)</code>, adicione ao <code>App::new()</code> na função main. Agora vamos para o sistema <code>movement_input_system</code>.</p>
<p>Primeira coisa que devemos fazer é alterar os testes para considerar que o <code>snake::movement_system</code> recebe uma query com <code>Position</code> e <code>snake::Head</code>, além de considerar que o movimento é feito com base no enum <code>Direction</code> contido dentro de <code>snake::Head</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// snake.rs
    #[test]
    fn snake_starts_moviment_up() { // &lt;-- novo teste
        // Setup app
        let mut app = App::new();

        // Add startup system
        app.add_systems(Startup, spawn_system);


        // Run systems
        app.update();

        let mut query = app.world.query::&lt;&amp;Head&gt;();
        let head = query.iter(&amp;app.world).next().unwrap();
        assert_eq!(head.direction, Direction::Up);
    }

    #[test]
        fn snake_head_has_moved_up() {
        // Setup
        let mut app = App::new();
        let default_position = Position { x: 5, y: 6 };

        // Adicionando sistemas
        app.add_systems(Startup, spawn_system)
            .add_systems(Update, movement_system)
            .add_systems(Update, movement_input_system.before(movement_system));


        // Adicionando inputs de `KeyCode`s
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);

        // Executando sistemas pelo menos uma vez
        app.update();

        //Assert
        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
        query.iter(&amp;app.world).for_each(|(head, position)| {
            assert_eq!(&amp;default_position, position);
            assert_eq!(head.direction, Direction::Up); // &lt;-- novo assert

        })
    }

    #[test]
    fn snake_head_moves_up_and_right() {
        // Setup
        let mut app = App::new();
        let up_position = Position { x: 5, y: 6 };

        // Adiciona systemas
        app.add_systems(Startup, spawn_system)
            .add_systems(Update, movement_system)
            .add_systems(Update, movement_input_system.before(movement_system));

        // Testa movimento para cima
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::W);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
        query.iter(&amp;app.world).for_each(|(head, position)| {
            assert_eq!(position, &amp;up_position);
            assert_eq!(head.direction, Direction::Up); // &lt;- Novo assert
        });

        let up_right_position = Position { x: 6, y: 6 };

        // Testa movimento para direita
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::D);
        app.insert_resource(input);
        app.update();

        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
        query.iter(&amp;app.world).for_each(|(head, position)| {
            assert_eq!(&amp;up_right_position, position);
            assert_eq!(head.direction, Direction::Right); // &lt;- Novo assert

        })
    }


    #[test]
    fn snake_head_moves_down_and_left() {
        // Setup
        let mut app = App::new();
        let down_left_position = Position { x: 4, y: 6 };

        // Add systems
        app.add_startup_system(spawn_system)
            .add_system(movement_system)
            .add_system(movement_input_system.before(movement_system)); // &lt;--

        // Move Left
        let mut input = Input::&lt;KeyCode&gt;::default();
        input.press(KeyCode::A);
        app.insert_resource(input);
        app.update();

         // Move down
         let mut input = Input::&lt;KeyCode&gt;::default();
         input.press(KeyCode::S);
         app.insert_resource(input);
         app.update();

        // Assert
        let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
        query.iter(&amp;app.world).for_each(|(head, position)| {
            assert_eq!(&amp;down_left_position, position);
            assert_eq!(head.direction, Direction::Left);
        })
    }
    #[test]
    fn snake_cannot_start_moving_down() { // &lt;-- novo teste
         // Setup
         let mut app = App::new();
         let down_left_position = Position { x: 5, y: 6 };
 
         // Add systems
         app.add_systems(Startup, spawn_system)
            .add_systems(Update, movement_system)
 r          .add_systems(Update, movement_input_system.before(movement_system));
 
          // Move down
          let mut input = Input::&lt;KeyCode&gt;::default();
          input.press(KeyCode::S);
          app.insert_resource(input);
          app.update();
 
         // Assert
         let mut query = app.world.query::&lt;(&amp;Head, &amp;Position)&gt;();
         query.iter(&amp;app.world).for_each(|(_head, position)| {
             assert_eq!(&amp;down_left_position, position);
         })
    }

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Foram criados dois novos testes: <code>snake_starts_moviment_up</code> que checa se a cobra inicia seu movimento para cima. <code>snake_cannot_start_moving_down</code> checa que não é possível se movimentar na direção oposta.</p>
</blockquote>
<p>Com estes testes sabemos que o movement system agora deve receber uma query com a posição mutável e com a <code>Head</code> para obtermos a direção. Com base na direção, movemos a posição da cabeça:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn movement_system(mut heads: Query&lt;(&amp;mut Position, &amp;Head)&gt;) {
    if let Some((mut pos, head)) = heads.iter_mut().next() {
        match &amp;head.direction {
            Direction::Left =&gt; {
                pos.x -= 1;
            }
            Direction::Right =&gt; {
                pos.x += 1;
            }
            Direction::Up =&gt; {
                pos.y += 1;
            }
            Direction::Down =&gt; {
                pos.y -= 1;
            }
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Já o <code>movement_input_system</code> recebe uma leitura de teclado (<code>KeyCode</code>) e muda a direção com base nesta leitura do teclado e evita mudanças na direção oposta:</p>
<pre><code class="language-rs">pub fn movement_input_system(
    keyboard_input: Res&lt;Input&lt;KeyCode&gt;&gt;, 
    mut heads: Query&lt;&amp;mut Head&gt;) {
    if let Some(mut head) = heads.iter_mut().next() {
        let dir: Direction = if keyboard_input.pressed(KeyCode::A) {
            Direction::Left
        } else if keyboard_input.pressed(KeyCode::S) {
            Direction::Down
        } else if keyboard_input.pressed(KeyCode::W) {
            Direction::Up
        } else if keyboard_input.pressed(KeyCode::D) {
            Direction::Right
        } else {
            head.direction
        };
        if dir != head.direction.opposite() {
            head.direction = dir;
        }
    }
}
</code></pre>
<p>Ao executarmos <code>cargo run</code> podemos ver a cobra se movimentando sozinha e obedecendo o sistema de direção. Próximo passo é adicionarmos o rabo.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part-2/05-spawnfood.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part-2/07-rabo.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part-2/05-spawnfood.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part-2/07-rabo.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
